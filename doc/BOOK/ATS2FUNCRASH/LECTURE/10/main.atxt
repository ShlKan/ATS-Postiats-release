%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture10">
#title("Lazy Stream-Processing")

#para("\

A stream is like a list but it is lazy in the sense that the elements
in a stream are not required to be made available at the moment when
the stream is formed. Instead, each element only needs to be produced
at the point where the element is actually needed for evaluation.
Given a type T, the type #stacode("stream(T)") is for a value
representing a stream of elements of the type T. Let us use the name
stream-value to refer to such a value, which is completely opaque for
it does not even reveal whether the stream it represents is empty or
not. Internally, a stream-value is represented as a thunk, that is, a
nullary closure-function. Evaluating a stream-value (that is, calling
the thunk representing it) yields a stream-con value of type
#dyncode("stream_con(T)") for some T, where #dyncode("stream_con")
is the following declared datatype:

#sats2xhtml('\
datatype
stream_con(a:t@ype) =
  | steam_nil of ()
  | stream_cons of (a, stream(a))
')

With pattern matching, we can inspect whether a stream-con value
represents an empty stream or not. If the stream is non-empty, then
its first element can be extracted. Formally speaking, we have the
following type definition in ATS:

#sats2xhtml('\
typedef stream(a:t@ype) = lazy(stream_con(a))
')

where #stacode("lazy") is a special type constructor. Given a type
T, the type #stacode("lazy(T)") is essentially for a thunk that returns
a value of the type T. Often such a thunk is referred to as a suspended
computation of the type T, which can be resumed by simply calling the thunk.

")

#para("\

As an example, the following function #dyncode("int_stream_from")
takes an integer #dyncode("n") and returns a stream that enumerates
ascendingly all of the integers greater than or equal to
#dyncode("n"):

#dats2xhtml('\
//
fun
int_stream_from
  (n: int): stream(int) =
  $delay(stream_cons(n, int_stream_from(n+1)))
//
')

The keyword #keycode("$delay") indicates the construction
of a thunk based on the expression appearing as its argument.

")

#para("\

Accessing elements in a given stream is shown in the following
example:

#dats2xhtml('\
//
fun
{a:t@ype}
stream_get_at
  (xs: stream(a), n: int): a =
(
case+ !xs of
| stream_nil() =>
  (
    $raise StreamSubscriptExn()
  )
| stream_cons(x, xs) =>
  (
    if n <= 0 then x else stream_get_at<a>(xs, n-1)
  )
)
//
')

The function #dyncode("stream_get_at") is the stream-version of
#dyncode("list_get_at"): Given a stream and a position (denoted by an
integer), #dyncode("stream_get_at") returns the element in the stream
at the given position. Note that the symbol #dyncode("!") refers to
the function #dyncode("lazy_force"), which evaluates a given stream
value into a stream-con value in this case. Like
#dyncode("list_get_at"), it is almost always a poor style of
programming to make use of #dyncode("stream_get_at") excessively (for
instance, inside the body of a loop).

")

#para("\

Let us see what is involved in the evaluation of the following two
lines of code:

#dats2xhtml('\
//
val xs = int_stream_from(0)
val x0 = stream_get_at<int>(xs, 1000000)
//
')

The call to #dyncode("int_stream_from") returns immediately as all
that is essentially done is creating a thunk (that is, a nullary
closure-function). The call to #dyncode("stream_get_at") returns
1000000 after creating 1000001 nodes to store the first 1000001
elements in the stream bound to the name #dyncode("xs"). While it
takes only a tiny amount of memory to store the initial stream bound
to the name #dyncode("xs"), it requires a large amount of memory to
store the expanded stream created during the evaluation of the call to
#dyncode("stream_get_at"). In general, a call to
#dyncode("lazy_force") evaluates its argument (of type
#stacode("lazy(T)")) to a value (of type T) and then caches the value
internally so that the value can be returned immediately when another
call to #dyncode("lazy_force") on the same argument evaluates later.
In other words, some form of memoization happens when the evaluation
of a suspended computation is performed.  Memoization can be expensive
memory-wise and unpredicatable time-wise. There is another kind of
stream (to be presented later) that is referred to as
#emphasis("linear stream"), which involves no memoization when
evaluated. As a matter of fact, the internal representation of a
linear stream only needs memory for storing one node (that contains
the head element of the stream), resulting in great memory-efficiency.

")

#para("\

Basically, for each a list-processing function, there is a
corresponding version of stream-processing function. Let us see some
concrete examples.  For instance, the following function
#dyncode("stream_append") (corresponding to #dyncode("list0_append"))
concatenates two given streams:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
stream_append
(xs: stream(a), ys: stream(a)): stream(a)
//
implement
{a}(*tmp*)
stream_append
(xs, ys) = $delay
(
case+ !xs of
| stream_nil() => !ys
| stream_cons(x, xs) =>
  stream_cons(x, stream_append<a>(xs, ys))
)
//
')

Please note the symbol #dyncode("!") in front of #dyncode("!ys"):
The expression following #keycode("$delay") should evaluate to
a stream-con value (instead of a stream value).

")

#para("\

With streams, we can facilitate the use of (general) recursion in
problem-solving by eliminating the risk of stack overflow caused by
deeply nested recursive calls. In the case of
#dyncode("stream_append"), the evaluation of a call to
#dyncode("stream_append") returns immediately as all it does
essentially is to form a thunk (for representing the resulting
stream). On the other hand, the implementation of
#dyncode("list0_append") presented previously can potentially cause
stack overflow if its argument is a long list (e.g., one consisting of
1000000 elements). By the way, the actual implementation of
#dyncode("list0_append") in #filename("ATSLIB/prelude") (the prelude
library of ATS) cannot cause stack overflow due to its being
tail-recursive. However, there is no free lunch here as this library
implementation is written in an advanced style that is somewhat
difficult to adopt in practice.

")

#para("\

The following function #dyncode("stream_map") is the stream-version of
#dyncode("list0_map"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
stream_map
(xs: stream(a), fopr: cfun(a, b)): stream(b)
//
implement
{a}{b}
stream_map
  (xs, fopr) = $delay
(
case+ !xs of
| stream_nil() =>
  stream_nil()
| stream_cons(x, xs) =>
  stream_cons(fopr(x), stream_map<a><b>(xs, fopr))
)
//
')

")

#para("\

The following function #dyncode("stream_filter") is the stream-version of
#dyncode("list0_filter"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
stream_filter
(xs: stream(a), test: cfun(a, bool)): stream(a)
//
implement
{a}(*tmp*)
stream_filter
  (xs, test) = $delay
(
case+ !xs of
| stream_nil() =>
  stream_nil()
| stream_cons(x, xs) =>
  if test(x)
    then
    stream_cons
      (x, stream_filter<a>(xs, test))
    // end of [then]
    else !(stream_filter<a>(xs, test))
  // end of [if]
)
//
')

")

#para("\

A function like #dyncode("stream_map") and #dyncode("stream_filter")
is often referred to as being fully lazy as its evaluation does nothing
except for creating a thunk (to represent a suspended computation).

")

#para("\

The following function #dyncode("sieve") implements the sieve of
Eratosthenes for enumerating prime numbers:

#dats2xhtml('\
//
fun
sieve(): stream(int) = let
//
fun
auxmain
(
xs: stream(int)
) : stream(int) = $delay
(
case- !xs of
| stream_cons(x0, xs) =>
  stream_cons(x0, auxmain(stream_filter(xs, lam(x) => x % x0 > 0)))
)
//
in
  auxmain(int_stream_from(2))
end // end of [sieve]
//
')

A call to #dyncode("sieve") returns a stream consisting of all the
primes enumerated in the ascending order: 2, 3, 5, 7, 11, etc. Note
that #keycode("case-") is used in place of #keycode("case") for the
purpose of suppressing a warning message that would otherwise be
issued due to pattern matching being non-exhaustive (as the case
#dyncode("stream_nil()") is not covered).

")

#para("\

As a simple experiment, please try to evaluate the following code:

#dats2xhtml('\
//
val
thePrimes = sieve()
val () = println! ("stream_get_at(thePrimes, 5000):")
val () = println! (stream_get_at<int>(thePrimes, 5000))
val () = println! ("stream_get_at(thePrimes, 5000):")
val () = println! (stream_get_at<int>(thePrimes, 5000))
//
')

Note that the number #emphasis("48619") is to be printed out
twice. There is a clear pause before it is done for the first time,
but there is virtually no delay between the first time and the second
time, showing clearly the effect of memoization performed during the
first call to #dyncode("stream_get_at") on #dyncode("thePrimes").

")

#para("\

Lastly, let us see a simple but telling example that demonstrates a
stream-based approach to addressing the potential risk of stack
overflow due to deeply nested non-tail-recursive calls. The following
implementation of #dyncode("list0_map") is standard:

#dats2xhtml('\
//
implement
{a}{b}
list0_map
(xs, fopr) =
auxmain(xs) where
{
//
fun
auxmain
(
xs: list0(a)
) : list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(x), auxmain(xs))
)
//
} (* end of [list0_map] *)
//
')

Clearly, this implementation is not tail-recursive. When applied to a
long list (e.g., one consisting of 1000000 elements),
#dyncode("list0_map") runs a high risk of causing stack overflow. This
can become a very serious issue in practice if we ever want to apply
functional programming to a domain like machine learning where
processing large data is a norm rather than an exception. One
possibility is to insist on using only tail-recursion in the
implementation of a function like #dyncode("list0_map") that may need
to be applied to large data, but such a requirement or restriction can
clearly exert negative impact on the use of recursion in
problem-solving. After all, there are numerous algorithms that are
natrually expressed in terms of (general) recursion. And non-trivial
effort is often needed in order to implement such an algorithm based
on tail-recursion only, likely diminishing programming productivity.

")

#para("\

Another implementation of #dyncode("list0_map") is given as follows:

#dats2xhtml('\
//
implement
{a}{b}
list0_map(xs, fopr) = let
//
fun
auxmain
(
xs: list0(a)
) : stream(b) = $delay
(
case+ xs of
| list0_nil() => stream_nil()
| list0_cons(x, xs) => stream_cons(fopr(x), auxmain(xs))
)
//
in
  g0ofg1(stream2list(auxmain(xs)))
end // end of [list0_map]
//
')

What is special about this implementation of #dyncode("list0_map")
lies in the implementation of of the inner function
#dyncode("auxmain"), which turns a list into a stream. Calling
#dyncode("auxmain") runs no risk of stack overflow as it simply
creates a thunk (without issuing any recursive calls).  The library
function #dyncode("stream2list") turns a stream into a (linear) list,
which can be cast into a list0-value in O(1)-time by a call to
#dyncode("g0ofg1"). As #dyncode("stream2list") is implemented
tail-recursively, it can be safely called to generate a long list.
Consequently, this stream-based implementation of
#dyncode("list0_map") can be applied to a long list with no concern of
causing stack overflow. After linear lazy streams are introduced, we
are to see a significantly improved version of this stream-based
approach to resolving a common type of risk of stack overflow caused
by calling recursively defined functions for generating long lists.

")

#para("\

Please find #mycodelink("LECTURE/10/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture10"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

