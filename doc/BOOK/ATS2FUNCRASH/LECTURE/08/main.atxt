%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture08">
#title("Persistent Arrays and References")

#para("\

Let us start with references. A reference is precisely an
(initialized) singleton array, that is, an array of size 1, and its
typical use is for implementing a global variable that can be updated.

")

#para("\

The following function is for creating a reference:

#sats2xhtml('\
//
fun
{a:t@ype}
ref_make_elt(x0: a): ref(a)
//
')

where #stacode("ref") is a type constructor in ATS that takes a type T
to form a reference type #stacode("ref(T)") for any reference holding
a value of the type T.  The functions #dyncode("ref_get_elt") and
#dyncode("ref_set_elt") are for fetching and updating the value stored
in a reference, respectively:

#sats2xhtml('\
//
fun
{a:t@ype}
ref_get_elt(r: ref(a)): a
fun
{a:t@ype}
ref_set_elt(r: ref(a), x: a): void
//
')

A shorthand for #dyncode("ref_make_elt") is #dyncode("ref").  Also,
both #dyncode("!") and #dyncode("[]") are overloaded with
#dyncode("ref_get_elt") and #dyncode("ref_set_elt"). For instance, the
following code prints out 0, 1, and 3 twice:

#dats2xhtml('\
//
val r0 = ref<int>(0)
val () = println! (!r0)
val () = (!r0 := !r0 + 1)
val () = println! (!r0)
val () = (!r0 := !r0 + 2)
val () = println! (!r0)
//
val r1 = ref<int>(0)
val () = println! (r1[])
val () = (r1[] := r1[] + 1)
val () = println! (r1[])
val () = (r1[] := r1[] + 2)
val () = println! (r1[])
//
')

")

#para("\

Programmers often misuse references. This is especially true for those
with a background in imperative programming. For instance, the
following example shows a typical poor use of references that is often
resulted from someone learning functional programming by \"translating\"
code written in imperative style:

#dats2xhtml('\
//
fun
fact_ref
(n: int): int = let
//
val i = ref<int>(0)
val r = ref<int>(1)
//
fun loop(): void =
  if !i < n then (!i := !i+1; !r := !r * !i; loop())
//
in
  let val () = loop() in !r end
end (* end of [fact_ref] *)
//
')

There are some obvious drawbacks in this implementation of
#dyncode("fact_ref"). For evaluating each call to
#dyncode("fact_ref"), two references are created, which become garbage
after the call returns. As a reference is allocated on heap, it is not
mapped to a register when compiled. Accessing a reference involves
memory traffic, which is much more expensive than accessing a
register. Compared to a tail-recursive implementation of the factorial
function in functional style, #dyncode("fact_ref") is of great
inefficiency both time-wise and memory-wise.

")

#para("\

There is a type constructor #stacode("array0") in ATS that takes a
type T to form the array type #stacode("array0(T)") for an array
storing elements of the type T. We refer to such an array as an
array0-value, which is essentially a pair containing a pointer (to the
memory location where elements are stored) and an integer (indicating
the capacity of the array). For instance, the following function can
be called to create an array0-value:

#sats2xhtml('\
//
fun
{a:t@ype}
array0_make_elt(asz: int, x0: a): array0(a)
//
')

Given a non-negative integer #dyncode("asz") and an element
#dyncode("x0"), #dyncode("array0_make_elt") returns an array0-value in
which the array is of size #dyncode("asz") and each of its cells is
initialized with #dyncode("x0").

")

#para("\

Another commonly used function for creating an array0-value
is #dyncode("array0_tabulate") of the following interface:

#sats2xhtml('\
//
fun
{a:t@ype}
array0_tabulate(asz: int, fopr: cfun(int, a)): array0(a)
//
')

Given a non-negative integer #dyncode("asz") and a closure-function
#dyncode("fopr"), #dyncode("array0_tabulate") returns an array0-value
in which the array is of size #dyncode("asz") and the array cells are
initialized with the values of #dyncode("fopr") at the valid indices.

")

#para("\

The functions #dyncode("array0_get_at") and #dyncode("array0_set_at")
are for fetching and updating the value stored in an array0-value at a
given index:

#sats2xhtml('\
//
fun
{a:t@ype}
array0_get_at(A: array0(a), i: int): a
fun
{a:t@ype}
array0_set_at(A: array0(a), i: int, x: a): void
//
')

Note that #dyncode("array0_get_at") raises an exception
(#dyncode("ArraySubscriptExn()")) if the given index is invalid, that
is, not between 0 and the array size minus 1, inclusive.  And the same
happens with respect to #dyncode("array0_set_at").  Also please note
that the brackets #dyncode("[]") is overloaded with both
#dyncode("array0_get_at") and #dyncode("array0_set_at").  For
instance, evaluating the following code prints out two lines: the
first consisting of the text #dyncode("000") and the second consisting
of the text #dyncode("123"):

#dats2xhtml('\
//
val A =
array0_make_elt<int>(3, 0)
//
val () =
println! (A[0], A[1], A[2])
//
val () = A[0] := 1
val () = A[1] := A[0] + 1
val () = A[2] := A[1] + 1
//
val () =
println! (A[0], A[1], A[2])
//
')

")

#para("\

Like list0-values, there are many commonly used functions for
processing array0-values. For instance, the following function
#dyncode("array0_foreach") corresponds to the previouly presented
#dyncode("list0_foreach"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
array0_foreach
(A: array0(a), fwork: cfun(a, void)): void
//
implement
{a}(*tmp*)
array0_foreach(A, fwork) =
(
  int_foreach<>(sz2i(A.size()), lam(i) => fwork(A[i]))
) (* end of [array0_foreach] *)
//
')

Given an array0-value #dyncode("A"), the expression
#dyncode("A.size()") is written in dot-notation, which returns the
size of the array contained in #dyncode("A"). The name #dyncode("sz2i")
refers to a cast function from the type #stacode("size_t") to the type
#stacode("int").

")

#para("\

The following function
#dyncode("array0_foldleft") corresponds to the previouly presented
#dyncode("list0_foldleft"):

#dats2xhtml('\
//
extern
fun
{r:t@ype}
{a:t@ype}
array0_foldleft
(A: array0(a), r0: r, fopr: cfun(r, a, r)): r
//
implement
{r}{a}
array0_foldleft
  (A, r0, fopr) =
(
//
int_foldleft<r>
  (sz2i(A.size()), r0, lam(r, i) => fopr(r, A[i]))
//
) (* end of [array0_foldleft] *)
//
')

The following function
#dyncode("array0_foldright") corresponds to the previouly presented
#dyncode("list0_foldright"):

#dats2xhtml('\
//
extern
fun
{r:t@ype}
{a:t@ype}
array0_foldright
(A: array0(a), fopr: cfun(a, r, r), r0: r): r
//
implement
{r}{a}
array0_foldright
  (A, fopr, r0) = let
  val asz = sz2i(A.size())
in
  int_foldleft<r>(asz, r0, lam(r, i) => fopr(A[asz-i-1], r))
end (* end of [array0_foldright] *)
//
')

Unlike #dyncode("list0_foldright"), #dyncode("array0_foldright")
is tail-recursive.

")

#para("\

In practice, matrices (that is, two dimensional arrays) are also a
very common data structure. In ATS, there is a type constructor
#stacode("matrix0"), which takes a type T to form the type
#stacode("matrix0(T)") for a matrix storing elements of the type T. We
refer to such a matrix as a matrix0-value, which is essentially a
tuple containing a pointer (to the memory location where elements are
stored) and two integers (indicating the number of rows and the number
of columns of the matrix). For instance, the following function can be
called to create a matrix0-value:

#sats2xhtml('\
//
fun
{a:t@ype}
matrix0_make_elt(nrow: int, ncol: int, x0: a): matrix0(a)
//
')

Given two non-negative integers #dyncode("m") and #dyncode("n") and an
element #dyncode("x0"), #dyncode("matrix0_make_elt") returns a
matrix0-value in which the matrix is of dimension #dyncode("m") by
#dyncode("n") and each of its cells is initialized with
#dyncode("x0").

")

#para("\

Please note that the so-called row-major representation is chosen for
the matrix contained in each created matrix0-value. As the elements in
each row are stored adjacently in row-major representation, it can be
(much) more efficient to process the elements in the row-by-row fashion
(compared to the column-by-column fashion) due to the memory-cache effect.

")

#para("\

Like #dyncode("array0_tabulate"), the following function
#dyncode("matrix0_tabulate") is often called to create a
matrix0-value:

#sats2xhtml('\
//
fun
{a:t@ype}
matrix0_tabulate
  (nrow: int, ncol: int, fopr: cfun(int, int, a)): matrix0(a)
//
')

Given two non-negative integers #dyncode("m") and #dyncode("n") and a
closure-function #dyncode("fopr"), #dyncode("matrix0_tabulate")
returns a matrix0-value in which the matrix is of dimension
#dyncode("m") by #dyncode("n") and the matrix cells are initialized
with the values of #dyncode("fopr") at the valid indices.

")

#para("\

The functions #dyncode("matrix0_get_at") and
#dyncode("matrix0_set_at") are for fetching and updating the value
stored in a matrix0-value at a given position (represented by a row
index and a column index):

#sats2xhtml('\
//
fun{a:t0p}
matrix0_get_at
  (M: matrix0(a), i: int, j: int): a
fun{a:t0p}
matrix0_set_at
  (M: matrix0(a), i: int, j: int, x: a): void
//
')

Note that #dyncode("matrix0_get_at") raises an exception
(#dyncode("MatrixSubscriptExn()")) if one of the given indices is
invalid.  And the same happens with respect to
#dyncode("matrix0_set_at"). Also please note that the brackets
#dyncode("[]") is overloaded with both #dyncode("matrix0_get_at") and
#dyncode("matrix0_set_at").

")

#para("\

Like #dyncode("array0_foreach"), the following function
#dyncode("matrix0_foreach") applies to each element stored in the
matrix contained in #dyncode("M") a given closure-function
#dyncode("fwork"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
matrix0_foreach
(M: matrix0(a), fwork: cfun(a, void)): void
//
implement
{a}(*tmp*)
matrix0_foreach
  (M, fwork) = let
  val nrow = sz2i(M.nrow())
  val ncol = sz2i(M.ncol())
in
  int_cross_foreach<>(nrow, ncol, lam(i, j) => fwork(M[i,j]))
end (* end of [matrix0_foreach] *)
//
')

The expression #dyncode("M.nrow()") is written in dot-notation, which
returns the number of rows in the matrix contained in
#dyncode("M"). And #dyncode("M.ncol()") is for the number of columns
in the matrix.

")

#para("\

Please find #mycodelink("LECTURE/08/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture08"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

