%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture06">
#title("Functional List-Processing (2)")

#para("\

Sometimes, a list-processing function is partial in the sense that it
is not well-defined for all of the lists. For instance, the function
#dyncode("list0_head") for returning the head element of a given list
is defined only if the given list is non-empty:

#dats2xhtml('\
fun
{a:t@ype}
list0_head(xs: list0(a)): a =
(
case+ xs of
| list0_cons(x, _) => x
| _(* list0_nil() *) => $raise ListSubscriptExn()
)
')

Note that the code #dyncode("$raise ListSubscriptExn()") is for
raising an exception (in the case where #dyncode("xs") is empty),
which is to be explained in details later. Another approach to
handling a partial function is to turn it into a total one that
returns options. For instance, #dyncode("list0_head_opt") is such a
total function corresponding to #dyncode("list0_head"):

#dats2xhtml('\
//
datatype
option0(a:t@ype) = Some0 of (a) | None0 of ()
//
fun
{a:t@ype}
list0_head_opt
  (xs: list0(a)): option0(a) =
(
case+ xs of list0_cons(x, _) => Some0(x) | _ => None0()
)
')

The function returning the last element
of a given list is also partial as it is only defined
for a non-empty list. The following function
#dyncode("list0_last_opt") returns an option to indicate
whether the last element of a given list is found:

#dats2xhtml('\
//
fun
{a:t@ype}
list0_last_opt
(
xs: list0(a)
) : option0(a) = let
//
fun
loop
(x0: a, xs: list0(a)): a =
(
case+ xs of
list0_nil() => x0
| list0_cons(x1, xs) => loop(x1, xs)
)
//
in
//
case+ xs of
| list0_nil() => None0()
| list0_cons(x, xs) => Some0(loop(x, xs))
//
end // end of [list0_last_opt]
//
')

Note that the inner function #dyncode("loop") in the
body of #dyncode("list0_last_opt") is tail-recursive.

")

#para("\

Before moving on, I would like to point out a very common mistake in
(functional) list-processing. First and foremost, a list is not meant
to be used like an array. The following (partial) function
#dyncode("list0_get_at") does the so-called list-subscripting:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_get_at
(xs: list0(a), n: int): a
//
implement
{a}(*tmp*)
list0_get_at
  (xs, n) =
(
case+ xs of
| list0_nil() =>
  $raise ListSubscriptExn()
| list0_cons(x, xs) =>
  if n <= 0 then x else list0_get_at<a>(xs, n-1)
)
//
')

For instance, given the list #dyncode("(1,10,100)") and the index
#dyncode("1"), #dyncode("list0_get_at") return the element
#dyncode("10").  Another common name for #dyncode("list0_get_at") is
#dyncode("list0_nth"). Clearly, the time-complexity of
#dyncode("list0_get_at") is O(n) (while array-subscripting is
O(1)-time). It is almost always a poor programming style to process
the elements in a list by calling #dyncode("list0_get_at") (as the
resulting code is likely to be prohibitively inefficient
time-wise). For the purpose of illustration, let us take a look at the
following two functions for tallying the integers contained in a given
list:

#dats2xhtml('\
//
fun
list0_tally1
  (xs: list0(int)): int =
  list0_foldleft<int><int>(xs, 0, lam(res, x) => res + x)
//
fun
list0_tally2
  (xs: list0(int)): int =
  int_foldleft<int>
  (list0_length(xs), 0, lam(res, i) => res + list0_get_at<int>(xs, i))
//
')

Given a list #dyncode("xs") of length n, the function
#dyncode("list0_tally1") is O(n)-time while the function
#dyncode("list0_tally2") is O(n#sup("2"))-time. List-processing should
be done in the efficient style of #dyncode("list0_tally1") rather than
in the terribly inefficient style of #dyncode("list0_tally2"). In
general, please try to avoid doing list-subscripting repeatedly if the
involved index cannot be bounded by a small constant!

")

#para("\

Let us see more functions for performing functional
list-processing in the following presentation and an
example of functional programming at the end that illustrates some
typical use of list-processing functions.

")

#para("\

A commonly used (higher-order) function is often referred to as
list-map, which takes a list and a function and returns a newly
constructed list consisting of all of the elements obtained from
applying the function to each element in the given list:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list0_map
(xs: list0(a), fopr: cfun(a, b)): list0(b)
//
implement
{a}{b}
list0_map
(
  xs, fopr
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(x), auxlst(xs))
)
//
} (* end of [list0_map] *)
//
')

For instance, given the list #dyncode("(1, 2, 3, 4, 5)") and the
integer square function, #dyncode("list0_map") returns the list
consisting of #dyncode("1"), #dyncode("4"), #dyncode("9"),
#dyncode("16"), and #dyncode("25").\

")

#para("\

With #dyncode("list0_map"), we can readily build #dyncode("list0_cross")
as follows for computing the cross product of two given lists:

#dats2xhtml('\
//
extern
fun
{a,b:t@ype}
list0_cross
(xs: list0(a), ys: list0(b)): list0($tup(a, b))
//
implement
{a,b}(*tmp*)
list0_cross
  (xs, ys) = let
//
typedef ab = $tup(a, b)
//
in
//
list0_concat // for concatenating a list of lists
(
list0_map<a><list0(ab)>
  (xs, lam(x) => list0_map<b><ab>(ys, lam(y) => $tup(x, y)))
) (* end of [list0_concat] *)
//
end // end of [list0_cross]
//
')

For instance, given two lists #dyncode("(0, 1)")
and #dyncode("(2, 3, 4)"), #dyncode("list0_cross") returns a newly
constructed list consisting of the following six pairs: #dyncode("(0,
2)"), #dyncode("(0, 3)"), #dyncode("(0, 4)"), #dyncode("(1, 2)"),
#dyncode("(2, 3)"), and #dyncode("(3, 4)").

")

#para("\

A function rather similar to #dyncode("list0_map") is
#dyncode("list0_foreach"), which takes a list and a procedure (i.e., a
function returning void) and applies the procedure to each element in
the list:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_foreach
(xs: list0(a), fwork: cfun(a, void)): void
//
implement
{a}(*tmp*)
list0_foreach
(
  xs, fwork
) = loop(xs) where
{
//
fun
loop
(xs: list0(a)): void =
(
case+ xs of
| list0_nil() => ()
| list0_cons(x, xs) => (fwork(x); loop(xs))
)
//
} (* end of [list0_foreach] *)
//
')

")

#para("\

Another commonly used (higher-order) function is often referred to as
list-filter, which takes a list and a predicate (i.e., a function
returning a boolean value) and returns a newly constructed list
consisting of all of the elements in the given list that satisfy the
given predicate:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_filter
(xs: list0(a), test: cfun(a, bool)): list0(a)
//
implement
{a}(*tmp*)
list0_filter
(
  xs, test
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(a) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x, xs) =>
  if test(x)
    then list0_cons(x, auxlst(xs)) else auxlst(xs)
  // end of [if]
)
//
} (* end of [list0_filter] *)
//
')

For instance, given the list #dyncode("(1, 2, 3, 4, 5)")
and the predicate for testing whether an integer is even,
#dyncode("list0_filter") returns the list consisting of #dyncode("2")
and #dyncode("4").

")

#para("\

Given a list #dyncode("xs"), the following function
#dyncode("list0_remdup") removes all of the elements in #dyncode("xs")
that have already appeared previously:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_remdup
(xs: list0(a), eqfn: cfun(a, a, bool)): list0(a)
//
implement
{a}(*tmp*)
list0_remdup(xs, eqfn) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x0, xs) =>
  list0_cons(x0, list0_remdup<a>(list0_filter<a>(xs, lam(x) => eqfn(x0, x)), eqfn))
)
//
')

The implementation of #dyncode("list0_remdup") should clearly remind
one of the sieve of Eratosthenes, which is to be given a stream-based
implementation later.

")

#para("\

The list-processing function #dyncode("list0_map") processes every
element in its list argument and so does #dyncode("list0_filter").
Sometimes, we need a list-processing function that stops immediately
after certain condition is met. For instance, we may want to locate
the index of the first element in a given list that satisfies some test,
which can done by calling the following function #dyncode("list0_find_index"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_find_index
(xs: list0(a), test: cfun(a, bool)): int
//
implement
{a}(*tmp*)
list0_find_index
  (xs, test) = let
//
fun
loop
(xs: list0(a), i: int): int =
(
case+ xs of
| list0_nil() => ~1
| list0_cons(x, xs) =>
  if test(x) then i else loop(xs, i+1)
)
//
in
  loop(xs, 0)
end // end of [list0_find_index]
//
')

For instance, given the list #dyncode("(1, 2, 3)") and the predicate
for testing whether an integer is even, #dyncode("list0_find_index")
returns #dyncode("1") (which is the index for the element #dyncode("2")
in the given list). Note that #dyncode("~1") (negative 1) is returned
if no element satisfying the given predicate is found.

")

#para("\

Given a list0-value #dyncode("xs") and a predicate #dyncode("test"),
#dyncode("list0_exist") returns true if and only if there exists one
element in #dyncode("xs") satisfing #dyncode("test"), and
#dyncode("list0_forall") returns true if and only if every element in
#dyncode("xs") satisfies #dyncode("test"). Both of these two functions
can be readily implemented based on a direct call to
#dyncode("list0_find_index"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_exists
(xs: list0(a), test: cfun(a, bool)): bool
extern
fun
{a:t@ype}
list0_forall
(xs: list0(a), test: cfun(a, bool)): bool
//
implement
{a}(*tmp*)
list0_exists(xs, test) =
list0_find_index<a>(xs, test) >= 0
implement
{a}(*tmp*)
list0_forall(xs, test) =
list0_find_index<a>(xs, lam(x) => not(test(x))) < 0
//
')

")

#para("\

Given a list (x#sub("0"), ..., x#sub("n-1")) of length n, its indexed
version refers to the list of pairs in which the elements are of the form
(i, x#sub("i")) for i ranging from 0 to n-1.  For a function that
processes a given list, there is often a meaningful variant of the
function that processes the indexed version of the list. For instance,
the following function #dyncode("list0_imap") is such a variant of
#dyncode("list0_map"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list0_imap
(xs: list0(a), fopr: cfun(int, a, b)): list0(b)
//
implement
{a}{b}
list0_imap
(
  xs, fopr
) = auxlst(0, xs) where
{
//
fun
auxlst
(i: int, xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(i, x), auxlst(i+1, xs))
)
//
} (* end of [list0_imap] *)
//
')

Let us use #dyncode("list0_iexists") and #dyncode("list0_iforall") to
refer to the variants of #dyncode("list0_exists") and
#dyncode("list0_forall"), respectively, for processing indexed lists.
The code implementing #dyncode("list0_iexists") and #dyncode("list0_iforall")
is omitted for brevity.

")

#para("\

I have so far presented a variety of functions for processing lists in a
functional style. I would like to conclude the chapter with an example
of functional programming that can concretely demonstrate some typical use of
list-processing functions in practice.

")

#para("\

The famous 8-queen puzzle asks the player to find ways to put eight
queen pieces on a chess board such that no queen piece can attack any
other ones. In other words, no two queen pieces can be put on the same
row, the same column, or the same diagnal. This puzzle can be readily
solved with a tree-based search. Let us introduce an abstract type as
follows:

#dats2xhtml('\
abstype node = ptr
')

where #stacode("ptr") indicates that #stacode("node") is
boxed. Intuitively, a node represents a partial solution where there
are #emphasis("n") queen pieces (for some #emphasis("n") less than or
equal to 8) on the first #emphasis("n") rows of the chess board such
that no one piece can attack any other pieces. Given a node, another
node extending it with one more queen piece is considered its
child. The following declared function #dyncode("node_get_children")
is supposed to be called to obtain all of the child nodes of a given
node:

#dats2xhtml('\
extern
fun
node_get_children(node): list0(node)
overload .children with node_get_children
')

With
#dyncode("node_get_children"),
we can readily implement #dyncode("node_dfsenum") as follows
for enumerating in the depth-first manner all of the nodes contained
in the tree rooted at a given node:

#dats2xhtml('\
//
extern
fun
node_dfsenum(node): list0(node)
//
implement
node_dfsenum
(nx0) =
list0_cons
(
nx0
,
list0_concat<node>
(
list0_map<node><list0(node)>(nx0.children(), lam(nx) => node_dfsenum(nx))
) (* list0_concat *)
) (* node_dfsenum *)
//
')

In order to find all of the solutions to the 8-queen puzzle,
we just need to keep all of the nodes of length 8 that are contained
in the tree rooted at the initial node (representing the empty partial
soloution):

#dats2xhtml('\
//
extern
fun
QueenSolve(): list0(node)
//
\#define N 8
//
implement
QueenSolve() =
list0_filter<node>(node_dfsenum(node_init()), lam(nx) => node_length(nx) = N)
//
')

where #dyncode("node_init") returns the initial node and
#dyncode("node_length") returns the length of a node (that is, the
number queen pieces in the partial solution represented by the node).
By treating #stacode("node") as #stacode("list0(int)"), we
can implement #dyncode("node_init") and #dyncode("node_length")
as follows:

#dats2xhtml('\
//
assume node = list0(int)
//
implement
node_init() = list0_nil()
//
implement
node_length(nx) = list0_length(nx)
//
')

A node is represented as a list of integers; the length of the list
refers to the number of queen pieces on the chess board; the integers
(between 0 and N-1) in the list refer to the reversely listed column
positions of the queen pieces. The function #dyncode("node_get_children")
is implemented as follows:

#dats2xhtml('\
//
fun
test_safety
(
xs: list0(int)
) : bool = let
//
val-
list0_cons(x0, xs) = xs
//
in
//
list0_iforall<int> // abs: absolute value
  (xs, lam(i, x) => (x0 != x && abs(x0-x) != (i+1)))
//
end // end of [test_safety]
//
implement
node_get_children
  (nx) =
  list0_filter<node>
  (int_list0_map<node>
    (N, lam(x) => list0_cons(x, nx)), lam(nx) => test_safety(nx)
  )
//
')

The function #dyncode("test_safety") checks whether a column position
is safe for the next queen piece. Note that applying
#dyncode("int_list0_map") to an integer n is like applying
#dyncode("list0_map") to the list consisting of all of the integers
between 0 and n-1, inclusive.

")

#para("\

The presented code for solving 8-queen puzzle is of the kind of
high-level functional programming style I intend to advocate
throughout the book. It should soon be clear that we can reap even
more benefits from programming in this way when linear lazy streams
are used in place of functional lists.

")

#para("\

Please find #mycodelink("LECTURE/06/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture06"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

