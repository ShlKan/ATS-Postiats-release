%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture09">
#title("Raising and Catching Exceptions")

#para("\

Exceptions provide a mechanism for altering the (normal) control-flow
during program execution. Raising an exception is somewhat like
executing a goto-statement.  A handler for handling a raised exception
is essentially a pattern matching clause guarded by a pattern (for
matching exceptions).  Intuitively speaking, a raised exception passes
through a stack of handlers; the raised exception is handled by a
handler if the exception matches the guard of the handler, or it
simply tries the next handler to see if it can be handled; the raised
exception terminates program execution abnormally if it is not handled
by any of the handlers.

")

#para("\

In ATS, a try-expression (or try-with-expression) is of the form
(#keycode("try") exp #keycode("with") clseq), where #keycode("try") is
a keyword, exp is an expression, #keycode("with") is also a keyword,
and clseq is a sequence of pattern matching clauses (used as
exception-handlers). When evaluating such a try-expression, we first
evaluate exp. If the evaluation of exp leads to a value, then the
value is also the value of the try-expression. If the evaluation of
exp leads to a raised exception, then we match the exception against
the guards of the matching clauses in clseq. If there is a match, the
raised exception is caught and we continue to evaluate the body of the
first clause whose guard is matched. If there is no match, the raised
exception is uncaught. In the following example,
#dyncode("list0_exists") is implemented based on
#dyncode("list0_foreach"):

#dats2xhtml('\
//
implement
{a}(*tmp*)
list0_exists
  (xs, test) = let
//
exception True of ()
//
in
//
try let
//
val () =
list0_foreach<a>
( xs
, lam(x) => if test(x) then $raise True()
)
//
in
  false
end with ~True() => true
//
end // end of [list0_exists]
//
')

Given a list and a predicate, #dyncode("list0_exists") returns a
boolean value to indicate whether there exists an element in the list
that satisfies the predicate.  There is a built-in type
#stacode("exn") in ATS, which is somewhat like an extensible datatype
in the sense that a new constructor associated with #stacode("exn")
can be introduced through an exception-declaration. For instance,
#dyncode("True") is introduced as a nullary exception-constructor in
the body of #dyncode("list0_exists"). Given a list and a function,
#dyncode("list0_foreach") normally traverses until the end of the list
while appying the function to each encountered element.  When the call
to #dyncode("list0_foreach") in the body of #dyncode("list0_exists")
is evaluated, an exception (#dyncode("True()")) is raised to stop
further traversing if an element satisfying the predicate
#dyncode("test") is encountered.  If the call to to
#dyncode("list0_foreach") returns, then the value #dyncode("false") is
the return value of #dyncode("list0_exists").  If #dyncode("True()")
is raised during the evaluation of the call, then this raised
exception is to be caught by the handler following the keyword
#keycode("with"), resulting in the value #dyncode("true") becoming the
return value of #dyncode("list0_exists").  Note that a raised
exception is considered a resource in ATS and it needs to be properly
freed or re-raised after being caught. The symbol #dyncode("~") in the
pattern #dyncode("~True()") indicates that the caught execption is
freed.

")

#para("\

By raising an exception, a function can efficiently pass some
information gathered during its evaluation. Let us see a typical
example of this kind as follows. A datatype #stacode("tree") is
decared for representing binary trees:

#dats2xhtml('\
//
datatype tree(a:t@ype) =
| tree_nil of ()
| tree_cons of (tree(a), a, tree(a))
//
')

For instance, the function for computing the height of a given
binary tree can be implemented as follows:

#dats2xhtml('\
//
fun
{a:t@ype}
tree_height(t0: tree(a)): int =
(
case+ t0 of
| tree_nil() => 0
| tree_cons(tl, _, tr) =>
  1 + max(tree_height<a>(tl), tree_height<a>(tr))
)
//
')

Note that #dyncode("tree_height") is O(n)-time, where n is the size of
its argument.  A binary is perfect if it is empty or both of its
children are perfect and of the same height. For instance, the
following function #dyncode("tree_is_perfect") checks whether a given
binary tree is perfect:

#dats2xhtml('\
//
fun
{a:t@ype}
tree_is_perfect
  (t0: tree(a)): bool =
(
case+ t0 of
| tree_nil() => true
| tree_cons(tl, _, tr) =>
  tree_is_perfect<a>(tl) &&
  tree_is_perfect<a>(tr) &&
  (tree_height<a>(tl) = tree_height<a>(tr))
)
//
')

Clearly, the time complexity of #dyncode("tree_is_perfect") is
O(n(log(n))) where n is the size of its argument. By making use of
exception, we can readily implement the following function of
O(n)-time that also checks whether a given tree is perfect:

#dats2xhtml('\
//
fun
{a:t@ype}
tree_is_perfect2
  (t0: tree(a)): bool = let
//
exception NotPerfect of ()
//
fun
aux(t0: tree(a)): int =
case+ t0 of
| tree_nil() => 0
| tree_cons(tl, _, tr) => let
    val hl = aux(tl) and hr = aux(tr)
  in
    if hl = hr then 1+max(hl, hr) else $raise NotPerfect
  end
//
in
  try let val _ = aux(t0) in true end with ~NotPerfect() => false
end // end of [tree_is_perfect2]
//
')

The inner function #dyncode("aux") inside #dyncode("tree_is_perfect2")
returns the height of a given tree only if the tree is
perfect. Otherwise, an exception (#dyncode("NotPerfect()")) is
raised. In other words, if a call to #dyncode("aux") on a tree
returns, we know that the tree is pefect while obtaining its height.
This is often dubbed a #emphasis("hitting-two-birds-with-one-stone")
scenario.

")

#para("\

Please find #mycodelink("LECTURE/09/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture09"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

