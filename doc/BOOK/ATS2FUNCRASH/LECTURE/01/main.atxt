%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture01">
#title("Introducing ATS")

<sect1
 id="lecture01:whatis">
#title("What is ATS?")

#para('\

ATS is a statically typed programming language with a functional
programming core inspired by ML.
  
')


#para('\

Aiming at unifying implementation with formal specification, ATS is
equipped with a highly expressive type system rooted in the framework
Applied Type System, which in turn gives the language its name. In
particular, ATS supports practical use of both dependent types and
linear types in capturing program invariants.  Moreover, ATS supports
a form of embeddable templates in the sense that such a template may
be implemented inside the body of a function (so as to allow the
implementation to have direct access to the arguments of the
function), greatly facilitating code reuse. \

')

#para('\

There is also a subsystem ATS/LF in ATS for accommodating a
form of (interactive) theorem-proving where proofs are constructed as
total functions. With this subsystem, ATS is able to advocate a
programmer-centric approach to program verification that combines
programming with theorem-proving in a syntactically intertwined
manner. \

')

</sect1><!--id="lecture01:whatis"-->

<sect1
 id="lecture01:whylearn">
#title("What can ATS bring?")

#para('\

Learning ATS can help a programmer greatly enhance his or her
programming productivity.

')

#para('\

For most people, learning basic programming is easy and fun but there
seems to be no clear path for one to ever reach the level of a
programming expert who can confidently design and implement large and
complex software systems. It is very common to see that the initial
excitement one receives from some sort of exposure to programming is
quickly replaced with the endless need for debugging. And one may even
draw the conclusion that the only way to obtain functioning code of
quality is by going through a lengthy debugging process, which of course
is far from the truth.

')

#para('\

In this book, I will be primarily using ATS as a vehicle to teach a
style of programing that is often referred to as functional
programming (FP).  In particular, I will be advocating the use of
recursion in problem-solving as well as the need to prevent potential
stack overflow caused by deeply nested recursive function calls.  I
will also be demonstrating concretely and repeatedly that one can
drastically reduce the need for debugging by making extensive use of
types in programming.

')

</sect1><!--id="lecture01:whylearn"-->
  
<sect1>
#title("Installing ATS")

#para('\

There are many approaches to installing ATS.
Please visit this
<ulink url="http://www.ats-lang.org/Downloads.html">link</ulink>
for details.\

')

#para('\

I have a free account with <ulink url="http://c9.io/">Cloud-9</ulink>,
which allows me to gain on-line access to Ubuntu boxes. With such a
box, one can simply execute the following command-lines to install ATS
in a couple minutes:

<informalexample><programlisting>
<command>wget</command> https://ats-lang.github.io/SCRIPT/C9-ATS2-install-cs320.sh
<command>bash</command> -v C9-ATS2-install-cs320.sh
<command>source</command> ~/.bashrc ## this one only needs to be executed once for all
</programlisting></informalexample>

After installation is done, one can execute:
<informalexample><programlisting>
<command>which</command> patscc
</programlisting></informalexample>

and expect to see the following line of output:

<informalexample><programlisting>
/home/ubuntu/workspace/ATS2/bin/patscc
</programlisting></informalexample>

Note that the home directory for ATS is
#filename("/home/ubuntu/workspace/ATS2"), which is stored in an
environment variable of the name #emphasis("PATSHOME").
Please use #command("which") to check that the commands
#command("patsopt") and #command("myatscc") are also available.\

')

#para('\

By visiting <ulink
url="https://ide.c9.io/c9hwxi/ats-bucs320">ats-bucs320</ulink>, one
can browse the two installed directories of the names
#emphasis("ATS2") and #emphasis("ATS2-contrib") and the files
contained in them.  If re-installing ATS is ever needed, please
remember that the installed directories #emphasis("ATS2") and
#emphasis("ATS2-contrib") should be removed before the steps outlined
above for installation are repeated.

')


#para('\

Please note that more scripts for installing ATS can be found on-line at
<ulink url="http://www.ats-lang.org/Downloads.html\#Scripts_for_installing_ATS_Postiats">Scripts_for_installing_ATS</ulink>.

')

</sect1><!--id="lecture01:installing"-->

<sect1
 id="lecture01:compiling">
#title("Compiling ATS code")

#para('\

ATS code is first compiled into code written in a very restricted
subset of C. The generated C code from ATS source can then be compiled
into object code or transpiled into code written in a variety of
programming languages including Javascript, PHP, Perl, Python, Erlang,
Scheme, Clojure, etc.

')

#para('\

The command #command("patsopt") is for compiling ATS code into C code,
which can then be compiled into object code by a standard C compiler
such as #emphasis("gcc") and #emphasis("clang").  The command
#command("patscc") is a convenience wrapper around
#command("patsopt"), and it can be called, for instance, to compile
ATS code into object code directly. For compiling a single-file ATS
program into a standalone executable, the command #command("myatscc")
can be used instead.

')

#para('\

As an example, let us assume that
the following code (for printing out the string "Hello, world!" plus a newline)
is stored in a file of the name #filename("hello.dats"):

#dats2xhtml('\
//
val _ = print ("Hello, world!\\\\\\\\n")
//
implement main0 () = () // a dummy for [main]
//
')

One can produce an executable of the
name #filename("hello_dats") by simply executing the command-line below:

<informalexample><programlisting>
<command>myatscc</command> hello.dats
</programlisting></informalexample>

When the command #command("./hello_dats") is executed, the expected message
is printed onto the console. Please give it a try!

')

#para('\

When a project consisting of multiple files written in ATS needs to be compiled,
I often construct a Makefile and then rely on the #command("make") utility to
streamline the compilation process.

')

</sect1><!--id="lecture01:compiling"-->

<sect1
 id="lecture01:libaccessing">
#title("Accessing ATS libraries")

#para('\

There are many libraries in the ATS programming language system.  For
instance, the name #filename("ATSLIB/prelude") refers to the prelude
library in ATS that targets C code generation; the name
#filename("ATSLIB/libats") refers to the libats library in ATS that
targets C code generation as well; the name #filename("LIBATSCC2JS")
refers to a library for targeting Javascript (JS) code generation; the
name #filename("LIBATSCC2PHP") refers to a library for targeting PHP
code generation; etc.

')

#para('\

If a function is implemented as a template, the ATS compiler needs
to access the source of the function implementation in order to generate
code for each instance call of the function. For instance, the following
line can be added to the beginning of a file so as to indicate to the compiler
that #filename("ATSLIB/prelude") needs to be first loaded for compiling the
rest of the ATS code in the file:

#dats2xhtml('\
//
\#include "share/atspre_staload.hats"
//
')

For accessing the library #filename("ATSLIB/libats/ML") (which is
somewhat an ML-like portion of #filename("ATSLIB/libats")), the following line
can be used:

#dats2xhtml('\
//
\#include "share/atspre_staload_libats_ML.hats"
//
')

Various library functions are to be introduced in the sample code presented in this book.

')

</sect1><!--id="lecture01:libaccessing"-->

</chapter><!--id="lecture01"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
