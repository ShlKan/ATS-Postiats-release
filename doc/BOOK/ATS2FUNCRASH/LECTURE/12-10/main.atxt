%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture12-10">
#title("Example: A Bit More of Animation")

#para("\

With continuation, we can readily insert break points into the
execution of a program so as to support some interactive form of
program execution (e.g., animation).

")

#para("\

Hanoi Towers is a puzzle that is often chosen to illustrate recursion
and exponentiation.

Given three poles: Pole 1, Pole 2 and Pole 3, there are 64 disks of
distinct sizes stacked on Pole 1 such that no disk is stacked on one
of a lesser size, and both Pole 2 and Pole 3 are empty. The player is
asked to finish the task of moving all the disks from Pole 1 to Pole 2
(while using Pole 3 as a spare): Only one disk can be moved from one
pole to another one at any time and no disk is ever allowed to be
stacked on another one of a lesser size during the entire process of
disk-moving.\

")

#para("\

With recursion, it is quite straightforward for one to infer that
2#sup('64')-1 moves are needed in order to accomplish the aforementioned task.
For instance, the following code shows how this task can be done:

#dats2xhtml('\
//
extern
fun
move(src: pole, dst: pole): void
//
extern
fun
nmove(n: int, src: pole, dst: pole, tmp: pole): void
//
(* ****** ****** *)
//
implement
nmove
( n
, src, dst, tmp) =
if
(n > 0)
then
(
nmove(n-1, src, tmp, dst); move(src, dst); nmove(n-1, tmp, dst, src);
)
// end of [if] // end of [nmove]
//
')

Given two poles #dyncode("src") and #dyncode("dst"), the function
#dyncode("move"), which is not implemented here, moves the top disk at
pole #dyncode("src") and stack it on the top of the disks at pole
#dyncode("dst").  Given a natural number #dyncode("n") and three poles
#dyncode("src"), #dyncode("dst"), and #dyncode("tmp"), the function
#dyncode("nmove") moves the top #dyncode("n") disks at pole
#dyncode("src") and stack them on the top of the disks at pole
#dyncode("dst") while using pole #dyncode("tmp") as the spare.  Assume
that #dyncode("n") is greater than 0.  In order to move the top
#dyncode("n") disks from pole #dyncode("src") to pole #dyncode("dst"),
#dyncode("nmove") first moves the top #dyncode("n-1") disks from pole
#dyncode("src") to pole #dyncode("tmp") and then calls
#dyncode("move") to move 1 disk from pole #dyncode("src") to pole
#dyncode("dist") and then move the top #dyncode("n-1") disks from pole
#dyncode("tmp") to pole #dyncode("dst"). Note that #dyncode("nmove")
eventually makes #dyncode('2#sup("n")-1') calls to #dyncode("move")
for each given natural number #dyncode("n").\

")

#para("\

Suppose that we want to animate the process of disk-moving incurred
by calling #dyncode("nmove"). A very natural approach that we can take
is to first translate #dyncode("nmove") (implemented in the direct-style)
into the following #dyncode("k_nmove") implemented in the CPS-style:

")

#para("\

#dats2xhtml('\
//
typedef cont() = cfun(void)
//
extern
fun
k_move(src: pole, dst: pole, k: cont()): void
//
extern
fun
k_nmove(n: int, src: pole, dst: pole, tmp: pole, k: cont()): void
//
(* ****** ****** *)
//
implement
k_nmove
( n
, src, dst, tmp
, k0 ) =
if
(n > 0)
then
(
k_nmove
( n-1, src, tmp, dst
, lam() => k_move(src, dst, lam() => k_nmove(n-1, tmp, dst, src, k0)))
)
else k0((*void*))
// end of [if] // end of [k_nmove]
//
')

")

#para("\

Usually, the function #dyncode("k_move") is expected to be implemented
in the follow way:

#dats2xhtml('\
//
implement
k_move
(src, dst, k0) = let
  val () = move(src, dst) in k0()
end // end of [k_move]
//
')

After calling #dyncode("move") to create some effects,
#dyncode("k_move") calls the passed continuation immediately to
initiate the work to be continued. For the sake of animation, the
function #dyncode("k_move") can be implemented as follows:

#dats2xhtml('\
//
implement
k_move
(src, dst, k0) = let
  val () = move(src, dst) in save_cont(k0)
end // end of [k_move]
//
')

where the function #dyncode("save_cont") stores a given continuation
somewhere so that it can be fetched and then called at a chosen point
in future.

")

#para("\

Please see <ulink
url=\"https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.html\">on-line</ulink>
a demo that animates the process of disk-moving involved in solving
the puzzle of Hanoi Towers, where the animation is achieved by a
controlled way of evaluating the continuation saved by each call to
#dyncode("k_move"). Also please refer to <ulink
url=\"https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.dats\">HanoiTowers.dats</ulink>
for various implementation details.

")

#para("\

Please find #mycodelink("LECTURE/12-10/CODE", "on-line") the entirety
of the code used in this chapter. The mentioned URL link(s) can be found as follows:

<itemizedlist>

<listitem>
#para("\
<ulink
url=\"https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.html\">https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.html</ulink>
")#comment("para")
</listitem>

<listitem>
#para("\
<ulink
url=\"https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.dats\">https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FUNCRASH/LECTURE/12-10/CODE/HanoiTowers.dats</ulink>
")#comment("para")
</listitem>

</itemizedlist>

")#comment("para")

</chapter><!--id="lecture12-10"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

