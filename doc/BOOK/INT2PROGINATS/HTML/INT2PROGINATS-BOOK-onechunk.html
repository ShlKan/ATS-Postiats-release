<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Introduction to Programming in ATS</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><META
NAME="KEYWORD"
CONTENT="ATS"><META
NAME="KEYWORD"
CONTENT="Programming"><META
NAME="KEYWORD"
CONTENT="Theorem-Proving"><META
NAME="KEYWORD"
CONTENT="Program-first"><META
NAME="KEYWORD"
CONTENT="Programmer-centric"><META
NAME="KEYWORD"
CONTENT="Verification"><META
NAME="KEYWORD"
CONTENT="Dependent Types"><META
NAME="KEYWORD"
CONTENT="Linear Types"><META
NAME="KEYWORD"
CONTENT="Function Templates"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="INT2PROGINATS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
>Introduction to Programming in ATS</A
></H1
><H2
CLASS="subtitle"
></H2
><H3
CLASS="author"
><A
NAME="AEN6"
></A
>Hongwei Xi</H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><br>
ATS&nbsp;Trustful&nbsp;Software,&nbsp;Inc.<br>
</P
></DIV
></DIV
><P
CLASS="copyright"
>Copyright &copy; 2010-201? Hongwei Xi</P
><DIV
><DIV
CLASS="abstract"
><P
></P
><A
NAME="AEN13"
></A
><P
>&#13;As a programming language, ATS is both syntax-rich and feature-rich.
This book introduces the reader to some core features of ATS, including
basic functional programming, simple types, (recursively defined)
datatypes, polymorphic types, dependent types, linear types, theorem-proving,
programming with theorem-proving (PwTP), and template-based programming.
Although the reader is not assumed to be familiar with programming in general,
the book is likely to be rather dense for someone without considerable
programming experience.
</P
><P
></P
></DIV
></DIV
><DIV
CLASS="legalnotice"
><P
></P
><A
NAME="AEN18"
></A
><P
>&#13;All rights are reserved. Permission is granted to print this document for personal use.
</P
><P
></P
></DIV
><HR></DIV
><HR><H1
><A
NAME="AEN30"
></A
>Dedication</H1
><P
>&#13;To Jinning, Zoe, and Chloe.
</P
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN32"
>Preface</A
></DT
><DT
>I. <A
HREF="#basic-functional-programming"
>Basic Functional Programming</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#preparation_for_starting"
>Preparation for Starting</A
></DT
><DD
><DL
><DT
><A
HREF="#a_running_program"
>A Running Program</A
></DT
><DT
><A
HREF="#a_template_for_single-file_programs"
>A Template for Single-File Programs</A
></DT
><DT
><A
HREF="#a_makefile_template"
>A Makefile Template</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#elements_of_programming"
>Elements of Programming</A
></DT
><DD
><DL
><DT
><A
HREF="#expressions_and_values"
>Expressions and Values</A
></DT
><DT
><A
HREF="#names_and_bindings"
>Names and Bindings</A
></DT
><DT
><A
HREF="#scopes_for_bindings"
>Scopes for Bindings</A
></DT
><DT
><A
HREF="#environments_for_evaluation"
>Environments for Evaluation</A
></DT
><DT
><A
HREF="#static_semantics"
>Static Semantics</A
></DT
><DT
><A
HREF="#primitive_types"
>Primitive Types</A
></DT
><DT
><A
HREF="#tuples_and_tuple_types"
>Tuples and Tuple Types</A
></DT
><DT
><A
HREF="#records_and_record_types"
>Records and Record Types</A
></DT
><DT
><A
HREF="#conditional_expressions"
>Conditional Expressions</A
></DT
><DT
><A
HREF="#sequence_expressions"
>Sequence Expressions</A
></DT
><DT
><A
HREF="#comments_in_code"
>Comments in Code</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#functions"
>Functions</A
></DT
><DD
><DL
><DT
><A
HREF="#functions-as-a-simple-form-of-abstraction"
>Functions as a Simple Form of Abstraction</A
></DT
><DT
><A
HREF="#function-arity"
>Function Arity</A
></DT
><DT
><A
HREF="#function-interface"
>Function Interface</A
></DT
><DT
><A
HREF="#evaluation-of-function-calls"
>Evaluation of Function Calls</A
></DT
><DT
><A
HREF="#recursive-functions"
>Recursive Functions</A
></DT
><DT
><A
HREF="#evaluation-of-recursive-function-calls"
>Evaluation of Recursive Function Calls</A
></DT
><DT
><A
HREF="#example-coin-changes-for-fun"
>Example: Coin Changes for Fun</A
></DT
><DT
><A
HREF="#tail-call-and-tail-recursion"
>Tail-Call and Tail-Recursion</A
></DT
><DT
><A
HREF="#example-the-eight-queens-puzzle"
>Example: The Eight-Queens Puzzle</A
></DT
><DT
><A
HREF="#mutually-recursive-functions"
>Mutually Recursive Functions</A
></DT
><DT
><A
HREF="#mutual-tail-recursion"
>Mutually Defined Tail-Recursion</A
></DT
><DT
><A
HREF="#envless-functions-and-function-closures"
>Envless Functions and Closure-Functions</A
></DT
><DT
><A
HREF="#higher-order-functions"
>Higher-Order Functions</A
></DT
><DT
><A
HREF="#example-binary-search-for-fun"
>Example: Binary Search for Fun</A
></DT
><DT
><A
HREF="#example-a-higher-order-fun-puzzle"
>Example: A Higher-Order Fun Puzzle</A
></DT
><DT
><A
HREF="#currying-and-uncurrying"
>Currying and Uncurrying</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#datatypes"
>Datatypes</A
></DT
><DD
><DL
><DT
><A
HREF="#patterns"
>Patterns</A
></DT
><DT
><A
HREF="#pattern-matching"
>Pattern-Matching</A
></DT
><DT
><A
HREF="#matching_clauses_and_case-expressions"
>Matching Clauses and Case-Expressions</A
></DT
><DT
><A
HREF="#enumerative_datatypes"
>Enumerative Datatypes</A
></DT
><DT
><A
HREF="#recursive_datatypes"
>Recursively Defined Datatypes</A
></DT
><DT
><A
HREF="#exhaustiveness_of_pattern-matching"
>Exhaustiveness of Pattern-Matching</A
></DT
><DT
><A
HREF="#example_binary_search_tree"
>Example: Binary Search Tree</A
></DT
><DT
><A
HREF="#example_evaluating_integer_expressions"
>Example: Evaluating Integer Expressions</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#parametric_polymorphism"
>Parametric Polymorphism</A
></DT
><DD
><DL
><DT
><A
HREF="#function_templates"
>Function Templates</A
></DT
><DT
><A
HREF="#polymorphic_functions"
>Polymorphic Functions</A
></DT
><DT
><A
HREF="#polymorphic_datatypes"
>Polymorphic Datatypes</A
></DT
><DT
><A
HREF="#example_function_templates_on_lists"
>Example: Function Templates on Lists</A
></DT
><DT
><A
HREF="#example_mergesort"
>Example: Mergesort on Lists</A
></DT
></DL
></DD
></DL
></DD
><DT
>II. <A
HREF="#support-for-practical-programming"
>Support for Practical Programming</A
></DT
><DD
><DL
><DT
>6. <A
HREF="#effecftul_programming_features"
>Effectful Programming Features</A
></DT
><DD
><DL
><DT
><A
HREF="#exceptions"
>Exceptions</A
></DT
><DT
><A
HREF="#example_testing_for_braun_trees"
>Example: Testing for Braun Trees</A
></DT
><DT
><A
HREF="#references"
>References</A
></DT
><DT
><A
HREF="#example_counter_implementation"
>Example: A Counter Implementation</A
></DT
><DT
><A
HREF="#arrays"
>Arrays</A
></DT
><DT
><A
HREF="#example_ordering_permutations"
>Example: Ordering Permutations</A
></DT
><DT
><A
HREF="#matrices"
>Matrices</A
></DT
><DT
><A
HREF="#example_estimating_the_constant_pi"
>Example: Estimating the Constant Pi</A
></DT
><DT
><A
HREF="#basic_input_and_output"
>Simple Input and Output</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#modularity"
>Modularity</A
></DT
><DD
><DL
><DT
><A
HREF="#types_as_a_form_of_specification"
>Types as a Form of Specification</A
></DT
><DT
><A
HREF="#static_and_dynamic_ats_files"
>Static and Dynamic ATS Files</A
></DT
><DT
><A
HREF="#generic_template_implementation"
>Generic Template Implementation</A
></DT
><DT
><A
HREF="#specific_template_implementation"
>Specific Template Implementation</A
></DT
><DT
><A
HREF="#abstract_types"
>Abstract Types</A
></DT
><DT
><A
HREF="#example_a_package_for_rationals"
>Example: A Package for Rationals</A
></DT
><DT
><A
HREF="#example_a_functorial_package_for_rationals"
>Example: A Functorial Package for Rationals</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#Cinteraction"
>Interaction with C</A
></DT
><DD
><DL
><DT
><A
HREF="#external_name"
>External Global Names</A
></DT
><DT
><A
HREF="#external_types_and_values"
>External Types and Values in ATS</A
></DT
><DT
><A
HREF="#inclusion_of_external_code"
>Inclusion of External Code in ATS</A
></DT
><DT
><A
HREF="#calling_external_functions"
>Calling External Functions in ATS</A
></DT
><DT
><A
HREF="#unsafe_c-style_programming_in_ats"
>Unsafe C-style Programming in ATS</A
></DT
><DT
><A
HREF="#exporting_types_and_values"
>Exporting Types in ATS for Use in C</A
></DT
><DT
><A
HREF="#example-constructing_a_statically_allocated_list"
>Example: Constructing a Statically Allocated List</A
></DT
></DL
></DD
></DL
></DD
><DT
>III. <A
HREF="#programming-with-dependent-types"
>Programming with Dependent Types</A
></DT
><DD
><DL
><DT
>9. <A
HREF="#introduction-to-dependent-types"
>Introduction to Dependent Types</A
></DT
><DD
><DL
><DT
><A
HREF="#enhanced_expressiveness_for_specification"
>Enhanced Expressiveness for Specification</A
></DT
><DT
><A
HREF="#constraint-solving_during_typechecking"
>Constraint-Solving during Typechecking</A
></DT
><DT
><A
HREF="#example_string_processing"
>Example: String Processing</A
></DT
><DT
><A
HREF="#example_binary_search_on_arrays"
>Example: Binary Search on Arrays</A
></DT
><DT
><A
HREF="#termination-checking_for_recursive_functions"
>Termination-Checking for Recursive Functions</A
></DT
><DT
><A
HREF="#dependent_types_for_debugging"
>Example: Dependent Types for Debugging</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#datatype_refinement"
>Datatype Refinement</A
></DT
><DD
><DL
><DT
><A
HREF="#dependent_datatypes"
>Dependent Datatypes</A
></DT
><DT
><A
HREF="#example_function_templates_on_lists_redux"
>Example: Function Templates on Lists (Redux)</A
></DT
><DT
><A
HREF="#example_mergesort_redux"
>Example: Mergesort on Lists (Redux)</A
></DT
><DT
><A
HREF="#sequentiality_of_pattern_matching"
>Sequentiality of Pattern Matching</A
></DT
><DT
><A
HREF="#example_fun_red-black_trees"
>Example: Functional Red-Black Trees</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#theorem-proving_in_ats_lf"
>Theorem-Proving in ATS/LF</A
></DT
><DD
><DL
><DT
><A
HREF="#encoding_relations_as_dataprops"
>Encoding Relations as Dataprops</A
></DT
><DT
><A
HREF="#constructing_proofs_as_total_functions"
>Constructing Proofs as Total Functions</A
></DT
><DT
><A
HREF="#example_distributivity_of_multiplication"
>Example: Distributivity of Multiplication</A
></DT
><DT
><A
HREF="#example_commutativity_of_multiplication"
>Example: Commutativity of Multiplication</A
></DT
><DT
><A
HREF="#datasorts"
>Algebraic Datasorts</A
></DT
><DT
><A
HREF="#example_establishing_properties_on_braun_trees"
>Example: Establishing Properties on Braun Trees</A
></DT
><DT
><A
HREF="#programmer_centric_theorem_proving"
>Programmer-Centric Theorem-Proving</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#programming_with_theorem-proving"
>Programming with Theorem-Proving</A
></DT
><DD
><DL
><DT
><A
HREF="#circumventing_nonlinear_constraints"
>Circumventing Nonlinear Constraints</A
></DT
><DT
><A
HREF="#example_safe_matrix_subscripting"
>Example: Safe Matrix Subscripting</A
></DT
><DT
><A
HREF="#specifying_with_precision"
>Specifying with Enhanced Precision</A
></DT
><DT
><A
HREF="#example_another_verified_factorial"
>Example: Another Verified Factorial</A
></DT
><DT
><A
HREF="#example_verified_fast_exponentiation"
>Example: Verified Fast Exponentiation</A
></DT
></DL
></DD
></DL
></DD
><DT
>IV. <A
HREF="#programming-with-linear-views-and-types"
>Programming with Views and Viewtypes</A
></DT
><DD
><DL
><DT
>13. <A
HREF="#introduction-to-views-and-viewtypes"
>Introduction to Views and Viewtypes</A
></DT
><DD
><DL
><DT
><A
HREF="#views_for_pointers"
>Views for Memory Access through Pointers</A
></DT
><DT
><A
HREF="#viewtypes_as_combination"
>Viewtypes as a Combination of Views and Types</A
></DT
><DT
><A
HREF="#lval_and_cbr"
>Left-Values and Call-by-Reference</A
></DT
><DT
><A
HREF="#stack-allocated_variables"
>Stack-Allocated Variables</A
></DT
><DT
><A
HREF="#heap-allocated-linear-closure-functions"
>Heap-Allocated Linear Closure-Functions</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#dataviews"
>Dataviews as Linear Dataprops</A
></DT
><DD
><DL
><DT
><A
HREF="#optional_views"
>Optional Views</A
></DT
><DT
><A
HREF="#disjunctive_views"
>Disjunctive Views</A
></DT
><DT
><A
HREF="#linear_arrays"
>Dataview for Linear Arrays</A
></DT
><DT
><A
HREF="#linear_strings"
>Dataview for Linear Strings</A
></DT
><DT
><A
HREF="#singly-linked_lists"
>Dataview for Singly-Linked Lists</A
></DT
><DT
><A
HREF="#view-changes"
>Proof Functions for View-Changes</A
></DT
></DL
></DD
><DT
>15. <A
HREF="#dataviewtypes"
>Dataviewtypes as Linear Datatypes</A
></DT
><DD
><DL
><DT
><A
HREF="#linear_optional_values"
>Linear Optional Values</A
></DT
><DT
><A
HREF="#linear_lists"
>Linear Lists</A
></DT
><DT
><A
HREF="#example_mergeSort_lin"
>Example: Merge-Sort on Linear Lists</A
></DT
><DT
><A
HREF="#example_insertionSort_lin"
>Example: Insertion Sort on Linear Lists</A
></DT
><DT
><A
HREF="#example_quickSort_lin"
>Example: Quick-Sort on Linear Lists</A
></DT
><DT
><A
HREF="#linear_binary_search_trees"
>Linear Binary Search Trees</A
></DT
><DT
><A
HREF="#transition_from_datatypes_to_dataviewtypes"
>Transition from Datatypes to Dataviewtypes</A
></DT
></DL
></DD
><DT
>16. <A
HREF="#abstract_views_viewtypes"
>Abstract Views and Viewtypes</A
></DT
><DD
><DL
><DT
><A
HREF="#simple-linear-objects"
>Simple Linear Objects</A
></DT
><DT
><A
HREF="#memory-allocation-deallocation"
>Memory Allocation and Deallocation</A
></DT
><DT
><A
HREF="#array-based-circular-buffers"
>Example: Array-Based Circular Buffers</A
></DT
><DT
><A
HREF="#locking-and-unlocking"
>Locking and Unlocking</A
></DT
><DT
><A
HREF="#linear-channels-for-async-ipc"
>Linear Channels for Asynchronous IPC</A
></DT
></DL
></DD
></DL
></DD
><DT
>V. <A
HREF="#programming-with-function-templates"
>Programming with Function Templates</A
></DT
><DD
><DL
><DT
>17. <A
HREF="#from-genericity-to-late-binding"
>From Genericity to Late-Binding</A
></DT
><DD
><DL
><DT
><A
HREF="#genericity-of-template-implementations"
>Genericity of Template Implementations</A
></DT
><DT
><A
HREF="#generic-operations-on-numbers"
>Example: Generic Operations on Numbers</A
></DT
><DT
><A
HREF="#templates-as-a-special-form-of-functors"
>Templates as a Special Form of Functors</A
></DT
><DT
><A
HREF="#template-for-loop-construction"
>Example: Templates for Loop Construction</A
></DT
><DT
><A
HREF="#template-based-support-for-late-binding"
>Template-Based Support for Late-Binding</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="preface"
><HR><H1
><A
NAME="AEN32"
></A
>Preface</H1
><P
>&#13;<A
HREF="http://www.ats-lang.org"
TARGET="_top"
>ATS</A
> is a statically
typed programming language that unifies implementation with formal
specification. Within ATS, there are two sublanguages: one for
specification and the other for implementation, and there is also a
theorem-proving subsystem for verifying whether an implementation indeed
implements according to its specification.  If I could associate only one
single word with ATS, I would choose the word
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>precision</I
></SPAN
>.  Programming in ATS is about being precise
and being able to effectively enforce precision. This point will be
demonstrated concretely and repeatedly in this book.
</P
><P
>&#13;In order to be precise in building software systems, we need to specify
what such a system is expected to accomplish. In the current day and age,
software specification, which is used in a rather loose sense here, is
often done in forms of varying degrees of formalism, ranging from verbal
discussions to pencil/paper drawings to diagrammatic depictions in modeling
languages such as UML to text descriptions in formal specification
languages such as VDM and Z. Often the main purpose of software
specification is to establish some mutual understanding among a team of
developers.  After the specification for a software system is done, either
formally or informally, we need to implement the specification in a
programming language.  In general, it is exceedingly difficult to be
reasonably certain whether an implementation actually meets its
specification. Even if the implementation coheres well with its
specification initially, it nearly inevitably diverges from the
specification as the software system evolves. The dreadful consequences of
such a divergence are all too familiar; the specification becomes less and
less reliable for understanding the behavior of the software system while
the implementation gradually turns into its own specification; for the
developers, it becomes increasingly difficult and risky to maintain and
extend the software system; for the users, it requires increased amount of
time and effort to learn and use the software system.
</P
><P
>&#13;Largely inspired by Martin-Loef's constructive type theory, which was
originally developed for the purpose of establishing a foundation for
mathematics, I designed ATS in an attempt to combine specification and
implementation into a single programming language. There are a static
component (statics) and a dynamic component (dynamics) in ATS. Intuitively,
the statics and dynamics are each for handling types and programs,
respectively. In particular, specification is done in the statics. Given a
specification, how can we then effectively ensure that an implementation of
the specification (type) indeed implements according to the specification?
We request that the programmer who does the implementation also construct a
proof in the theorem-proving subsystem of ATS to demonstrate it.  This is a
style of program verification that puts the programmer at the center, and
thus we refer to it as a programmer-centric approach to program
verification.
</P
><P
>&#13;As a programming language, ATS is both syntax-rich and feature-rich. It can
support a variety of programming paradigms, including functional
programming, imperative programming, object-oriented programming,
concurrent programming, modular programming, etc. However, the core of ATS,
which is based on a call-by-value functional language, is surprisingly
simple, and this is where the journey of programming in ATS starts. In this
book, I will demonstrate primarily through examples how various programming
features in ATS can be employed effectively to facilitate the construction
of high-quality programs. I will focus on programming practice instead of
programming theory.  If you are primarily interested in the
type-theoretical foundation of ATS, then you have to find it elsewhere.
</P
><P
>&#13;If you can implement, then you are a good programmer.  In order to be a
better programmer, you should also be able to explain what you implement.
If you can guarantee what is implemented matches what is specified, then
you are surely the best programmer.  Hopefully, learning ATS will put you
on a wonderful exploring journey to become the best programmer. Let that
journey start now!

</P
></DIV
><DIV
CLASS="PART"
><A
NAME="basic-functional-programming"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
>I. Basic Functional Programming</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#preparation_for_starting"
>Preparation for Starting</A
></DT
><DT
>2. <A
HREF="#elements_of_programming"
>Elements of Programming</A
></DT
><DT
>3. <A
HREF="#functions"
>Functions</A
></DT
><DT
>4. <A
HREF="#datatypes"
>Datatypes</A
></DT
><DT
>5. <A
HREF="#parametric_polymorphism"
>Parametric Polymorphism</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="preparation_for_starting"
></A
>Chapter 1. Preparation for Starting</H1
><P
>&#13;It is likely that you want to write programs in the programming language
you are learning.  You may also want to try some of the examples included
in this book and see what really happens. So I will first show you how to
write in ATS a single-file program, that is, a program contained in a
single file, and compile it and then execute it.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="a_running_program"
>A Running Program</A
></H2
><P
>The following example is a program in ATS that prints out (onto the
console) the string "Hello, world!" plus a newline before it terminates:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN50"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> _ <span class="keyword">=</span> print <span class="keyword">(</span><span class="dynstr">"Hello, world!\n"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span> main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// a dummy for [main]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>val</FONT
> initiates a binding between the variable
<FONT
COLOR="RED"
>_</FONT
> (underscore) and the function call
<FONT
COLOR="RED"
>print("Hello, world!\n")</FONT
>.  However, this
binding is never used after it is introduced; its sole purpose is for
the call to the <FONT
COLOR="RED"
>print</FONT
> function to get evaluated. 
</P
><P
>&#13;The function <FONT
COLOR="RED"
>main0</FONT
> is a slight variant of another function
named <FONT
COLOR="RED"
>main</FONT
>, which is of certain special meaning in ATS. For a
programmer who knows the C or Java programming language, I simply point out
that the role of <FONT
COLOR="RED"
>main</FONT
> is essentially the same as its
counterpart of the same name in C or Java.  The keyword
<FONT
COLOR="RED"
>implement</FONT
> initiates the implementation of a function whose
interface has already been declared elsewhere. Following is the declared
interface for <FONT
COLOR="RED"
>main0</FONT
> in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN62"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> main0 <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


which indicates that <FONT
COLOR="RED"
>main0</FONT
> is a nullary function, that is, a
function taking no arguments, and it returns no value (or it returns the
void value). The double slash symbol (<FONT
COLOR="RED"
>//</FONT
>) initiates a comment
that terminates at the end of the current line.
</P
><P
>Suppose that you have already installed the ATS programming language
system. You can issue the following command-line to generate an executable
named <TT
CLASS="filename"
>hello</TT
> in the current working directory:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN68"
></A
><PRE
CLASS="programlisting"
>&#13;<B
CLASS="command"
>atscc</B
> -o hello hello.dats
</PRE
><P
></P
></DIV
>

where <TT
CLASS="filename"
>hello.dats</TT
> refers to a file containing the above
program.  The command <B
CLASS="command"
>atscc</B
> is essentially a convenience
wrapper around the command <B
CLASS="command"
>atsopt</B
>, which triggers the process
of typechecking and compiling ATS programs. Note that <B
CLASS="command"
>atscc</B
> and
<B
CLASS="command"
>atsopt</B
> may actually be given the names <B
CLASS="command"
>patscc</B
> and
<B
CLASS="command"
>patsopt</B
>, respectively, in certain installations of ATS.  The filename
extension <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>.dats</I
></SPAN
> should not be altered as it has already been
assigned a special meaning that the compilation command <B
CLASS="command"
>atscc</B
>
recognizes. Another special filename extension is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>.sats</I
></SPAN
>, which
we will soon encounter.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="a_template_for_single-file_programs"
>A Template for Single-File Programs</A
></H2
><P
>&#13;The following code template, which is available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_START/mytest.dats"
TARGET="_top"
>on-line</A
>, is designed for constructing a
single-file program in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN85"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">(*
**
** A template for single-file ATS programs
**
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#include</span> "share/atspre_define.hats"</span>
<span class="neuexp"><span class="keyword">#include</span> "share/atspre_staload.hats"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//</span>
<span class="comment">// please write you program in this section</span>
<span class="comment">//</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span> main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// a dummy implementation for [main]</span>

</p></PRE
><P
></P
></DIV
>


The line starting with the keyword <FONT
COLOR="RED"
>#include</FONT
> enables the ATS
compiler <B
CLASS="command"
>atsopt</B
> to gain access to certain external library
packages and the definitions of various library functions. I will cover
elsewhere in the book the topic on making use of library code in ATS.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="a_makefile_template"
>A Makefile Template</A
></H2
><P
>&#13;The following Makefile template, which is available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_START/Makefile_template"
TARGET="_top"
>on-line</A
>, is provided to help
you construct your own Makefile for compiling ATS programs. If you are not
familiar with the <B
CLASS="command"
>make</B
> utility, you could readily find plenty
resources on-line to help yourself learn it.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN94"
></A
><PRE
CLASS="programlisting"
>######
#
# Note that
# certain installations require the following changes:
#
# atscc -&#62; patscc
# atsopt -&#62; patsopt
# ATSHOME -&#62; PATSHOME
#
######
#
ATSHOMEQ="$(ATSHOME)"
#
######
#
ATSCC=$(ATSHOMEQ)/bin/atscc
ATSOPT=$(ATSHOMEQ)/bin/atsopt
#
######
#
#
# HX: Please uncomment the one you want, or skip it entirely
#
ATSCCFLAGS=
# ATSCCFLAGS=-O2
#
# '-flto' enables link-time optimization such as inlining lib functions
#
# ATSCCFLAGS=-O2 -flto
#
#
######
#
cleanall::
#
######
#
# Please uncomment the following three lines and replace the name [foo]
# with the name of the file you want to compile
#
# foo: foo.dats ; \
#   $(ATSCC) $(ATSCCFLAGS) -o $@ $&#60; || echo $@ ": ERROR!!!"
# cleanall:: ; $(RMF) foo
#
######
#
# You may find these rules useful
#
# %_sats.o: %.sats ; $(ATSCC) $(ATSCCFLAGS) -c $&#60; || echo $@ ": ERROR!!!"
# %_dats.o: %.dats ; $(ATSCC) $(ATSCCFLAGS) -c $&#60; || echo $@ ": ERROR!!!"
#
######
#
RMF=rm -f
#
######
#
clean:: ; $(RMF) *~
clean:: ; $(RMF) *_?ats.o
clean:: ; $(RMF) *_?ats.c
#
cleanall:: clean
#
###### end of [Makefile] ######
</PRE
><P
></P
></DIV
>

</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="elements_of_programming"
></A
>Chapter 2. Elements of Programming</H1
><P
>The core of ATS is a call-by-value functional programming language. I will
explain the meaning of <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>call-by-value</I
></SPAN
> in a moment. As
for functional programming, there is really no precise definition.  The
most important aspect of functional programming that I want to explore is
the notion of binding, which relates names to expressions.</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="expressions_and_values"
>Expressions and Values</A
></H2
><P
>&#13;ATS is both syntax-rich and feature-rich, and its grammar is probably more
complex than most existing programming languages. In ATS, there are a large
variety of forms of expressions, which I will introduce gradually.</P
><P
>&#13;Let us first start with some integer arithmetic expressions (IAEs):
<FONT
COLOR="RED"
>1</FONT
>, <FONT
COLOR="RED"
>~2</FONT
>, <FONT
COLOR="RED"
>1+2</FONT
>, <FONT
COLOR="RED"
>1+2*3-4</FONT
>,
<FONT
COLOR="RED"
>(1+2)/(3-4)</FONT
>, etc. Note that the negative sign is represented by
the tilde symbol (<FONT
COLOR="RED"
>~</FONT
>) in ATS.  There is also support for
floating point numbers, and some floating point constants are given here:
<FONT
COLOR="RED"
>1.0</FONT
>, <FONT
COLOR="RED"
>~2.0</FONT
>, <FONT
COLOR="RED"
>3.</FONT
>, <FONT
COLOR="RED"
>0.12345</FONT
>,
<FONT
COLOR="RED"
>2.71828</FONT
>, <FONT
COLOR="RED"
>31416E-4</FONT
>, etc. Note that <FONT
COLOR="RED"
>3.</FONT
>
and <FONT
COLOR="RED"
>31416E-4</FONT
> are the same as <FONT
COLOR="RED"
>3.0</FONT
> and
<FONT
COLOR="RED"
>3.1416</FONT
>, respectively. What I really want to emphasize at this
point is that <FONT
COLOR="RED"
>1</FONT
> and <FONT
COLOR="RED"
>1.0</FONT
> are two distinct numbers in
ATS: the former is an integer while the latter is a floating point number
(of double precision).</P
><P
>&#13;There are also boolean constants: <FONT
COLOR="RED"
>true</FONT
> and <FONT
COLOR="RED"
>false</FONT
>.
We can form boolean expressions such as <FONT
COLOR="RED"
>1 &#62;= 0</FONT
>,
<FONT
COLOR="RED"
>not(2-1 &#62;= 2)</FONT
>, <FONT
COLOR="RED"
>(1 &#60; 2) andalso (2 &#60; 3)</FONT
> and
<FONT
COLOR="RED"
>(~1 &#62; 1) orelse (~1 &#60;= 1)</FONT
>, where <FONT
COLOR="RED"
>not</FONT
>,
<FONT
COLOR="RED"
>andalso</FONT
> and <FONT
COLOR="RED"
>orelse</FONT
> stand for negation, conjunction
and disjunction, respectively. For programmers familiar with C-like syntax,
I point out that operators <FONT
COLOR="RED"
>&#38;&#38;</FONT
> and <FONT
COLOR="RED"
>||</FONT
> are synonyms
for <FONT
COLOR="RED"
>andalso</FONT
> and <FONT
COLOR="RED"
>orelse</FONT
>, respectively.  
</P
><P
>&#13;Other commonly used constant values include characters and strings.  For
instance, following are some character constants: <FONT
COLOR="RED"
>'a'</FONT
>,
<FONT
COLOR="RED"
>'B'</FONT
>, <FONT
COLOR="RED"
>'\n'</FONT
> (newline), <FONT
COLOR="RED"
>'\t'</FONT
> (tab),
<FONT
COLOR="RED"
>'\('</FONT
> (left parenthesis), <FONT
COLOR="RED"
>')'</FONT
> (right
parenthesis), <FONT
COLOR="RED"
>'\{'</FONT
> (left curly brace), <FONT
COLOR="RED"
>'}'</FONT
>
(right curly brace), etc; following are some string constants:
<FONT
COLOR="RED"
>"My name is Zoe"</FONT
>, <FONT
COLOR="RED"
>"Don't call me \"Chloe\""</FONT
>,
<FONT
COLOR="RED"
>"this is a newline:\n"</FONT
>, etc.
</P
><P
>&#13;Given a (function) name, say, foo, and an expression exp, the expression
foo(exp) is a function application or function call. The parentheses in
foo(exp) may be dropped if no ambiguity is created by doing so. For
instance, <FONT
COLOR="RED"
>print("Hello")</FONT
> is a function application, which can
also be written as <FONT
COLOR="RED"
>print "Hello"</FONT
>.  If foo is a nullary
function, then a function application foo() can be formed.  If foo is a
binary function, then a function application foo(exp1, exp2) can be formed
for expressions exp1 and exp2. Functions of more arguments can be treated
accordingly.
</P
><P
>&#13;Note that we cannot write <FONT
COLOR="RED"
>+(1,2)</FONT
> as the name <FONT
COLOR="RED"
>+</FONT
> has
already been given the infix status requiring that it be treated as an
infix operator.  However, we can write <FONT
COLOR="RED"
>op+(1,2)</FONT
>, where
<FONT
COLOR="RED"
>op</FONT
> is a keyword in ATS that can be used to temporarily suspend
the infix status of any name immediately following it. I will explain in
detail the issue of fixity (prefix, infix and postfix) elsewhere.
</P
><P
>&#13;Values are essentially expressions of certain special forms, which cannot
be reduced or simplified further. For instance, integer constants such as
<FONT
COLOR="RED"
>1</FONT
> and <FONT
COLOR="RED"
>~2</FONT
> are values, but the integer expression
<FONT
COLOR="RED"
>1+2</FONT
> is not a value, which can be reduced to the value
<FONT
COLOR="RED"
>3</FONT
>.  Evaluation refers to the computational process that reduces
a given expression into a value. However, certain expressions such as
<FONT
COLOR="RED"
>1/0</FONT
> cannot be reduced to a value, and evaluating such an
expression must abort at some point. I will gradually present more
information on evaluation.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="names_and_bindings"
>Names and Bindings</A
></H2
><P
>&#13;A crucial aspect of a programming language is the mechanism it provides for
binding names, which are themselves expressions, to expressions. For
instance, a declaration is introduced by the following syntax that declares
a binding between the name <FONT
COLOR="RED"
>x</FONT
>, which is also referred to as a
variable, and the expression <FONT
COLOR="RED"
>1+2</FONT
>:
</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN167"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> <span class="dynexp">1</span> + <span class="dynexp">2</span></span></p></PRE
><P
></P
></DIV
><P
>&#13;Note that <FONT
COLOR="RED"
>val</FONT
> is a keyword in ATS, and the declaration is
classified as a val-declaration. Conceptually, what happens at run-time in
a call-by-value language such as ATS is that the expression <FONT
COLOR="RED"
>1+2</FONT
>
is first evaluated to the value <FONT
COLOR="RED"
>3</FONT
>, and then the binding between
<FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>1+2</FONT
> is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>finalized</I
></SPAN
> into a binding
between <FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>3</FONT
>. Essentially, call-by-value means
that a binding between a name and an expression needs to be finalized into
one between the name and the value of the expression before it can be used
in evaluation subsequently. As another example, the following syntax
declares three bindings, two of which are formed simultaneously in the
first line:
</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN178"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> PI <span class="keyword">=</span> <span class="dynexp">3.14</span> <span class="keyword">and</span> radius <span class="keyword">=</span> <span class="dynexp">10.0</span></span>
<span class="dynexp"><span class="keyword">val</span> area <span class="keyword">=</span> PI * radius * radius</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that it is unspecified in ATS as to which of the first two bindings
(connected by the keyword <FONT
COLOR="RED"
>and</FONT
>) is finalized ahead of the other
at run-time. However, it is guaranteed that the third binding is finalized
after the first two are done. To see this issue from a different angle, we
can try to typecheck the following code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN182"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">and</span> y <span class="keyword">=</span> x + <span class="dynexp">1</span></span>
</p></PRE
><P
></P
></DIV
>


The error message reported in this case indicates that the name (or dynamic
identifier) <FONT
COLOR="RED"
>x</FONT
> in the expression <FONT
COLOR="RED"
>x + 1</FONT
> is unbound.
In particular, the two occurrences of <FONT
COLOR="RED"
>x</FONT
> in the above code are
unrelated.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="scopes_for_bindings"
>Scopes for Bindings</A
></H2
><P
>&#13;Each binding is given a fixed scope in which the binding is considered
legal or effective. The scope of a toplevel binding in a file starts from
the point where the binding is introduced until the very end of the
file. The bindings introduced in the following example between the keywords
<FONT
COLOR="RED"
>let</FONT
> and <FONT
COLOR="RED"
>in</FONT
> are effective until the keyword
<FONT
COLOR="RED"
>end</FONT
> is reached:
</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN193"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> area <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> PI <span class="keyword">=</span> <span class="dynexp">3.14</span> <span class="keyword">and</span> radius <span class="keyword">=</span> <span class="dynexp">10.0</span></span> <span class="keyword">in</span> PI * radius * radius
<span class="keyword">end</span></span> <span class="comment">// end of [let]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Such bindings are referred to as local bindings, and the names such as
<FONT
COLOR="RED"
>PI</FONT
> and <FONT
COLOR="RED"
>radius</FONT
> are referred to as local names.  This
example can also be written in the following style:
</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN198"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> area <span class="keyword">=</span>
  PI * radius * radius <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> PI <span class="keyword">=</span> <span class="dynexp">3.14</span> <span class="keyword">and</span> radius <span class="keyword">=</span> <span class="dynexp">10.0</span></span> <span class="comment">// simultaneous bindings</span>
<span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [val]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The keyword <FONT
COLOR="RED"
>where</FONT
> appearing immediately after an expression
introduces bindings that are solely effective for evaluating names
contained in the expression.  Note that expressions formed using the
keywords <FONT
COLOR="RED"
>let</FONT
> and <FONT
COLOR="RED"
>where</FONT
> are often referred to as
let-expressions and where-expressions, respectively. The former can always
be translated into the latter directly and vice versa.  Which style is
better? I have not formed my opinion yet. The answer seems to entirely
depend on the taste of the programmer.
</P
><P
>&#13;The following example demonstrates an alternative approach to introducing
local bindings:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN205"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">local</span>

<span class="dynexp"><span class="keyword">val</span> PI <span class="keyword">=</span> <span class="dynexp">3.14</span> <span class="keyword">and</span> radius <span class="keyword">=</span> <span class="dynexp">10.0</span></span>

<span class="keyword">in</span> <span class="comment">(* in-of-local *)</span>

<span class="dynexp"><span class="keyword">val</span> area <span class="keyword">=</span> PI * radius * radius</span>

<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</p></PRE
><P
></P
></DIV
>


where the bindings introduced between the keywords <FONT
COLOR="RED"
>local</FONT
> and
<FONT
COLOR="RED"
>in</FONT
> are effective until the keyword <FONT
COLOR="RED"
>end</FONT
> is
reached. Note that the bindings introduced between the keywords
<FONT
COLOR="RED"
>in</FONT
> and <FONT
COLOR="RED"
>end</FONT
> are themselves toplevel bindings. The
difference between <FONT
COLOR="RED"
>let</FONT
> and <FONT
COLOR="RED"
>local</FONT
> should be clear:
The former is used to form an expression while the latter is used to
introduce a sequence of declarations.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="environments_for_evaluation"
>Environments for Evaluation</A
></H2
><P
>Evaluation is the computational process that reduces expressions to
values.  When performing evaluation, we need not only the expression to be
evaluated but also a collection of bindings that map names in the
expression to values. This collection of bindings, which is just a finite
mapping, is often referred to as an environment (for evaluation). For
instance, suppose that we want to evaluate the following expression:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN217"
></A
><PRE
CLASS="programlisting"
>let
  val PI = 3.14 and radius2 = 10.0 * 10.0 in PI * radius2
end
</PRE
><P
></P
></DIV
>


We start with the empty environment ENV0; we evaluate <FONT
COLOR="RED"
>3.14</FONT
> to
itself and <FONT
COLOR="RED"
>10.0 * 10.0</FONT
> to <FONT
COLOR="RED"
>100.0</FONT
> under the
environment ENV0; we then extend ENV0 to ENV1 with two bindings mapping
<FONT
COLOR="RED"
>PI</FONT
> to <FONT
COLOR="RED"
>3.14</FONT
> and <FONT
COLOR="RED"
>radius2</FONT
> to
<FONT
COLOR="RED"
>100.0</FONT
>; we then evaluate <FONT
COLOR="RED"
>PI * radius2</FONT
> under ENV1
to <FONT
COLOR="RED"
>3.14 * radius2</FONT
>, then to <FONT
COLOR="RED"
>3.14 * 100.0</FONT
>, and
finally to <FONT
COLOR="RED"
>314.0</FONT
>, which is the value of the let-expression.</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="static_semantics"
>Static Semantics</A
></H2
><P
>ATS is a programming language equipped with a highly expressive type
system rooted in the <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>Applied Type System</I
></SPAN
> framework,
which also gives ATS its name. I will gradually introduce the type system
of ATS, which is probably the most outstanding and interesting part of this
book.</P
><P
>It is common to treat a type as the set of values it classifies.
However, I find it more approriate to treat a type as a form of
meaning. There are formal rules for assigning types to expressions, which
are referred to as typing rules.  If a type T can be assigned to an
expression, then I say that the expression possesses the static meaning
(semantics) represented by the type T. Note that an expression may be
assigned many distinct static meanings.  An expression is well-typed if
there exists a type T such that the expression can be assigned the type T.</P
><P
>If there is a binding between a name and an expression and the
expression is of some type T, then the name is assumed to be of the type T
in the effective scope of the binding. In other words, the name assumes the
static meaning of the expression it refers to.</P
><P
>&#13;Let exp0 be an expression of some type T, that is, the type T can be
assigned to exp0 according to certain typing rules. If we can evaluate exp0
to exp1, then exp1 can also be assigned the type T. In other words, static
meaning is an invariant under evaluation. This property is often referred
to as <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type preservation</I
></SPAN
>, which is part of the soundness of the
type system of ATS. Based on this property, we can readily infer that any
value is of the type T if exp0 can be evaluated to it (in multiple steps).
</P
><P
>&#13;Let exp0 be an expression of some type T. Assume that exp0 is not a value.
Then exp0 can always be evaluated one step further to another expression
exp1. This property is often referred to as <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>progress</I
></SPAN
>, which is
another part of the soundness of the type system of ATS.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="primitive_types"
>Primitive Types</A
></H2
><P
>&#13;The simplest types in ATS are primitive types, which are used to classify
primitive values. For instance, we have the primitive types <FONT
COLOR="RED"
>int</FONT
>
and <FONT
COLOR="RED"
>double</FONT
>, which classify integers (in a fixed range) and
floating point numbers (of double precision), respectively.
</P
><P
>&#13;In the current implementation of ATS (Postiats),
a program in ATS is first compiled into one in C (conforming to the
C99 standard), which can then be compiled to object code by a compiler
for C such as gcc. In the compilation from ATS to C, each of the types
<FONT
COLOR="RED"
>int</FONT
>, <FONT
COLOR="RED"
>double</FONT
> and <FONT
COLOR="RED"
>void</FONT
> in ATS is
translated to the type of the same name in C.

</P
><P
>&#13;There are many other primitive types in ATS, and I will introduce
them gradually.  Some commonly used primitive types are listed as follows:

<P
></P
><UL
><LI
><P
><FONT
COLOR="RED"
>bool</FONT
>:
This type is for boolean values <FONT
COLOR="RED"
>true</FONT
> and <FONT
COLOR="RED"
>false</FONT
>,
and it is translated into the int type in C.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>char</FONT
>:
This type is translated into the type in C for characters.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>schar</FONT
>:
This type is translated into the type in C for signed characters.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>uchar</FONT
>:
This type is translated into the type in C for unsigned characters.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>float</FONT
>:
This type is translated into the type in C for floating point numbers of
single precision.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>uint</FONT
>:
This type is translated into the type in C for unsigned integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>lint</FONT
>:
This type is translated into the type in C for long integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>ulint</FONT
>:
This type is translated into the type in C for unsigned long integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>llint</FONT
>:
This type is translated into the type in C for long long integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>ullint</FONT
>:
This type is translated into the type in C for unsigned long long integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>size_t</FONT
>:
This type is translated into the type in C of the same name, which is for
unsigned integers of certain precision. Usually, the type <FONT
COLOR="RED"
>size_t</FONT
>
can be treated as the type <FONT
COLOR="RED"
>ulint</FONT
> and vice versa.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>ssize_t</FONT
>:
This type is translated into the type in C of the same name, which is for
signed integers of certain precision. Usually, the type <FONT
COLOR="RED"
>ssize_t</FONT
>
can be treated as the type <FONT
COLOR="RED"
>lint</FONT
> and vice versa.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>sint</FONT
>:
This type is translated into the type in C for short integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>usint</FONT
>:
This type is translated into the type in C for unsigned short integers.</P
></LI
><LI
><P
><FONT
COLOR="RED"
>string</FONT
>:
This type is for strings, and its translation in C is the type for
pointers. I will explain this translation elsewhere.</P
></LI
></UL
>

I will gradually present programming examples involving various primitive types and
values.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="tuples_and_tuple_types"
>Tuples and Tuple Types</A
></H2
><P
>&#13;Given two types T1 and T2, we can form a tuple type (T1, T2), which can
also be written as @(T1, T2).  Assume that exp1 and exp2 are two
expressions of the types T1 and T2, respectively. Then the expression
(exp1, exp2), which can also be written as @(exp1, exp2), refers to a tuple
of the tuple type (T1, T2). Accordingly, we can form tuples and tuple types
of more components. In order for a tuple type to be assigned to a tuple,
the tuple and the tuple type must have the equal number of components.
</P
><P
>&#13;When evaluating a tuple expression, we evaluate all of its components
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>sequentially</I
></SPAN
>. Suppose that the expression contains n
components, then the value of the expression is the tuple consisting of the
n values of the n components listed in the order as the components
themselves.
</P
><P
>&#13;A tuple of length n for n &#62;= 2 is just a record of field names ranging from
0 until n-1, inclusive. Given an expression exp of some tuple type (T1,
T2), we can form expressions (exp).0 and (exp).1, which are of types T1 and
T2, respectively. Note that the expression exp does not have to be a tuple
expression. For instance, exp may be a name or a function application. If
exp evaluates to a tuple of two values, then exp.0 evaluates to the first
value and exp.1 the second value. Clearly, if the tuple type of exp
contains more components, what is stated can be generalized accordingly.
</P
><P
>&#13;In the following example, we first construct a tuple of length 3 and then
introduce bindings between 3 names and all of the 3 components of the
tuple:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN309"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> xyz <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp">'A'</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2.0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.0</span></span> <span class="keyword">and</span> y <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.1</span></span> <span class="keyword">and</span> z <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.2</span></span></span>
</p></PRE
><P
></P
></DIV
>


Note that the constructed tuple can be assigned the tuple type
<FONT
COLOR="RED"
>(char, int, double)</FONT
>. Another method for selecting components in
a given tuple is based on pattern matching, which is employed in the
following example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN312"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> xyz <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp">'A'</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2.0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">,</span> z<span class="keyword">)</span> <span class="keyword">=</span> xyz</span> <span class="comment">// x = 'A'; y = 1; z = 2.0</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>(x, y, z)</FONT
> is a pattern that can match any tuples of
exact 3 components. I will say more about pattern matching elsewhere.
</P
><P
>&#13;The tuples introduced above are often referred to as flat tuples, native
tuples or unboxed tuples. There is another kind of tuples supported in ATS,
which are called boxed tuples. A boxed tuple is essentially a pointer
pointing to some heap location where a flat tuple is stored.
</P
><P
>&#13;Assume that exp1 and exp2 are two expressions of the types T1 and T2,
respectively. Then the expression '(exp1, exp2), refers to a tuple of the
tuple type '(T1, T2). Accordingly, we can form boxed tuples and boxed tuple
types of fewer or more components. What should be noted immediately is that
every boxed tuple is of the size of a pointer, and can thus be stored in
any place where a pointer can. Using boxed tuples is rather similar to
using unboxed ones. For instance, the meaning of the following code should
be evident:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN317"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> xyz <span class="keyword">=</span> <span class="keyword">'(</span> <span class="dynexp">'A'</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2.0</span> <span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.0</span></span> <span class="keyword">and</span> y <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.1</span></span> <span class="keyword">and</span> z <span class="keyword">=</span> xyz<span class="dynexp"><span class="keyword">.2</span></span></span>
</p></PRE
><P
></P
></DIV
>


Note that a space is needed between <FONT
COLOR="RED"
>'(</FONT
> and <FONT
COLOR="RED"
>'A'</FONT
>
for otherwise the current parser (for ATS/Postiats) would be confused.
</P
><P
>&#13;Given the availability of flat and boxed tuples, one naturally wants to
know whether there is a simple way to determine which kind is preferred
over the other. Unfortunately, there is no simple way to do this as far as
I can tell. In order to be certain, some kind of profiling is often
needed. However, if we want to run code with no support of garbage
collection (GC), then we should definitely avoid using boxed tuples.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="records_and_record_types"
>Records and Record Types</A
></H2
><P
>A record is just like a tuple except that each field name of the
record is chosen by the programmer (instead of being fixed). Similarly, a
record type is just like a tuple type.  For instance, a record type
<FONT
COLOR="RED"
>point2D</FONT
> is defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN326"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span>
<span class="staexp">point2D <span class="keyword">=</span> <span class="keyword">@{</span> <span class="stalab">x</span><span class="keyword">=</span> <span class="staexp">double</span><span class="keyword">,</span> <span class="stalab">y</span><span class="keyword">=</span> <span class="staexp">double</span> <span class="keyword">}</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>y</FONT
> are the names of the two fields in
a record value of this type. We also refer to a field in a record as a
component. The special symbol <FONT
COLOR="RED"
>@{</FONT
> indicates that the formed
type is for flat/native/unboxed records. A value of the type
<FONT
COLOR="RED"
>point2D</FONT
> is constructed as follows and given the name
<FONT
COLOR="RED"
>theOrigin</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN333"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> theOrigin <span class="keyword">=</span> <span class="keyword">@{</span> <span class="dynlab">x</span><span class="keyword">=</span> <span class="dynexp">0.0</span><span class="keyword">,</span> <span class="dynlab">y</span><span class="keyword">=</span> <span class="dynexp">0.0</span> <span class="keyword">}</span> <span class="keyword">:</span> <span class="staexp">point2D</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>We can use the standard dot notation to extract out a selected component in
a record, and this is shown in the next line of code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN336"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> theOrigin_x <span class="keyword">=</span> theOrigin<span class="dynexp"><span class="keyword">.</span>x</span> <span class="keyword">and</span> theOrigin_y <span class="keyword">=</span> theOrigin<span class="dynexp"><span class="keyword">.</span>y</span></span>
</p></PRE
><P
></P
></DIV
>


Alternatively, we can use pattern matching for doing component extraction
as is done in the next line of code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN338"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> <span class="keyword">@{</span> <span class="dynlab">x</span><span class="keyword">=</span> theOrigin_x<span class="keyword">,</span> <span class="dynlab">y</span><span class="keyword">=</span> theOrigin_y <span class="keyword">}</span> <span class="keyword">=</span> theOrigin</span>
</p></PRE
><P
></P
></DIV
>


In this case, the names <FONT
COLOR="RED"
>theOrigin_x</FONT
> and
<FONT
COLOR="RED"
>theOrigin_y</FONT
> are bound to the components in
<FONT
COLOR="RED"
>theOrgin</FONT
> that are named <FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>y</FONT
>,
respectively. If we only need to extract out a selected few of components
(instead of all the available ones), we can make use of the following
kind of patterns:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN345"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> <span class="keyword">@{</span> <span class="dynlab">x</span><span class="keyword">=</span> theOrigin_x<span class="keyword">,</span> <span class="keyword">...</span> <span class="keyword">}</span> <span class="keyword">=</span> theOrigin</span> <span class="comment">// the x-component only </span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">@{</span> <span class="dynlab">y</span><span class="keyword">=</span> theOrigin_y<span class="keyword">,</span> <span class="keyword">...</span> <span class="keyword">}</span> <span class="keyword">=</span> theOrigin</span> <span class="comment">// the y-component only </span>
</p></PRE
><P
></P
></DIV
>


If you find all this syntax for component extraction to be confusing, then
I suggest that you stick to the dot notation. I myself rarely use pattern
matching on record values.
</P
><P
>Compared with handling native/flat/unboxed records, the only change
needed for handling boxed records is to replace the special symbol
<FONT
COLOR="RED"
>@{</FONT
> with another one: <FONT
COLOR="RED"
>'{</FONT
>, which is a quote
followed immediately by a left curly brace.</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="conditional_expressions"
>Conditional Expressions</A
></H2
><P
>A conditional expression consists of a test and two branches. For instance,
the following expression is conditional:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN353"
></A
><PRE
CLASS="programlisting"
>if (x &#62;= 0) then x else ~x
</PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>if</FONT
>, <FONT
COLOR="RED"
>then</FONT
> and <FONT
COLOR="RED"
>else</FONT
> are keywords
in ATS. In a conditional expression, the expression following
<FONT
COLOR="RED"
>if</FONT
> is the test and the expressions following <FONT
COLOR="RED"
>then</FONT
>
and <FONT
COLOR="RED"
>else</FONT
> are referred to as the then-branch and the
else-branch (of the conditional expression), respectively.
</P
><P
>&#13;In order to assign a type T to a conditional expression, we need to assign
the type <FONT
COLOR="RED"
>bool</FONT
> to the test and the type T to both of the
then-branch and the else-branch. For instance, the type <FONT
COLOR="RED"
>int</FONT
> can
be assigned to the above conditional expression if the name <FONT
COLOR="RED"
>x</FONT
>
is given the type <FONT
COLOR="RED"
>int</FONT
>.  </P
><P
>&#13;Suppose that we have a conditional expression that is well-typed. When
evaluating it, we first evaluate the test to a value, which is guaranteed
to be either <FONT
COLOR="RED"
>true</FONT
> or <FONT
COLOR="RED"
>false</FONT
>; if the value is
<FONT
COLOR="RED"
>true</FONT
>, then we continue to evaluate the then-branch; otherwise,
we continue to evaluate the else-branch.  </P
><P
>&#13;It is also allowed to form a conditional expression where the else-branch
is missing or truncated. For instance, we can form an expression as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN371"
></A
><PRE
CLASS="programlisting"
>if (x &#62;= 0) then print(x)
</PRE
><P
></P
></DIV
>


which is equivalent to the following conditional expression:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN373"
></A
><PRE
CLASS="programlisting"
>if (x &#62;= 0) then print(x) else ()
</PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>()</FONT
> stands for the void value (of the type
<FONT
COLOR="RED"
>void</FONT
>). If a type can be assigned to a conditional expression
in the truncated form, then the type must be <FONT
COLOR="RED"
>void</FONT
>.</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="sequence_expressions"
>Sequence Expressions</A
></H2
><P
>&#13;Assume that exp1 and exp2 are expressions of types T1 and T2 respectively,
where T1 is <FONT
COLOR="RED"
>void</FONT
>. Then a sequence expression (exp1; exp2) can
be formed that is of the type T2.  When evaluating the sequence expression
(exp1; exp2), we first evaluate exp1 to the void value and then evaluate
exp2 to some value, which is also the value of the sequence expression.
When more expressions are sequenced, all of them but the last one need to
be of the type <FONT
COLOR="RED"
>void</FONT
> and the type of the last expression is also
the type of the sequence expression being formed.  Evaluating a sequence of
more expressions is analogous to evaluating a sequence of two. The
following example is a sequence expression:
 
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN383"
></A
><PRE
CLASS="programlisting"
>(print 'H'; print 'e'; print 'l'; print 'l'; print 'o')
</PRE
><P
></P
></DIV
>


Evaluating this sequence expression prints out (onto the console) the
5-letter string "Hello". Instead of parentheses, we can also use the
keywords <FONT
COLOR="RED"
>begin</FONT
> and <FONT
COLOR="RED"
>end</FONT
> to form a sequence
expression:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN387"
></A
><PRE
CLASS="programlisting"
>begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o'
end // end of [begin]
</PRE
><P
></P
></DIV
>


If we like, we may also add a semicolon immediately after the last
expression in a sequence as long as the last expression is of the type
<FONT
COLOR="RED"
>void</FONT
>. For instance, the above example can also be written as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN390"
></A
><PRE
CLASS="programlisting"
>begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o';
end // end of [begin]
</PRE
><P
></P
></DIV
>


I also want to point out the following style of sequencing:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN392"
></A
><PRE
CLASS="programlisting"
>let
  val () = print 'H'
  val () = print 'e'
  val () = print 'l'
  val () = print 'l'
  val () = print 'o'
in
  // nothing
end // end of [let]
</PRE
><P
></P
></DIV
>


which is quite common in functional programming.</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="comments_in_code"
>Comments in Code</A
></H2
><P
>ATS currently supports four forms of comments: line comment, block
comment of ML-style, block comment of C-style, and rest-of-file comment.

<P
></P
><UL
><LI
><P
>A line comment starts with the double slash symbol
(<FONT
COLOR="RED"
>//</FONT
>) and extends until the end of the current line.</P
></LI
><LI
><P
>&#13;A block comment of ML-style starts and closes with the tokens
<FONT
COLOR="RED"
>(*</FONT
> and <FONT
COLOR="RED"
>*)</FONT
>, respectively. Note that nested block
comments of ML-style are allowed, that is, one block comment of ML-style
can occur within another one of the same style.</P
></LI
><LI
><P
>A block comment of C-style starts and closes with the tokens
<FONT
COLOR="RED"
>/*</FONT
> and <FONT
COLOR="RED"
>*/</FONT
>, respectively. Note that block comments
of C-style cannot be nested.  The use of block comments of C-style is
primarily in code that is supposed to be shared by ATS and C. In other
cases, block comments of ML-style should be the preferred choice.</P
></LI
><LI
><P
>A rest-of-file comment starts with the quadruple slash
symbol (<FONT
COLOR="RED"
>////</FONT
>) and extends until the end of the file. Comments
of this style of are primarily useful for developing or debugging programs.</P
></LI
></UL
>

</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="functions"
></A
>Chapter 3. Functions</H1
><P
>&#13;Functions play a foundational role in programming.  While it may be
theoretically possible to program without functions (but with loops), such
a programming style is of little practical value. ATS does provide some
language constructs for implementing for-loops and while-loops directly. I,
however, strongly recommend that the programmer implement loops as
recursive functions or more precisely, as tail-recursive functions. This is
a programming style that matches well with more advanced programming
features in ATS, which will be presented in this book later.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="functions-as-a-simple-form-of-abstraction"
>Functions as a Simple Form of Abstraction</A
></H2
><P
>Given an expression exp of the type <FONT
COLOR="RED"
>double</FONT
>, we can
multiply exp by itself to compute its square. If exp is a complex
expression, we may introduce a binding between a name and exp so that exp
is only evaluated once. This idea is shown in the following example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN421"
></A
><PRE
CLASS="programlisting"
>let val x = 3.14 * (10.0 - 1.0 / 1.4142) in x * x end
</PRE
><P
></P
></DIV
>


Now suppose that we have found a more efficient way to do squaring. In
order to take full advantage of it, we need to modify each occurrence of
squaring in the current program accordingly. This style of programming is
clearly not modular, and it is of little chance to scale. To address this
problem, we can implement a function as follows to compute the square of a
given floating point number:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN423"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> square <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=</span> x * x</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>fn</FONT
> initiates the definition of a non-recursive
function, and the name following it is for the function to be defined.  In
the above example, the function <FONT
COLOR="RED"
>square</FONT
> takes one argument of
the name <FONT
COLOR="RED"
>x</FONT
>, which is assumed to have the type
<FONT
COLOR="RED"
>double</FONT
>, and returns a value of the type
<FONT
COLOR="RED"
>double</FONT
>. The expression on the right-hand side (RHS) of the
symbol <FONT
COLOR="RED"
>=</FONT
> is the body of the function, which is <FONT
COLOR="RED"
>x *
x</FONT
> in this case. If we have a more efficient way to do squaring, we
can just re-implement the body of the function <FONT
COLOR="RED"
>square</FONT
>
accordingly to take advantage of it, and there is no other changes needed
(assuming that squaring is solely done by calling <FONT
COLOR="RED"
>square</FONT
>).
</P
><P
>&#13;If <FONT
COLOR="RED"
>square</FONT
> is a name, what is the expression it refers to? It
turns out that the above function definition can also be written as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN436"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> square <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=&gt;</span> x * x</span>
</p></PRE
><P
></P
></DIV
>


where the RHS of the symbol <FONT
COLOR="RED"
>=</FONT
> is a lambda-expression
representing an anonymous function that takes one argument of the type
<FONT
COLOR="RED"
>double</FONT
> and returns a value of the type <FONT
COLOR="RED"
>double</FONT
>,
and the expression following the symbol <FONT
COLOR="RED"
>=&#62;</FONT
> is the body of the
function. If we wish, we can change the name of the function argument as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN442"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> square <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>y<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=&gt;</span> y * y</span>
</p></PRE
><P
></P
></DIV
>


This is called alpha-renaming (of function arguments), and the new
lambda-expression is said to be alpha-equivalent to the original one.
</P
><P
>&#13;A lambda-expression is a (function) value. Suppose we have a
lambda-expression representing a binary function, that is, a function
taking two arguments. In order to assign a type of the form (T1, T2) -&#62; T
to the lambda-expression, we need to verify that the body of the function
can be given the type T if the two arguments of the function are assumed to
have the types T1 and T2.
What is stated also applies, <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>mutatis mutandis</I
></SPAN
>, to
lambda-expressions representing functions of fewer or more arguments. For
instance, the lambda-expression <FONT
COLOR="RED"
>lam (x: double): double =&#62; x *
x</FONT
> can be assigned the function type <FONT
COLOR="RED"
>(double) -&#62; double</FONT
>, which
may also be written as <FONT
COLOR="RED"
>double -&#62; double</FONT
>.
</P
><P
>&#13;Assume that exp is an expression of some function type (T1, T2) -&#62; T. Note
that exp is not necessarily a name or a lambda-expression. If expressions
exp<SUB
>1</SUB
> and exp<SUB
>2</SUB
> can be assigned
the types T1 and T2, then the function application
exp(exp<SUB
>1</SUB
>, exp<SUB
>2</SUB
>), which may
also be referred to as a function call, can be assigned the type T.  Typing
a function application of fewer or more arguments is handled similarly.
</P
><P
>Let us now see an example that builds on the previously defined
function <FONT
COLOR="RED"
>square</FONT
>. The boundary of a ring consists of two
circles centered at the same point. If the radii of the outer and inner
circles are R and r, respectively, then the area of the ring can be
computed by the following function <FONT
COLOR="RED"
>area_of_ring</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN457"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> area_of_ring
  <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=</span> <span class="dynexp">3.1416</span> * <span class="keyword">(</span>square<span class="keyword">(</span>R<span class="keyword">)</span> - square<span class="keyword">(</span>r<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [area_of_ring]</span>
</p></PRE
><P
></P
></DIV
>


Note that the subtraction and multiplication functions
are of the type <FONT
COLOR="RED"
>(double, double) -&#62; double</FONT
>
and <FONT
COLOR="RED"
>square</FONT
> is of the type <FONT
COLOR="RED"
>(double) -&#62;
double</FONT
>. It is thus a simple routine to verify that the body of
<FONT
COLOR="RED"
>area_of_ring</FONT
> can be assigned the type <FONT
COLOR="RED"
>double</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="function-arity"
>Function Arity</A
></H2
><P
>&#13;The arity of a function is the number of arguments the function
takes.  Functions of arity 0, 1, 2 and 3 are often called nullary, unary,
binary and ternary functions, respectively. For example, the following
function <FONT
COLOR="RED"
>sqrsum1</FONT
> is a binary function such that its two
arguments are of the type <FONT
COLOR="RED"
>int</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN469"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> sqrsum1 <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> x * x + y * y</span>
</p></PRE
><P
></P
></DIV
>


We can define a unary function <FONT
COLOR="RED"
>sqrsum2</FONT
> as follows:
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN472"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">int2 <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fn</span> sqrsum2
  <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">int2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">let</span> <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> xy<span class="dynexp"><span class="keyword">.0</span></span> <span class="keyword">and</span> y <span class="keyword">=</span> xy<span class="dynexp"><span class="keyword">.1</span></span></span> <span class="keyword">in</span> x * x + y * y <span class="keyword">end</span></span>
<span class="comment">// end of [sqrsum2]</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>typedef</FONT
> introduces a binding between the name
<FONT
COLOR="RED"
>int2</FONT
> and the tuple type <FONT
COLOR="RED"
>(int, int)</FONT
>. In other words,
<FONT
COLOR="RED"
>int2</FONT
> is treated as an abbreviation or alias for <FONT
COLOR="RED"
>(int,
int)</FONT
>. The function <FONT
COLOR="RED"
>sqrsum2</FONT
> is unary as it takes only one
argument, which is a tuple of the type <FONT
COLOR="RED"
>int2</FONT
>.  When applying
<FONT
COLOR="RED"
>sqrsum2</FONT
> to a tuple consisting of <FONT
COLOR="RED"
>1</FONT
> and
<FONT
COLOR="RED"
>~1</FONT
>, we need to write <FONT
COLOR="RED"
>sqrsum2 @(1, ~1)</FONT
>. If we simply
write <FONT
COLOR="RED"
>sqrsum2 (1, ~1)</FONT
>, then the typechecker is to report an
error of function arity mismatch as it assumes that <FONT
COLOR="RED"
>sqrsum2</FONT
> is
applied to two arguments (instead of one representing a pair).
</P
><P
>&#13;Many functional languages (e.g., Haskell and ML) only allow unary
functions. A function of multiple arguments is encoded in these languages
as a unary function taking a tuple as its only argument or it is curried
into a function that takes these arguments sequentially. ATS, however,
provides direct support for functions of multiple arguments. There is even
some limited support in ATS for variadic functions, that is, functions of
indefinite number of arguments (e.g., the famous <FONT
COLOR="RED"
>printf</FONT
>
function in C). This is a topic I will cover elsewhere.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="function-interface"
>Function Interface</A
></H2
><P
>&#13;The interface for a function specifies the type assigned to the
function. Given a binary function foo of the type (T1, T2) -&#62; T3, its
interface can be written as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN492"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> foo <span class="keyword">(</span>arg1<span class="keyword">:</span> <span class="staexp">T1</span><span class="keyword">,</span> arg2<span class="keyword">:</span> <span class="staexp">T2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">T3</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>arg1</FONT
> and <FONT
COLOR="RED"
>arg2</FONT
> may be replaced with any
other legal identifiers for function arguments.  For functions of more or
fewer arguments, interfaces can be written in a similar fashion.  For
instance, we have the following interfaces for various functions on
integers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN496"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> succ_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// successor</span>
<span class="dynexp"><span class="keyword">fun</span> pred_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// predecessor</span>

<span class="dynexp"><span class="keyword">fun</span> add_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// +</span>
<span class="dynexp"><span class="keyword">fun</span> sub_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// -</span>
<span class="dynexp"><span class="keyword">fun</span> mul_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// *</span>
<span class="dynexp"><span class="keyword">fun</span> div_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// /</span>

<span class="dynexp"><span class="keyword">fun</span> mod_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// modulo</span>
<span class="dynexp"><span class="keyword">fun</span> gcd_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// greatest common divisor</span>

<span class="dynexp"><span class="keyword">fun</span> lt_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// &lt;</span>
<span class="dynexp"><span class="keyword">fun</span> lte_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// &lt;=</span>
<span class="dynexp"><span class="keyword">fun</span> gt_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// &gt;</span>
<span class="dynexp"><span class="keyword">fun</span> gte_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// &gt;=</span>
<span class="dynexp"><span class="keyword">fun</span> eq_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// =</span>
<span class="dynexp"><span class="keyword">fun</span> neq_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// &lt;&gt;</span>

<span class="dynexp"><span class="keyword">fun</span> max_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// maximum</span>
<span class="dynexp"><span class="keyword">fun</span> min_int_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span> <span class="comment">// minimum</span>

<span class="dynexp"><span class="keyword">fun</span> print_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> tostring_int <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">string</span></span>
</p></PRE
><P
></P
></DIV
>


For now, I mostly use function interfaces for the purpose of presenting
functions.  I will show later how a function definition can be separated
into two parts: a function interface and an implementation that implements
the function interface. Note that separation as such is pivotal for
constructing (large) programs in a modular style.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="evaluation-of-function-calls"
>Evaluation of Function Calls</A
></H2
><P
>&#13;Evaluating a function call is straightforward. Assume that we are to
evaluate the function call <FONT
COLOR="RED"
>abs(0.0 - 1.0)</FONT
> under some
environment ENV0, where the function <FONT
COLOR="RED"
>abs</FONT
> is defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN503"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> abs <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=</span> <span class="keyword">if</span> x &gt;= <span class="dynexp">0.0</span> <span class="keyword">then</span> x <span class="keyword">else</span> <span class="keyword">~</span>x</span>
</p></PRE
><P
></P
></DIV
>


We first evaluate the argument of the call to <FONT
COLOR="RED"
>~1.0</FONT
> under ENV0;
we then extend ENV0 to ENV1 with a binding between <FONT
COLOR="RED"
>x</FONT
> and
<FONT
COLOR="RED"
>~1.0</FONT
> and start to evaluate the body of <FONT
COLOR="RED"
>abs</FONT
> under
ENV1; we evaluate the test <FONT
COLOR="RED"
>x &#62;= 0</FONT
> to <FONT
COLOR="RED"
>~1.0 &#62;= 0</FONT
> and
then to <FONT
COLOR="RED"
>false</FONT
>, which indicates that we take the else-branch
<FONT
COLOR="RED"
>~x</FONT
> to continue; we evaluate <FONT
COLOR="RED"
>~x</FONT
> to
<FONT
COLOR="RED"
>~(~1.0)</FONT
> and then to <FONT
COLOR="RED"
>1.0</FONT
>; so the evaluation of the
function call <FONT
COLOR="RED"
>abs(0.0 - 1.0)</FONT
> returns <FONT
COLOR="RED"
>1.0</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="recursive-functions"
>Recursive Functions</A
></H2
><P
>&#13;A recursive function is one that may make calls to itself in its body. In
ATS, the keyword <FONT
COLOR="RED"
>fun</FONT
> is used to initiate the definition of a
recursive function.  Clearly, a non-recursive function is just a special
kind of recursive function: the kind that does not make any calls to itself
in its body. If one prefers, one can use <FONT
COLOR="RED"
>fun</FONT
> (instead of
<FONT
COLOR="RED"
>fn</FONT
>) to initiate the definition of a non-recursive function.
</P
><P
>&#13;I consider recursion the most enabling feature a programming language can
provide. With recursion, we are enabled to do problem-solving based on a
strategy of reduction: In order to solve a problem to which a solution is
difficult to find immediately, we reduce the problem to problems that are
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>similar</I
></SPAN
> but <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>simpler</I
></SPAN
>, and we repeat this
reduction process if needed until solutions become apparent. Let us now see
some concrete examples of problem-solving that make use of this reduction
strategy.
</P
><P
>Suppose that we want to sum up all the integers ranging from 1 to n,
where n is a given integer. This can be readily done by implementing the
following recursive function <FONT
COLOR="RED"
>sum1</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN529"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum1
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">1</span> <span class="keyword">then</span> sum1 <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> + n <span class="keyword">else</span> <span class="dynexp">0</span></span>
<span class="comment">// end of [sum1]</span>
</p></PRE
><P
></P
></DIV
>


To find out the sum of all the integers ranging from <FONT
COLOR="RED"
>1</FONT
> to
<FONT
COLOR="RED"
>n</FONT
>, we call <FONT
COLOR="RED"
>sum1 (n)</FONT
>. The reduction strategy for
<FONT
COLOR="RED"
>sum1 (n)</FONT
> is straightforward: If <FONT
COLOR="RED"
>n</FONT
> is greater than
<FONT
COLOR="RED"
>1</FONT
>, then we can readily find the value of <FONT
COLOR="RED"
>sum1 (n)</FONT
>
by solving a simpler problem, that is, finding the value of <FONT
COLOR="RED"
>sum1
(n-1)</FONT
>.
</P
><P
>We can also solve the problem by implementing the following
recursive function <FONT
COLOR="RED"
>sum2</FONT
> that sums up all the integers in a
given range:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN541"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum2
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m &lt;= n <span class="keyword">then</span> m + sum2 <span class="keyword">(</span>m+<span class="dynexp">1</span><span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">0</span></span>
<span class="comment">// end of [sum2]</span>
</p></PRE
><P
></P
></DIV
>


This time, we call <FONT
COLOR="RED"
>sum2 (1, n)</FONT
> in order to find out the sum of
all the integers ranging from <FONT
COLOR="RED"
>1</FONT
> to <FONT
COLOR="RED"
>n</FONT
>.  The
reduction strategy for <FONT
COLOR="RED"
>sum2 (m, n)</FONT
> is also straightforward: If
<FONT
COLOR="RED"
>m</FONT
> is less than <FONT
COLOR="RED"
>n</FONT
>, then we can readily find the
value of <FONT
COLOR="RED"
>sum2 (m, n)</FONT
> by solving a simpler problem, that is,
finding the value of <FONT
COLOR="RED"
>sum2 (m+1, n)</FONT
>. The reason for <FONT
COLOR="RED"
>sum2
(m+1, n)</FONT
> being simpler than <FONT
COLOR="RED"
>sum2 (m, n)</FONT
> is that
<FONT
COLOR="RED"
>m+1</FONT
> is closer to <FONT
COLOR="RED"
>n</FONT
> than <FONT
COLOR="RED"
>m</FONT
> is.
</P
><P
>Given integers m and n, there is another strategy for summing up all
the integers from m to n: If m does not exceed n, we can find the sum of
all the integers from m to (m+n)/2-1 and then the sum of all the integers
from (m+n)/2+1 to n and then sum up these two sums and (m+n)/2. The
following recursive function <FONT
COLOR="RED"
>sum3</FONT
> is implemented precisely
according to this strategy:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN558"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum3
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m &lt;= n
    <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> mn2 <span class="keyword">=</span> <span class="keyword">(</span>m+n<span class="keyword">)</span>/<span class="dynexp">2</span></span>
    <span class="keyword">in</span>
      sum3 <span class="keyword">(</span>m<span class="keyword">,</span> mn2-<span class="dynexp">1</span><span class="keyword">)</span> + mn2 + sum3 <span class="keyword">(</span>mn2+<span class="dynexp">1</span><span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [then]</span>
    <span class="keyword">else</span> <span class="dynexp">0</span></span> <span class="comment">// end of [else]</span>
<span class="comment">// end of [sum3]</span>
</p></PRE
><P
></P
></DIV
>


It should be noted that the division involved in the expression
<FONT
COLOR="RED"
>(m+n)/2</FONT
> is integer division for which rounding is done by
truncation.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="evaluation-of-recursive-function-calls"
>Evaluation of Recursive Function Calls</A
></H2
><P
>Evaluating a call to a recursive function is not much different from
evaluating one to a non-recursive function.  Let <FONT
COLOR="RED"
>fib</FONT
> be the
following defined function for computing the Fibonacci numbers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN565"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fib
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">2</span> <span class="keyword">then</span> fib<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> + fib<span class="keyword">(</span>n-<span class="dynexp">2</span><span class="keyword">)</span> <span class="keyword">else</span> n</span>
<span class="comment">// end of [fib]</span>
</p></PRE
><P
></P
></DIV
>


Suppose that we are to evaluate <FONT
COLOR="RED"
>fib(2)</FONT
> under some environment
ENV0. Given that <FONT
COLOR="RED"
>2</FONT
> is already a value, we extend ENV0 to ENV1
with a binding between <FONT
COLOR="RED"
>n</FONT
> and <FONT
COLOR="RED"
>2</FONT
> and start to
evaluate the body of <FONT
COLOR="RED"
>fib</FONT
> under ENV1; clearly, this evaluation
leads to the evaluation of <FONT
COLOR="RED"
>fib(n-1) + fib(n-2)</FONT
>; it is easy to
see that evaluating <FONT
COLOR="RED"
>fib(n-1)</FONT
> and <FONT
COLOR="RED"
>fib(n-2)</FONT
> under
ENV1 leads to <FONT
COLOR="RED"
>1</FONT
> and <FONT
COLOR="RED"
>0</FONT
>, respectively, and the
evaluation of <FONT
COLOR="RED"
>fib(n-1) + fib(n-2)</FONT
> eventually returns
<FONT
COLOR="RED"
>1</FONT
> (as the result of <FONT
COLOR="RED"
>1+0</FONT
>); thus the evaluation of
<FONT
COLOR="RED"
>fib(2)</FONT
> under ENV0 yields the integer value <FONT
COLOR="RED"
>1</FONT
>.
</P
><P
>Let us now evaluate <FONT
COLOR="RED"
>fib(3)</FONT
> under ENV0; we extend ENV0
to ENV2 with a binding between <FONT
COLOR="RED"
>n</FONT
> and <FONT
COLOR="RED"
>3</FONT
>, and start
to evaluate the body of <FONT
COLOR="RED"
>fib</FONT
> under ENV2; we then reach the
evaluation of <FONT
COLOR="RED"
>fib(n-1) + fib(n-2)</FONT
> under ENV2; evaluating
<FONT
COLOR="RED"
>fib(n-1)</FONT
> under ENV2 leads to the evaluation of
<FONT
COLOR="RED"
>fib(2)</FONT
> under ENV2, which eventually returns <FONT
COLOR="RED"
>1</FONT
>;
evaluating <FONT
COLOR="RED"
>fib(n-2)</FONT
> under ENV2 leads to the evaluation of
<FONT
COLOR="RED"
>fib(1)</FONT
> under ENV2, which eventually returns <FONT
COLOR="RED"
>1</FONT
>;
therefore, evaluating <FONT
COLOR="RED"
>fib(3)</FONT
> under ENV0 returns <FONT
COLOR="RED"
>2</FONT
>
(as the result of <FONT
COLOR="RED"
>1+1</FONT
>).
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example-coin-changes-for-fun"
>Example: Coin Changes for Fun</A
></H2
><P
>Let S be a finite set of positive numbers.  The problem we want to
solve is to find out the number of distinct ways for a given integer x to
be expressed as the sum of multiples of the positive numbers chosen from
S. If we interpret each number in S as the denomination of a coin, then the
problem asks how many distinct ways there exist for a given value x to be
expressed as the sum of a set of coins. If we use cc(S, x) for this number,
then we have the following properties on the function cc:

<P
></P
><UL
><LI
><P
>cc(S, 0) = 1 for any S.
</P
></LI
><LI
><P
>If x &#60; 0, then cc(S, x) = 0 for any S.
</P
></LI
><LI
><P
>If S is empty and x &#62; 0, then cc(S, x) = 0.
</P
></LI
><LI
><P
>If S contains a number c, then
cc(S, x) = cc(S<SUB
>1</SUB
>, x) + cc(S, x-c),
where S<SUB
>1</SUB
> is the set formed by removing c from S.
</P
></LI
></UL
>

In the following implementation, we fix S to be the set consisting of
1, 5, 10 and 25.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN611"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">int4 <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> theCoins <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">10</span><span class="keyword">,</span> <span class="dynexp">25</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int4</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> coin_get
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">if</span> n <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> theCoins<span class="dynexp"><span class="keyword">.0</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> n <span class="keyword">=</span> <span class="dynexp">1</span> <span class="keyword">then</span> theCoins<span class="dynexp"><span class="keyword">.1</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> n <span class="keyword">=</span> <span class="dynexp">2</span> <span class="keyword">then</span> theCoins<span class="dynexp"><span class="keyword">.2</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> n <span class="keyword">=</span> <span class="dynexp">3</span> <span class="keyword">then</span> theCoins<span class="dynexp"><span class="keyword">.3</span></span>
  <span class="keyword">else</span> <span class="keyword">~</span><span class="dynexp">1</span> <span class="comment">(* erroneous value *)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [coin_get] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> coin_change
  <span class="keyword">(</span>sum<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> aux <span class="keyword">(</span>sum<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> sum <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
     <span class="keyword">(</span><span class="keyword">if</span> n &gt;= <span class="dynexp">0</span> <span class="keyword">then</span> aux <span class="keyword">(</span>sum<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span> + aux <span class="keyword">(</span>sum-coin_get<span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">0</span><span class="keyword">)</span>
    <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">if</span> sum <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="dynexp">0</span> <span class="keyword">else</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
  <span class="comment">// end of [aux]</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span>sum<span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [coin_change]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The auxiliary function <FONT
COLOR="RED"
>aux</FONT
> defined in the body of
the function <FONT
COLOR="RED"
>coin_change</FONT
> corresponds to the cc function
mentioned above.

When applied to <FONT
COLOR="RED"
>1000</FONT
>, the function <FONT
COLOR="RED"
>coin_change</FONT
>
returns <FONT
COLOR="RED"
>142511</FONT
>.
</P
><P
>Note that the entire code in this section plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/coinchange.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="tail-call-and-tail-recursion"
>Tail-Call and Tail-Recursion</A
></H2
><P
>&#13;Suppose that a function foo makes a call in its body to a function
bar, where foo and bar may be the same function. If the return value of the
call to bar is also the return value of foo, then this call to bar is a
tail-call. If foo and bar are the same, then this is a (recursive) self
tail-call. For instance, there are two recursive calls in the body of the
function <FONT
COLOR="RED"
>f91</FONT
> defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN624"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> f91 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">101</span> <span class="keyword">then</span> n - <span class="dynexp">10</span> <span class="keyword">else</span> f91<span class="keyword">(</span>f91<span class="keyword">(</span>n+<span class="dynexp">11</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where the outer recursive call is a self tail-call while the inner one is
not.
</P
><P
>&#13;If each recursive call in the body of a function is a tail-call,
then this function is a tail-recursive function. For instance, the
following function <FONT
COLOR="RED"
>sum_iter</FONT
> is tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN628"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum_iter
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> sum_iter<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">,</span> n+res<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span>res<span class="keyword">)</span></span>
<span class="comment">// end of [sum_iter]</span>
</p></PRE
><P
></P
></DIV
>


A tail-recursive function is often referred to as an iterative function.
</P
><P
>&#13;In ATS, the single most important optimization is probably the one
that turns a self tail-call into a local jump. This optimization
effectively turns every tail-recursive function into the equivalent of a
loop. Although ATS provides direct syntactic support for constructing
for-loops and while-loops, the preferred approach to loop construction in
ATS is in general through the use of tail-recursive functions. This is the
case primarily due to the fact that the syntax for writing tail-recursive
functions is compatible with the syntax for other programming features in
ATS while the syntax for loops is much less so.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example-the-eight-queens-puzzle"
>Example: The Eight-Queens Puzzle</A
></H2
><P
>The eight-queens puzzle is the problem of positioning on a 8x8
chessboard 8 queen pieces so that none of them can capture any other pieces
using the standard chess moves defined for a queen piece. I will present as
follows a solution to this puzzle in ATS, reviewing some of the programming
features that have been covered so far. In particular, please note that
every recursive function implemented in this solution is tail-recursive.
</P
><P
>First, let us introduce a name for the integer constant 8 as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN635"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="neuexp"><span class="keyword">#define</span> N 8</span>
</p></PRE
><P
></P
></DIV
>


After this declaration, each occurrence of the name <FONT
COLOR="RED"
>N</FONT
> is to
be replaced with 8. For representing board configurations, we define
a type <FONT
COLOR="RED"
>int8</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN639"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">int8 <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span>
<span class="keyword">)</span></span> <span class="comment">// end of [int8]</span>
</p></PRE
><P
></P
></DIV
>


A value of the type <FONT
COLOR="RED"
>int8</FONT
> is a tuple of 8 integers where the
first integer states the column position of the queen piece on the first
row (row 0), and the second integer states the column position of the queen
piece on the second row (row 1), and so on.
</P
><P
>In order to print out a board configuration, we define the following
functions:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN643"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> print_dots <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">(</span>print <span class="dynstr">". "</span><span class="keyword">;</span> print_dots <span class="keyword">(</span>i-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [print_dots]</span>

<span class="dynexp"><span class="keyword">fun</span> print_row <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  print_dots <span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">;</span> print <span class="dynstr">"Q "</span><span class="keyword">;</span> print_dots <span class="keyword">(</span>N-i-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">;</span> print <span class="dynstr">"\n"</span><span class="keyword">;</span>
<span class="keyword">)</span></span> <span class="comment">// end of [print_row]</span>

<span class="dynexp"><span class="keyword">fun</span> print_board <span class="keyword">(</span>bd<span class="keyword">:</span> <span class="staexp">int8</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.2</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.3</span></span><span class="keyword">)</span><span class="keyword">;</span>
  print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.4</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.5</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.6</span></span><span class="keyword">)</span><span class="keyword">;</span> print_row <span class="keyword">(</span>bd<span class="dynexp"><span class="keyword">.7</span></span><span class="keyword">)</span><span class="keyword">;</span>
  print_newline <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">// end of [print_board]</span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>print_newline</FONT
> prints out a newline symbol and then
flushes the buffer associated with the standard output. If the reader is
unclear about what buffer flushing means, please feel free to ignore this
aspect of <FONT
COLOR="RED"
>print_newline</FONT
>.
</P
><P
>&#13;As an example, if <FONT
COLOR="RED"
>print_board</FONT
> is called on the board
configuration represented by @(0, 1, 2, 3, 4, 5, 6, 7), then the following
8 lines are printed out:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN649"
></A
><PRE
CLASS="programlisting"
>Q . . . . . . . 
. Q . . . . . . 
. . Q . . . . . 
. . . Q . . . . 
. . . . Q . . . 
. . . . . Q . . 
. . . . . . Q . 
. . . . . . . Q 
</PRE
><P
></P
></DIV
>

</P
><P
>&#13;Given a board and the row number of a queen piece on the board, the
following function <FONT
COLOR="RED"
>board_get</FONT
> returns the column number of the piece:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN653"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> board_get
  <span class="keyword">(</span>bd<span class="keyword">:</span> <span class="staexp">int8</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.0</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">1</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.1</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">2</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.2</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">3</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.3</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">4</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.4</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">5</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.5</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">6</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.6</span></span>
  <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">7</span> <span class="keyword">then</span> bd<span class="dynexp"><span class="keyword">.7</span></span>
  <span class="keyword">else</span> <span class="keyword">~</span><span class="dynexp">1</span></span> <span class="comment">// end of [if]</span>
<span class="comment">// end of [board_get]</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>&#13;Given a board, a row number i and a column number j, the following function
<FONT
COLOR="RED"
>board_set</FONT
> returns a new board that are the same as the original
board except for j being the column number of the queen piece on row i:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN657"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> board_set
  <span class="keyword">(</span>bd<span class="keyword">:</span> <span class="staexp">int8</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int8</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span> <span class="keyword">=</span> bd</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x0 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">1</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x1 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">2</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x2 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">3</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x3 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">4</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x4 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">5</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x5 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">6</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x6 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">7</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> x7 <span class="keyword">=</span> j</span> <span class="keyword">in</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x1<span class="keyword">,</span> x2<span class="keyword">,</span> x3<span class="keyword">,</span> x4<span class="keyword">,</span> x5<span class="keyword">,</span> x6<span class="keyword">,</span> x7<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> bd <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [board_set]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, the functions <FONT
COLOR="RED"
>board_get</FONT
> and <FONT
COLOR="RED"
>board_set</FONT
> are
defined in a rather unwieldy fashion. This is entirely due to the use of
tuples for representing board configurations. If we could use an array to
represent a board configuration, then the implementation would be much
simpler and cleaner. However, we have not yet covered arrays at this point.
</P
><P
>&#13;Let us now implement two testing functions <FONT
COLOR="RED"
>safety_test1</FONT
> and
<FONT
COLOR="RED"
>safety_test2</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN664"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> safety_test1
<span class="keyword">(</span>
  i0<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j0<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> i1<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j1<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
<span class="comment">(*
** [abs]: the absolute value function
*)</span>
  j0 != j1 andalso abs <span class="keyword">(</span>i0 - i1<span class="keyword">)</span> != abs <span class="keyword">(</span>j0 - j1<span class="keyword">)</span></span>
<span class="comment">// end of [safety_test1]</span>

<span class="dynexp"><span class="keyword">fun</span> safety_test2
<span class="keyword">(</span>
  i0<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j0<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> bd<span class="keyword">:</span> <span class="staexp">int8</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i &gt;= <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> safety_test1 <span class="keyword">(</span>i0<span class="keyword">,</span> j0<span class="keyword">,</span> i<span class="keyword">,</span> board_get <span class="keyword">(</span>bd<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">then</span> safety_test2 <span class="keyword">(</span>i0<span class="keyword">,</span> j0<span class="keyword">,</span> bd<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> false
    <span class="comment">// end of [if]</span>
  <span class="keyword">else</span> true</span> <span class="comment">// end of [if]</span>
<span class="comment">// end of [safety_test2]</span>
</p></PRE
><P
></P
></DIV
>


The functionalities of these two functions can be described as such:

<P
></P
><UL
><LI
><P
>&#13;The function <FONT
COLOR="RED"
>safety_test1</FONT
> tests whether a queen piece on row
<FONT
COLOR="RED"
>i0</FONT
> and column <FONT
COLOR="RED"
>j0</FONT
> can capture another one on row
<FONT
COLOR="RED"
>i</FONT
> and column <FONT
COLOR="RED"
>j</FONT
>.
</P
></LI
><LI
><P
>&#13;The function <FONT
COLOR="RED"
>safety_test2</FONT
> tests whether a queen piece on row
<FONT
COLOR="RED"
>i0</FONT
> and column <FONT
COLOR="RED"
>j0</FONT
> can capture any other pieces on a
given board with a row number less than or equal to <FONT
COLOR="RED"
>i</FONT
>.
</P
></LI
></UL
>
</P
><P
>&#13;We are now ready to implement the following function
<FONT
COLOR="RED"
>search</FONT
> based on a standard depth-first search (DFS) algorithm:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN682"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> search
<span class="keyword">(</span>
  bd<span class="keyword">:</span> <span class="staexp">int8</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> nsol<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
<span class="keyword">(</span>j <span class="keyword">&lt;</span> N<span class="keyword">)</span>
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> test <span class="keyword">=</span> safety_test2 <span class="keyword">(</span>i<span class="keyword">,</span> j<span class="keyword">,</span> bd<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">if</span> test
    <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> bd1 <span class="keyword">=</span> board_set <span class="keyword">(</span>bd<span class="keyword">,</span> i<span class="keyword">,</span> j<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> i+<span class="dynexp">1</span> <span class="keyword">=</span> N
        <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">print!</span> <span class="keyword">(</span><span class="dynstr">"Solution #"</span><span class="keyword">,</span> nsol+<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynstr">":\n\n"</span><span class="keyword">)</span></span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_board <span class="keyword">(</span>bd1<span class="keyword">)</span></span>
        <span class="keyword">in</span>
          search <span class="keyword">(</span>bd<span class="keyword">,</span> i<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">,</span> nsol+<span class="dynexp">1</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [then]</span>
        <span class="keyword">else</span> <span class="keyword">(</span>
          search <span class="keyword">(</span>bd1<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">0</span><span class="comment">(*j*)</span><span class="keyword">,</span> nsol<span class="keyword">)</span> <span class="comment">// positioning next piece</span>
        <span class="keyword">)</span> <span class="comment">(* end of [else] *)</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">// end of [then]</span>
    <span class="keyword">else</span> search <span class="keyword">(</span>bd<span class="keyword">,</span> i<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">,</span> nsol<span class="keyword">)</span>
  <span class="comment">// end of [if]</span>
<span class="keyword">end</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">(</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span>
    <span class="keyword">then</span> search <span class="keyword">(</span>bd<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">,</span> board_get <span class="keyword">(</span>bd<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span> + <span class="dynexp">1</span><span class="keyword">,</span> nsol<span class="keyword">)</span> <span class="keyword">else</span> nsol
  <span class="comment">// end of [if]</span>
<span class="keyword">)</span> <span class="comment">(* end of [else] *)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [search] *)</span>
</p></PRE
><P
></P
></DIV
>


The return value of <FONT
COLOR="RED"
>search</FONT
> is the number of distinct solutions
to the eight queens puzzle. The symbol <FONT
COLOR="RED"
>print!</FONT
> in the body of
<FONT
COLOR="RED"
>search</FONT
> is a special identifier in ATS: It takes an indefinite
number of arguments and then applies <FONT
COLOR="RED"
>print</FONT
> to each of
them. Following is the first solution printed out by
<FONT
COLOR="RED"
>print_board</FONT
> during a call to the function <FONT
COLOR="RED"
>search</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN690"
></A
><PRE
CLASS="programlisting"
>Q . . . . . . . 
. . . . Q . . . 
. . . . . . . Q 
. . . . . Q . . 
. . Q . . . . . 
. . . . . . Q . 
. Q . . . . . . 
. . . Q . . . . 
</PRE
><P
></P
></DIV
>


There are 92 distinct solutions in total.
</P
><P
>&#13;Note that the entire code in this section plus some additional code for
testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/queens.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="mutually-recursive-functions"
>Mutually Recursive Functions</A
></H2
><P
>&#13;A collection of functions are defined mutually recursively if each function
can make calls in its body to any functions in this collection.  Mutually
recursive functions are commonly encountered in practice.

</P
><P
>&#13;As an example, let P be a function on natural numbers defined as follows:

<P
></P
><UL
><LI
><P
>P(0) = 1</P
></LI
><LI
><P
>P(n+1) = 1 + the sum of the products of i and P(i) for i ranging from 1 to n
</P
></LI
></UL
>

Let us introduce a function Q such that Q(n) is the sum of the products of
i and P(i) for i ranging from 1 to n. Then the functions P and Q can be
defined mutually recursively as follows:

<P
></P
><UL
><LI
><P
>P(0) = 1</P
></LI
><LI
><P
>P(n+1) = 1 + Q(n)</P
></LI
><LI
><P
>Q(0) = 0</P
></LI
><LI
><P
>Q(n+1) = Q(n) + (n+1) * P(n+1)</P
></LI
></UL
>

The following implementation of P and Q is a direct translation of their
definitions into ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN712"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> P <span class="keyword">(</span>n<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="dynexp">1</span> + Q<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span>
<span class="keyword">and</span> Q <span class="keyword">(</span>n<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> Q<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> + n * P<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">0</span></span>
</p></PRE
><P
></P
></DIV
>


Note that the keyword <FONT
COLOR="RED"
>and</FONT
> is used to combine function
definitions.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="mutual-tail-recursion"
>Mutually Defined Tail-Recursion</A
></H2
><P
>&#13;Suppose that foo and bar are two mutually defined recursive functions.  In
the body of foo or bar, a tail-call to foo or bar is a mutually recursive
tail-call. For instance, the following two functions <FONT
COLOR="RED"
>isevn</FONT
> and
<FONT
COLOR="RED"
>isodd</FONT
> are mutually recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN720"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
isevn <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> isodd <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> true
<span class="comment">//</span>
<span class="keyword">and</span>
isodd <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> isevn <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> false</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The mutually recursive call to <FONT
COLOR="RED"
>isodd</FONT
> in the body of
<FONT
COLOR="RED"
>isevn</FONT
> is a tail-call, and the mutually recursive call to
<FONT
COLOR="RED"
>isevn</FONT
> in the body of <FONT
COLOR="RED"
>isodd</FONT
> is also a tail-call.  If
we want that these two tail-calls be compiled into local jumps, we should
replace the keyword <FONT
COLOR="RED"
>fun</FONT
> with the keyword <FONT
COLOR="RED"
>fnx</FONT
> as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN728"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fnx</span>
isevn <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> isodd <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> true
<span class="comment">//</span>
<span class="keyword">and</span>
isodd <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> isevn <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> false</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


What the ATS compiler does in this case is to combine these two functions
into a single one so that each mutually recursive tail-call in their bodies
can be turned into a self tail-call in the body of the combined function,
which is then ready to be compiled into a local jump.
</P
><P
>When writing code corresponding to embedded loops in an imperative
programming language such as C or Java, we often need to make sure that
mutually recursive tail-calls are compiled into local jumps. The following
function <FONT
COLOR="RED"
>print_multable</FONT
> is implemented to print out a standard
multiplication table for nonzero digits:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN732"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
print_multable
  <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> N 9</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fnx</span>
loop1
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i &lt;= N <span class="keyword">then</span> loop2 <span class="keyword">(</span>i<span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">and</span>
loop2
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> j &lt;= i
    <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> j &gt;= <span class="dynexp">2</span> <span class="keyword">then</span> print <span class="dynstr">" "</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extfcall</span><span class="keyword">(</span>void<span class="keyword">,</span> "printf"<span class="keyword">,</span> "%dx%d=%2.2d"<span class="keyword">,</span> j<span class="keyword">,</span> i<span class="keyword">,</span> j*i<span class="keyword">)</span></span></span>
    <span class="keyword">in</span>
      loop2 <span class="keyword">(</span>i<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">)</span> 
    <span class="keyword">end</span> <span class="comment">// end of [then]</span>
    <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">in</span> loop1 <span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
  <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop1 <span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [print_multable]</span>
</p></PRE
><P
></P
></DIV
>


The functions <FONT
COLOR="RED"
>loop1</FONT
> and <FONT
COLOR="RED"
>loop2</FONT
> are defined
mutually recursively, and the mutually recursive calls in their bodies are
all tail-calls. The keyword <FONT
COLOR="RED"
>fnx</FONT
> indicates to the ATS compiler
that the functions <FONT
COLOR="RED"
>loop1</FONT
> and <FONT
COLOR="RED"
>loop2</FONT
> should be
combined so that these tail-calls can be compiled into local jumps. In a
case where <FONT
COLOR="RED"
>N</FONT
> is a large number (e.g., 1,000,000), calling
<FONT
COLOR="RED"
>loop1</FONT
> may run the risk of stack overflow if these tail-calls
are not compiled into local jumps.
</P
><P
>&#13;When called, the function <FONT
COLOR="RED"
>print_multable</FONT
> prints out the
following multiplication table:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN743"
></A
><PRE
CLASS="programlisting"
>1x1=01
1x2=02 2x2=04
1x3=03 2x3=06 3x3=09
1x4=04 2x4=08 3x4=12 4x4=16
1x5=05 2x5=10 3x5=15 4x5=20 5x5=25
1x6=06 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36
1x7=07 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49
1x8=08 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64
1x9=09 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;In summary, the very ability to turn mutually recursive tail-calls into
local jumps makes it possible to implement embedded loops as mutually
tail-recursive functions. This ability is indispensable for advocating the
practice of replacing loops with recursive functions in ATS.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="envless-functions-and-function-closures"
>Envless Functions and Closure-Functions</A
></H2
><P
>&#13;I use <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>envless</I
></SPAN
> as a shorthand for environmentless,
which is not a legal word but I suppose that you have no problem figuring
out what it means.
</P
><P
>&#13;An envless function is represented by a pointer pointing to some place in a
code segment where the object code for executing a call to this function is
located. Every function in the programming language C is envless. A
closure-function is also represented by a pointer, but the pointer points
to some place in a heap where a tuple is allocated (at run-time). Usually,
the first component of this tuple is a pointer representing an envless
function and the rest of the components represent some bindings. A tuple as
such is often referred to as a closure-function or simply closure, which
can be thought of as an envless function paired with an environment. It is
possible that the environment of a closure-function is empty, but this does
not equate a closure-function with an envless function. Every function in
functional languages such as ML and Haskell is a closure-function.
</P
><P
>&#13;In the following example, the function <FONT
COLOR="RED"
>sum</FONT
>, which is assigned
the type <FONT
COLOR="RED"
>(int) -&#62; int</FONT
>, sums up all the integers between 1 and a
given natural number:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN754"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
  <span class="keyword">(</span>
    i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span> loop <span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">,</span> res+i<span class="keyword">)</span> <span class="keyword">else</span> res</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="dynexp">1</span><span class="comment">(*i*)</span><span class="keyword">,</span> <span class="dynexp">0</span><span class="comment">(*res*)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sum]</span>
</p></PRE
><P
></P
></DIV
>


The inner function <FONT
COLOR="RED"
>loop</FONT
> is a closure-function as is indicated
by the special syntax <FONT
COLOR="RED"
>:&#60;cloref1&#62;</FONT
>, and the type assigned
to <FONT
COLOR="RED"
>loop</FONT
> is denoted by <FONT
COLOR="RED"
>(int, int) -&#60;cloref1&#62;
int</FONT
>. Hence, envless functions and closure-functions can be distinguished
at the level of types.
</P
><P
>&#13;If the syntax <FONT
COLOR="RED"
>:&#60;cloref1&#62;</FONT
> is replaced with the colon
symbol <FONT
COLOR="RED"
>:</FONT
> alone, the code can still pass typechecking but its
compilation may eventually lead to a warning or even an error indicating
that <FONT
COLOR="RED"
>loop</FONT
> cannot be compiled into a toplevel function in C. The
reason for this warning/error is due to the body of <FONT
COLOR="RED"
>loop</FONT
>
containing a variable <FONT
COLOR="RED"
>n</FONT
> that is neither at toplevel nor a part
of the arguments of <FONT
COLOR="RED"
>loop</FONT
> itself. It is straightforward to make
<FONT
COLOR="RED"
>loop</FONT
> an envless function by including <FONT
COLOR="RED"
>n</FONT
> as an
argument in addition to the original ones:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN769"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
  <span class="keyword">(</span>
    n<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span> loop <span class="keyword">(</span>n<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> res+i<span class="keyword">)</span> <span class="keyword">else</span> res</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>n<span class="keyword">,</span> <span class="dynexp">1</span><span class="comment">(*i*)</span><span class="keyword">,</span> <span class="dynexp">0</span><span class="comment">(*res*)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sum]</span>
</p></PRE
><P
></P
></DIV
>


As a matter of fact, what happens during compilation is that the first
implementation of <FONT
COLOR="RED"
>sum</FONT
> and <FONT
COLOR="RED"
>loop</FONT
> gets translated,
more or less, into the second implementation, and there is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>no</I
></SPAN
>
actual creation of closures at run-time.
</P
><P
>&#13;The need for creating closures often appears when a function is not
directly applied. For instance, the return value of a function call may
also be a function. In the following code, the defined function
<FONT
COLOR="RED"
>addx</FONT
> returns another function when applied to a given integer
<FONT
COLOR="RED"
>x</FONT
>, and the returned function is a closure-function, which
always adds the integer <FONT
COLOR="RED"
>x</FONT
> to its own argument:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN778"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> addx <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">lam</span> y <span class="keyword">=&gt;</span> x + y</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> plus1 <span class="keyword">=</span> addx <span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span></span> <span class="comment">// [plus1] is of the type int -&lt;cloref1&gt; int</span>
<span class="dynexp"><span class="keyword">val</span> plus2 <span class="keyword">=</span> addx <span class="keyword">(</span><span class="dynexp">2</span><span class="keyword">)</span></span> <span class="comment">// [plus2] is of the type int -&lt;cloref1&gt; int</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


It should be clear that <FONT
COLOR="RED"
>plus1(0)</FONT
> and <FONT
COLOR="RED"
>plus2(0)</FONT
>
return <FONT
COLOR="RED"
>1</FONT
> and <FONT
COLOR="RED"
>2</FONT
>, respectively.  The closure-function
that is given the name <FONT
COLOR="RED"
>plus1</FONT
> consists of an envless function
and an environment binding <FONT
COLOR="RED"
>x</FONT
> to <FONT
COLOR="RED"
>1</FONT
>. The envless
function can essentially be described by the pseudo syntax <FONT
COLOR="RED"
>lam
(env, y) =&#62; env.x + y</FONT
>, where <FONT
COLOR="RED"
>env</FONT
> and <FONT
COLOR="RED"
>env.x</FONT
> refer
to an environment and the value to which <FONT
COLOR="RED"
>x</FONT
> is bound in that
environment. When evaluating <FONT
COLOR="RED"
>plus1(0)</FONT
>, we can first bind
<FONT
COLOR="RED"
>env</FONT
> and <FONT
COLOR="RED"
>y</FONT
> to the environment in <FONT
COLOR="RED"
>plus1</FONT
>
and the argument <FONT
COLOR="RED"
>0</FONT
>, respectively, and then start to evaluate
the body of the envless function in <FONT
COLOR="RED"
>plus1</FONT
>, which is
<FONT
COLOR="RED"
>env.x + y</FONT
>. Clearly, this evaluation yields the value
<FONT
COLOR="RED"
>1</FONT
> as is expected.
</P
><P
>&#13;Closures are often passed as arguments to functions that are referred
to as higher-order functions.  It is also fairly common for closures to
be embedded in data structures.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="higher-order-functions"
>Higher-Order Functions</A
></H2
><P
>A higher-order function is a function that take another function as
its argument. For instance, the following defined function
<FONT
COLOR="RED"
>rtfind</FONT
> is a higher-order one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN804"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> rtfind
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
    f<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> f<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> n <span class="keyword">else</span> loop <span class="keyword">(</span>f<span class="keyword">,</span> n+<span class="dynexp">1</span><span class="keyword">)</span></span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>f<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [rtfind]</span>
</p></PRE
><P
></P
></DIV
>


Given a function from integers to integers, <FONT
COLOR="RED"
>rtfind</FONT
> searches
for the first natural number that is a root of the function. For instance,
calling <FONT
COLOR="RED"
>rtfind</FONT
> on the polynomial function <FONT
COLOR="RED"
>lam x =&#62; x * x
- x - 110</FONT
> returns <FONT
COLOR="RED"
>11</FONT
>.  Note that <FONT
COLOR="RED"
>rtfind</FONT
>
loops forever if it is applied to a function that does not have a root.
</P
><P
>Higher-order functions can greatly facilitate code reuse, and I now
present a simple example to illustrate this point.  The following defined
functions <FONT
COLOR="RED"
>sum</FONT
> and <FONT
COLOR="RED"
>prod</FONT
> compute the sum and
product of the integers ranging from 1 to a given natural number,
respectively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN814"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sum <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> sum <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> + n <span class="keyword">else</span> <span class="dynexp">0</span></span>
<span class="dynexp"><span class="keyword">fun</span> prod <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> prod <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> * n <span class="keyword">else</span> <span class="dynexp">1</span></span>
</p></PRE
><P
></P
></DIV
>


The similarity between the functions <FONT
COLOR="RED"
>sum</FONT
> and <FONT
COLOR="RED"
>prod</FONT
>
is evident.  We can define a higher-function <FONT
COLOR="RED"
>ifold</FONT
> and then
implement <FONT
COLOR="RED"
>sum</FONT
> and <FONT
COLOR="RED"
>prod</FONT
> based on
<FONT
COLOR="RED"
>ifold</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN822"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> ifold
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> f <span class="keyword">(</span>ifold <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">,</span> f<span class="keyword">,</span> ini<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> ini</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> sum <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> ifold <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> res + x<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> prod <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> ifold <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> res * x<span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


If we ever want to compute the sum of the squares of the integers ranging
from 1 to a given natural number n, we can readily do it by defining a
function based on <FONT
COLOR="RED"
>ifold</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN825"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sqrsum <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> ifold <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> res + x * x<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Suppose we generalize <FONT
COLOR="RED"
>sqrsum</FONT
> to the following function
<FONT
COLOR="RED"
>sqrmodsum</FONT
> in order to compute the sum of the squares of the
integers ranging from 1 to n that are multiples of a given number d:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN829"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sqrmodsum
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> d<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  ifold <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">if</span> x mod d <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> res + x * x <span class="keyword">else</span> res<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="comment">// end of [sqrmodsum]</span>
</p></PRE
><P
></P
></DIV
>


For someone unfamilar with the distinction between an envless function and
a closure-function, it may be a bit suprising to learn that this
generalization does not actually work. The simple reason is that
<FONT
COLOR="RED"
>ifold</FONT
> expects its second argument to be an envless function but
the function passed to <FONT
COLOR="RED"
>ifold</FONT
> in the body of
<FONT
COLOR="RED"
>sqrmodsum</FONT
> is clearly not envless (due to its use of
<FONT
COLOR="RED"
>d</FONT
>). To address the issue, we can implement a variant of
<FONT
COLOR="RED"
>ifold</FONT
> as follows and then implement <FONT
COLOR="RED"
>sqrmodsum</FONT
> based
on this variant:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN837"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ifold2
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> f <span class="keyword">(</span>ifold2 <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">,</span> f<span class="keyword">,</span> ini<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> ini</span>
<span class="comment">// end of [ifold2]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sqrmodsum <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> d<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  ifold2 <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">if</span> x mod d <span class="keyword">then</span> res + x * x <span class="keyword">else</span> res<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="comment">// end of [sqrmodsum]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


While <FONT
COLOR="RED"
>ifold2</FONT
> is indeed more general than <FONT
COLOR="RED"
>ifold</FONT
>,
this generality does come with a price. Whenever <FONT
COLOR="RED"
>sqrmodsum</FONT
> is
called, a closure-function must be created on heap and then passed to
<FONT
COLOR="RED"
>ifold2</FONT
>; this closure-function is of no further use after the
call returns and the memory it occupies can only be properly relcaimed
through garbage collection (GC). Therefore, calling functions like
<FONT
COLOR="RED"
>sqrmodsum</FONT
> can readily result in memory leaks in a setting where
GC is not available. Fortunately, there are also linear closure-functions
in ATS, which do not cause any memory leaks even in the absence of GC as
they are required to be explicitly freed by the programmer. I will cover
this interesting programming feature elsewhere.
</P
><P
>&#13;As more features of ATS are introduced, higher-order functions will become
even more effective in facilitating code reuse.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example-binary-search-for-fun"
>Example: Binary Search for Fun</A
></H2
><P
>&#13;While binary search is often performed on an ordered array to check whether
a given element is stored in that array, it can also be employed to compute
the inverse of an increasing or decreasing function on integers. In the
following code, the defined function <FONT
COLOR="RED"
>bsearch_fun</FONT
> returns an
integer i0 such that f(i) &#60;= x0 holds for i ranging from lb to i0,
inclusive, and x0 &#60; f(i) holds for i ranging from i0+1 to ub, inclusive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN849"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="comment">// The type [uint] is for unsigned integers</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> bsearch_fun
<span class="keyword">(</span>
  f<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">uint</span>
<span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">,</span> lb<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> ub<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> lb &lt;= ub <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> mid <span class="keyword">=</span> lb + <span class="keyword">(</span>ub - lb<span class="keyword">)</span> / <span class="dynexp">2</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> x0 <span class="keyword">&lt;</span> f <span class="keyword">(</span>mid<span class="keyword">)</span> <span class="keyword">then</span>
      bsearch_fun <span class="keyword">(</span>f<span class="keyword">,</span> x0<span class="keyword">,</span> lb<span class="keyword">,</span> mid-<span class="dynexp">1</span><span class="keyword">)</span>
    <span class="keyword">else</span>
      bsearch_fun <span class="keyword">(</span>f<span class="keyword">,</span> x0<span class="keyword">,</span> mid+<span class="dynexp">1</span><span class="keyword">,</span> ub<span class="keyword">)</span>
    <span class="comment">// end of [if]</span>
  <span class="keyword">end</span> <span class="keyword">else</span> ub</span> <span class="comment">// end of [if]</span>
<span class="comment">// end of [bsearch_fun]</span>
</p></PRE
><P
></P
></DIV
>


As an example, the following function <FONT
COLOR="RED"
>isqrt</FONT
> is defined based
on <FONT
COLOR="RED"
>bsearch_fun</FONT
> to compute the integer square root of a given
natural number, that is, the largest integer whose square is less than or
equal to the given natural number:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN853"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="comment">// Assuming that [uint] is of 32 bits</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
ISQRT_MAX <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp">1</span> &lt;&lt; <span class="dynexp">16</span><span class="keyword">)</span> - <span class="dynexp">1</span></span> <span class="comment">// = 65535</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> isqrt
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  bsearch_fun <span class="keyword">(</span><span class="keyword">lam</span> i <span class="keyword">=&gt;</span> square<span class="keyword">(</span>g0i2u<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> ISQRT_MAX<span class="keyword">)</span></span>
<span class="comment">// end of [isqrt]</span>
</p></PRE
><P
></P
></DIV
>


Note that the function <FONT
COLOR="RED"
>g0i2u</FONT
> is for casting a signed integer
into an unsigned one and the function <FONT
COLOR="RED"
>square</FONT
> returns the square
of its argument.
</P
><P
>Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/bsearch.dats"
TARGET="_top"
>on-line</A
>
the entire code in this section plus some additional code for testing.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example-a-higher-order-fun-puzzle"
>Example: A Higher-Order Fun Puzzle</A
></H2
><P
>&#13;Let us first introduce a type definition as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN862"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">I<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span></span>
</p></PRE
><P
></P
></DIV
>


Given a type T, I(T) is for a closure-function that maps a given input
value of type T to an output value of the same type T. Given a function f
of type I(T), we can compose f with itself to form another function, which
just applies f twice to a given argument. The following function template
<FONT
COLOR="RED"
>twice</FONT
> does precisely the described function composition:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN865"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
twice <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp">I</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">I</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> f <span class="keyword">(</span>f <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Let us now take a look at some interesting code involving <FONT
COLOR="RED"
>twice</FONT
>
that is also likely to be puzzling:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN868"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">I0 <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="keyword">typedef</span> <span class="staexp">I1 <span class="keyword">=</span> <span class="staexp">I</span><span class="keyword">(</span><span class="staexp">I0</span><span class="keyword">)</span></span>
<span class="keyword">typedef</span> <span class="staexp">I2 <span class="keyword">=</span> <span class="staexp">I</span><span class="keyword">(</span><span class="staexp">I1</span><span class="keyword">)</span></span>
<span class="keyword">typedef</span> <span class="staexp">I3 <span class="keyword">=</span> <span class="staexp">I</span><span class="keyword">(</span><span class="staexp">I2</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> Z <span class="keyword">=</span> <span class="dynexp">0</span></span>
<span class="dynexp"><span class="keyword">val</span> S <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> x + <span class="dynexp">1</span></span>
<span class="dynexp"><span class="keyword">val</span> ans0 <span class="keyword">=</span> twice&lt;<span class="staexp">I0</span><span class="keyword">&gt;</span><span class="keyword">(</span>S<span class="keyword">)</span><span class="keyword">(</span>Z<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> ans1 <span class="keyword">=</span> twice&lt;<span class="staexp">I1</span><span class="keyword">&gt;</span><span class="keyword">(</span>twice&lt;<span class="staexp">I0</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>S<span class="keyword">)</span><span class="keyword">(</span>Z<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> ans2 <span class="keyword">=</span> twice&lt;<span class="staexp">I2</span><span class="keyword">&gt;</span><span class="keyword">(</span>twice&lt;<span class="staexp">I1</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>twice&lt;<span class="staexp">I0</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>S<span class="keyword">)</span><span class="keyword">(</span>Z<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> ans3 <span class="keyword">=</span> twice&lt;<span class="staexp">I3</span><span class="keyword">&gt;</span><span class="keyword">(</span>twice&lt;<span class="staexp">I2</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>twice&lt;<span class="staexp">I1</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>twice&lt;<span class="staexp">I0</span><span class="keyword">&gt;</span><span class="keyword">)</span><span class="keyword">(</span>S<span class="keyword">)</span><span class="keyword">(</span>Z<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that the type definitions
<FONT
COLOR="RED"
>I0</FONT
>,
<FONT
COLOR="RED"
>I1</FONT
>,
<FONT
COLOR="RED"
>I2</FONT
>, and
<FONT
COLOR="RED"
>I3</FONT
> are introduced to make the above code more easily
accessible.
</P
><P
>&#13;Obviously, <FONT
COLOR="RED"
>Z</FONT
> stands for the integer 0 and <FONT
COLOR="RED"
>S</FONT
> for the
successor function on integers. Also, <FONT
COLOR="RED"
>ans0</FONT
> equals 2 as it is
the result of applying <FONT
COLOR="RED"
>S</FONT
> to <FONT
COLOR="RED"
>Z</FONT
> twice. Let
<FONT
COLOR="RED"
>S2</FONT
> be the function that applies <FONT
COLOR="RED"
>S</FONT
> twice.  It is
clear that <FONT
COLOR="RED"
>ans1</FONT
> is the result of applying <FONT
COLOR="RED"
>S2</FONT
> to
<FONT
COLOR="RED"
>Z</FONT
> twice and thus equals 4. With a bit more effort, one should
be able to figure out that the value of <FONT
COLOR="RED"
>ans2</FONT
> is 16. What is the
value of <FONT
COLOR="RED"
>ans3</FONT
>? In general, what is the nth value in the
sequence of <FONT
COLOR="RED"
>ans0</FONT
>, <FONT
COLOR="RED"
>ans1</FONT
>, <FONT
COLOR="RED"
>ans2</FONT
>, etc.?
I leave these questions as exercises for the interested reader.

</P
><P
>Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/twice.dats"
TARGET="_top"
>on-line</A
>
the entire code in this section plus some additional code for testing.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="currying-and-uncurrying"
>Currying and Uncurrying</A
></H2
><P
>&#13;Currying, which is named after the logician Haskell Curry, means to
turn a function taking multiple arguments simultaneously into a function of
the same body (modulo corresponding recursive function calls being changed
accordingly) that takes these arguments sequentially. Uncurrying means
precisely the opposite of currying. In the following code, both of the
defined functions <FONT
COLOR="RED"
>acker1</FONT
> and <FONT
COLOR="RED"
>acker2</FONT
> implement the
Ackermann's function (which is famous for being recursive but not primitive
recursive):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN897"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> acker1
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker1 <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> acker1 <span class="keyword">(</span>m<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> acker1 <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">else</span> n+<span class="dynexp">1</span> <span class="comment">// end of [if]</span>
<span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">fun</span> acker2
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker2 <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">(</span>acker2 m <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> acker2 <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">)</span> <span class="dynexp">1</span>
  <span class="keyword">else</span> n+<span class="dynexp">1</span> <span class="comment">// end of [if]</span>
<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>acker2</FONT
> is a curried version of <FONT
COLOR="RED"
>acker1</FONT
>
while the function <FONT
COLOR="RED"
>acker1</FONT
> in an uncurried version of
<FONT
COLOR="RED"
>acker2</FONT
>. Applying <FONT
COLOR="RED"
>acker2</FONT
> to an integer value
generates a closure-function, which causes a memory-leak unless it can be
reclaimed by garbage collection (GC) at run-time.
</P
><P
>&#13;In functional languages such as ML and Haskell, a function of multiple
arguments needs to be either curried or translated into a corresponding
unary function of a single argument that itself is a tuple. In such
languages, currying often leads to better performance at run-time and thus
is preferred. In ATS, functions of multiple arguments are supported
directly. Also, given a function of multiple arguments, a curried version
of the function is likely to perform less efficiently at run-time than the
function itself (due to the treatment of curried functions by the ATS
compiler <B
CLASS="command"
>atsopt</B
>).  Therefore, the need for currying in
ATS is greatly diminished. Unless convincing reasons can be given, currying
is in general <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not</I
></SPAN
> a recommended programming style in ATS.
</P
><P
>&#13;Please find
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FUNCTION/acker.dats"
TARGET="_top"
>on-line</A
>
the entire code in this section plus some additional
code for testing.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="datatypes"
></A
>Chapter 4. Datatypes</H1
><P
>The feature of datatypes in ATS in largely taken from ML.
</P
><P
>A datatype is
like a tagged union type. For each datatype, there are some constructors
associated with it, and these constructors are needed for constructing
values of the datatype.  As an example, the following syntax declares a
datatype named <FONT
COLOR="RED"
>intopt</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN914"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">intopt <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">intopt_none <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp">intopt_some <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [intopt]</span>
</p></PRE
><P
></P
></DIV
>


There are two constructors associated with <FONT
COLOR="RED"
>intopt</FONT
>:
<FONT
COLOR="RED"
>intopt_none</FONT
>, which is nullary, and <FONT
COLOR="RED"
>intopt_some</FONT
>,
which is unary. For instance, <FONT
COLOR="RED"
>intopt_none()</FONT
> and
<FONT
COLOR="RED"
>intopt_some(1)</FONT
> are two values of the type <FONT
COLOR="RED"
>intopt</FONT
>.
In order for accessing components in such values, a mechanism often
referred to as pattern-matching is provided in ATS. I will demonstrate
through examples that datatypes plus pattern matching can offer not only
great convenience in programming but also clarity in code.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATATYPE/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="patterns"
>Patterns</A
></H2
><P
>Patterns in ATS can be defined inductively as follows:

<P
></P
><UL
><LI
><P
>&#13;Certain constant values such as integers, booleans, chars, floating point
numbers, and strings are patterns.
</P
></LI
><LI
><P
>The void-value () is a pattern.</P
></LI
><LI
><P
>The underscore symbol <FONT
COLOR="RED"
>_</FONT
> represents a special wildcard pattern.
</P
></LI
><LI
><P
>Variables are patterns.
</P
></LI
><LI
><P
>&#13;A tuple of patterns, either boxed or unboxed, is a pattern.
</P
></LI
><LI
><P
>&#13;A record of patterns, either boxed or unboxed, is a pattern.
</P
></LI
><LI
><P
>&#13;Given a constructor C, a pattern can be formed by applying C to a given
list of patterns.
</P
></LI
><LI
><P
>&#13;Given a variable x and a pattern pat, (x <FONT
COLOR="RED"
>as</FONT
> pat) is a
reference-pattern, where <FONT
COLOR="RED"
>as</FONT
> is a keyword.
</P
></LI
><LI
><P
>&#13;Some other forms of patterns will be introduced elsewhere.
</P
></LI
></UL
>

Each variable can occur at most once in a given pattern, and this is
referred as the linearity restriction on variables in patterns. For
instance, (x, x) is not a legal pattern as the variable x appears twice in
it. However, this restriction does not apply to the variable <FONT
COLOR="RED"
>_</FONT
>,
which represents the wildcard pattern.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="pattern-matching"
>Pattern-Matching</A
></H2
><P
>&#13;Pattern matching means matching values against patterns. In the case where
a value matches a pattern, a collection of bindings are generated between
the variables in the pattern and certain components in the
value. Pattern-matching is performed according to the following set of
rules:

<P
></P
><UL
><LI
><P
>&#13;A value that matches a constant pattern must be the same constant, and this
matching generates no bindings.
</P
></LI
><LI
><P
>&#13;The void-value () only matches the void-pattern (), and this matching
generates no bindings.
</P
></LI
><LI
><P
>Any value can match the wildcard pattern, and this matching generates no bindings.
</P
></LI
><LI
><P
>&#13;Any value can match a variable pattern, and this matching generates a
binding between the variable and the value.
</P
></LI
><LI
><P
>&#13;A tuple-value matches a tuple-pattern if they are of the same length and
each value component in the former matches the corresponding pattern
component in the latter, and this matching generates a collection of
bindings that is the union of the bindings generated from matching the
value components in the tuple-value against the pattern components in the
tuple-pattern.
</P
></LI
><LI
><P
>&#13;A record-value matches a record-pattern if they have the same field names
and each value component in the former matches the corresponding pattern
component in the latter, and this matching generates a collection of
bindings that is the union of the bindings generated from matching the
value components in the record-value against the pattern components in the
record-pattern.
</P
></LI
><LI
><P
>&#13;Given a pattern formed by applying a constructor C to some pattern
arguments, a value matches this pattern if the value is formed by applying
C to some value arguments matching the pattern arguments, and this matching
generates a collection of bindings that is the union of the bindings
generated from matching the value arguments against the pattern arguments.
</P
></LI
><LI
><P
>&#13;Given a referenced pattern (x <FONT
COLOR="RED"
>as</FONT
> pat), a value matches the
pattern if it matches pat, and this matching generates a collection of
bindings that extends the bindings generated from matching the value
against pat with a binding from x to the value.
</P
></LI
></UL
>

Suppose we have a tuple-value (0, 1, 2, 3) and a tuple-pattern (0, _, x,
y). Then the value matches the pattern and this matching yields bindings
from x and y to 2 and 3, respectively.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="matching_clauses_and_case-expressions"
>Matching Clauses and Case-Expressions</A
></H2
><P
>Given a pattern pat and an expression exp, (pat <FONT
COLOR="RED"
>=&#62;</FONT
> exp) is a
matching clause. The pattern pat and the expression exp are referred to as
the guard and the body of the matching clause.
</P
><P
>&#13;Given an expression exp0 and a sequence of matching clauses clseq, a
case-expression can be formed as such: (<FONT
COLOR="RED"
>case</FONT
> exp0
<FONT
COLOR="RED"
>of</FONT
> clseq). To evaluate the case-expression under a given
environment ENV0, we first evaluate exp0 under ENV0 to a value. If this
value does not match the guard of any clause in clseq, then the evaluation
of the case-expression aborts. Otherwise, we choose the first clause in
clseq such that the value matches the guard of the clause. Let ENV1 be the
environment that extends ENV0 with the bindings generated from this
matching, and we evaluate the body of the chosen clause under ENV1. The
value obtained from this evaluation is the value of the case-expression
being evaluated.  </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="enumerative_datatypes"
>Enumerative Datatypes</A
></H2
><P
>&#13;The simplest form of datatypes is for enumerating a finite number of
constants. For instance, the following concrete syntax introduces a
datatype of the name <FONT
COLOR="RED"
>wday</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN982"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">wday <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">Monday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Tuesday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Wednesday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Thursday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Friday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Saturday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">Sunday <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [wday]</span>
</p></PRE
><P
></P
></DIV
>


where the first bar symbol (|) is optional.  There are 7 nullary
constructors introduced in the datatype declaration: <FONT
COLOR="RED"
>Monday</FONT
>
through <FONT
COLOR="RED"
>Sunday</FONT
>, which are for constructing values of the type
<FONT
COLOR="RED"
>wday</FONT
>. For instance, <FONT
COLOR="RED"
>Monday()</FONT
> is a value of the type
<FONT
COLOR="RED"
>wday</FONT
>. Given a nullary constructor C, we can write C for C() as
a value. For instance, we can write <FONT
COLOR="RED"
>Monday</FONT
> for
<FONT
COLOR="RED"
>Monday()</FONT
>. However, one should <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not</I
></SPAN
> assume
that <FONT
COLOR="RED"
>Tuesday</FONT
> is something like <FONT
COLOR="RED"
>Monday+1</FONT
>.
</P
><P
>&#13;The following code implements a function that tests whether a given value
of the type <FONT
COLOR="RED"
>wday</FONT
> is a weekday or not:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN996"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> isWeekday
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">wday</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">case</span> x <span class="keyword">of</span>
  <span class="keyword">|</span> Monday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true <span class="comment">// the first bar (|) is optional</span>
  <span class="keyword">|</span> Tuesday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> Wednesday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> Thursday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> Friday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> Saturday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
  <span class="keyword">|</span> Sunday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false</span>
<span class="comment">// end of [isWeekday]</span>
</p></PRE
><P
></P
></DIV
>


Given a unary constructor C, C() is a pattern that can only match the value
C(). Note that C() <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>cannot</I
></SPAN
> be written as C when it is
used as a pattern. If <FONT
COLOR="RED"
>Monday()</FONT
> is written as <FONT
COLOR="RED"
>Monday</FONT
> in
the body of the function <FONT
COLOR="RED"
>isWeekday</FONT
>, then an error message is to be
reported during typechecking, indicating that all the clauses after the
first one are redundant. This is simply due to <FONT
COLOR="RED"
>Monday</FONT
> being
treated as a variable pattern, which is matched by any value. A likely more
sensible implementation of <FONT
COLOR="RED"
>isWeekday</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1004"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> isWeekday
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">wday</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">case</span> x <span class="keyword">of</span>
  <span class="keyword">|</span> Saturday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false <span class="keyword">|</span> Sunday<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> true</span>
<span class="comment">// end of [isWeekday]</span>
</p></PRE
><P
></P
></DIV
>


This implementation works because pattern-matching is done sequentially at
run-time: If a value of the type <FONT
COLOR="RED"
>wday</FONT
> does not match either of
<FONT
COLOR="RED"
>Saturday()</FONT
> and <FONT
COLOR="RED"
>Sunday()</FONT
>, then it must match one of
<FONT
COLOR="RED"
>Monday()</FONT
> , <FONT
COLOR="RED"
>Tuesday()</FONT
> , <FONT
COLOR="RED"
>Wednesday()</FONT
> ,
<FONT
COLOR="RED"
>Thursday()</FONT
>, and <FONT
COLOR="RED"
>Friday()</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="recursive_datatypes"
>Recursively Defined Datatypes</A
></H2
><P
>&#13;A recursively defined datatype (or recursive datatype for short) is one
such that its associated constructors may form values by applying to values
of the datatype itself. For instance, the following declared datatype
<FONT
COLOR="RED"
>charlst</FONT
> is recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1018"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">charlst <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">charlst_nil <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">charlst_cons <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">,</span> <span class="staexp">charlst</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [charlst]</span>
</p></PRE
><P
></P
></DIV
>


When applied to a character and a value of the type <FONT
COLOR="RED"
>charlst</FONT
>,
the constructor <FONT
COLOR="RED"
>charlst_cons</FONT
> forms a value of the type
<FONT
COLOR="RED"
>charlst</FONT
>. As an example, the following value represents a
character list consisting of 'a', 'b' and 'c':

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1023"
></A
><PRE
CLASS="programlisting"
>charlst_cons('a', charlst_cons('b', charlst_cons('c', charlst_nil())))
</PRE
><P
></P
></DIV
>


We can define a function <FONT
COLOR="RED"
>charlst_length</FONT
> as follows to compute
the length of a given character list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1026"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
charlst_length
<span class="keyword">(</span>
  cs<span class="keyword">:</span> <span class="staexp">charlst</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">case</span> cs <span class="keyword">of</span>
  <span class="keyword">|</span> charlst_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
  <span class="keyword">|</span> charlst_cons<span class="keyword">(</span>_<span class="keyword">,</span> cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span> + charlst_length<span class="keyword">(</span>cs<span class="keyword">)</span></span>
<span class="comment">// end of [charlst_length]</span>
</p></PRE
><P
></P
></DIV
>


Note that this implementation is recursive but not tail-recursive. By
relying on the commutativity and associativity of integer addition, we can
give the following implementation of <FONT
COLOR="RED"
>charlst_length</FONT
> that is
tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1029"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
charlst_length
  <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">charlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">charlst</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">case</span> cs <span class="keyword">of</span>
  <span class="keyword">|</span> charlst_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> n <span class="keyword">|</span> charlst_cons <span class="keyword">(</span>_<span class="keyword">,</span> cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop<span class="keyword">(</span>cs<span class="keyword">,</span> n+<span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>cs<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [charlst_length]</span>
</p></PRE
><P
></P
></DIV
>


Note that the naming convention I follow closely in this book (and
elsewhere) mandates that only a tail-recursive function be given a name
indicative of its being a loop. A non-tail-recursive function is not called
a loop because it cannot be translated directly to a loop in an imperative
programming language like C.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="exhaustiveness_of_pattern-matching"
>Exhaustiveness of Pattern-Matching</A
></H2
><P
>&#13;Given a type T and a set of patterns, if for any given value of the type T
there is always at least one pattern in the set such that the value matches
the pattern, then pattern-matching values of the type T against the set of
patterns is exhaustive.  Given a case-expression of the form
(<FONT
COLOR="RED"
>case</FONT
> exp0 <FONT
COLOR="RED"
>of</FONT
> clseq), where exp0 is assumed to be of
some type T, if pattern-matching values of the type T against the guards of
the matching clauses in clseq is exhaustive, then the case-expression is
said to be pattern-matching-exhaustive.
</P
><P
>The following code implements a function that finds the last character
in a non-empty character list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1037"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
charlst_last
  <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">charlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">char</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case</span> cs <span class="keyword">of</span>
  <span class="keyword">|</span> charlst_cons <span class="keyword">(</span>c<span class="keyword">,</span> charlst_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> c
  <span class="keyword">|</span> charlst_cons <span class="keyword">(</span>_<span class="keyword">,</span> cs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> charlst_last <span class="keyword">(</span>cs1<span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">// end of [charlst_last]</span>
</p></PRE
><P
></P
></DIV
>


The body of <FONT
COLOR="RED"
>charlst_last</FONT
> is a case-expression, which is not
pattern-matching-exhaustive: If <FONT
COLOR="RED"
>cs</FONT
> is bound to the value
<FONT
COLOR="RED"
>charlst_nil()</FONT
>, that is, the empty character list, than none of
the matching clauses in the case-expression can be chosen. When the code is
typechecked by atsopt, a warning message is issued to indicate the
case-expression being non-pattern-matching-exhaustive. If the programmer
wants an error message instead, the keyword <FONT
COLOR="RED"
>case</FONT
> should be
replaced with <FONT
COLOR="RED"
>case+</FONT
>.  If the programmer wants to suppress the
warning message, the keyword <FONT
COLOR="RED"
>case</FONT
> should be replaced with
<FONT
COLOR="RED"
>case-</FONT
>. I myself mostly use <FONT
COLOR="RED"
>case+</FONT
> when coding in
ATS.
</P
><P
>&#13;The function <FONT
COLOR="RED"
>charlst_last</FONT
> can also be implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1049"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
charlst_last
  <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">charlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">char</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case</span> cs <span class="keyword">of</span>
  <span class="keyword">|</span> charlst_cons <span class="keyword">(</span>c<span class="keyword">,</span> cs1<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>
      <span class="keyword">case+</span> cs1 <span class="keyword">of</span>
      <span class="keyword">|</span> charlst_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> c <span class="keyword">|</span> charlst_cons _ <span class="keyword">=&gt;</span> charlst_last <span class="keyword">(</span>cs1<span class="keyword">)</span>
    <span class="keyword">)</span> <span class="comment">// end of [charlst_cons]</span>
<span class="keyword">)</span></span> <span class="comment">// end of [charlst_last]</span>
</p></PRE
><P
></P
></DIV
>


In this implementation, the outer case-expression is not
pattern-matching-exhaustive while the inner one is. Note that the pattern
<FONT
COLOR="RED"
>charlst_cons _</FONT
> is just a shorthand for
<FONT
COLOR="RED"
>charlst_cons(_, _)</FONT
>. In general, a pattern of the form
<FONT
COLOR="RED"
>C _</FONT
>, where C is a constructor (associated with some datatype),
can be matched by any value that is constructed by applying C to some
values. For instance, the pattern <FONT
COLOR="RED"
>charlst_nil()</FONT
> can also be
written as <FONT
COLOR="RED"
>charlst_nil _</FONT
>.
</P
><P
>&#13;Suppose we have a case-expression containing only one matching clause, that
is, the case-expression is of the form [<FONT
COLOR="RED"
>case</FONT
> exp0
<FONT
COLOR="RED"
>of</FONT
> pat <FONT
COLOR="RED"
>=&#62;</FONT
> exp].  Then we can also write this
case-expression as a let-expression: (<FONT
COLOR="RED"
>let</FONT
> <FONT
COLOR="RED"
>val</FONT
> pat
<FONT
COLOR="RED"
>=</FONT
> exp0 <FONT
COLOR="RED"
>in</FONT
> exp <FONT
COLOR="RED"
>end</FONT
>). For instance, we
give another implementation of the function <FONT
COLOR="RED"
>charlst_last</FONT
> as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1066"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
charlst_last
  <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">charlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">char</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> charlst_cons <span class="keyword">(</span>c<span class="keyword">,</span> cs1<span class="keyword">)</span> <span class="keyword">=</span> cs</span> <span class="keyword">in</span> <span class="keyword">case+</span> cs1 <span class="keyword">of</span>
  <span class="keyword">|</span> charlst_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> c <span class="keyword">|</span> charlst_cons _ <span class="keyword">=&gt;</span> charlst_last <span class="keyword">(</span>cs1<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [charlst_last]</span>
</p></PRE
><P
></P
></DIV
>


When this implementation is typechecked by atsopt, a warning message is
issued to indicate the val-declaration being
non-pattern-matching-exhaustive. If the programmer wants an error message
instead, the keyword <FONT
COLOR="RED"
>val</FONT
> should be replaced with
<FONT
COLOR="RED"
>val+</FONT
>.  If the programmer wants to suppress the warning message,
the keyword <FONT
COLOR="RED"
>val</FONT
> should be replaced with <FONT
COLOR="RED"
>val-</FONT
>.
</P
><P
>&#13;As values formed by the constructors <FONT
COLOR="RED"
>charlst_nil</FONT
> and
<FONT
COLOR="RED"
>charlst_cons</FONT
> are assigned the same type <FONT
COLOR="RED"
>charlst</FONT
>, it
is impossible to rely on typechecking to prevent the function
<FONT
COLOR="RED"
>charlst_last</FONT
> from being applied to an empty character list.
This is a serious limitation.  With dependent types, which allow data to be
described much more precisely, we can ensure at the level of types that a
function finding the last element of a list can only be applied to a
non-empty list.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_binary_search_tree"
>Example: Binary Search Tree</A
></H2
><P
>&#13;A binary search tree is a binary tree satisfying the following property:
for each node in the tree, the key stored in the node is greater than or
equal to every key stored in the left child of the node and less than or
equal to every key stored in the right child of the node. In other words, a
binary tree is a binary search tree if a pre-order traversal encounters a
sequence of keys ordered ascendingly (according to some ordering on keys). In
practice, binary search trees are commonly employed to represent sets and
maps.

</P
><P
>&#13;The following declaration introduces a datatype <FONT
COLOR="RED"
>bstree</FONT
> for
binary search trees in which the stored keys are strings:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1082"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">bstree <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">E <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp">B <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">bstree</span><span class="keyword">,</span> <span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">bstree</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [bstree]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;It should be noted that not every value of the type <FONT
COLOR="RED"
>bstree</FONT
>
represents a valid binary search tree as it is certainly possible to
construct a value representing a binary tree but not a binary search tree.

</P
><P
>&#13;The following function [bstree_inord] does a in-order traversal of a
given binary tree:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1087"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
bstree_inord
<span class="keyword">(</span>
  t0<span class="keyword">:</span> <span class="staexp">bstree</span><span class="keyword">,</span> fwork<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> t0 <span class="keyword">of</span>
<span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> B <span class="keyword">(</span>t1<span class="keyword">,</span> k<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> bstree_inord <span class="keyword">(</span>t1<span class="keyword">,</span> fwork<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fwork <span class="keyword">(</span>k<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> bstree_inord <span class="keyword">(</span>t2<span class="keyword">,</span> fwork<span class="keyword">)</span></span>
  <span class="keyword">}</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [bstree_inord] *)</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;If [t0] is a binary search tree, then the sequence of
keys processed by [fwork] are ordered ascendingly.

</P
><P
>&#13;Given a binary search tree and a key, the following function
[bstree_search] checks whether the key is stored inside the tree:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1091"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
bstree_search
<span class="keyword">(</span>
  t0<span class="keyword">:</span> <span class="staexp">bstree</span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> t0 <span class="keyword">of</span>
<span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
<span class="keyword">|</span> B <span class="keyword">(</span>t1<span class="keyword">,</span> k<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span> bstree_search <span class="keyword">(</span>t1<span class="keyword">,</span> k0<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span> bstree_search <span class="keyword">(</span>t2<span class="keyword">,</span> k0<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="comment">(*k0 = k*)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">end</span> <span class="comment">// end of [B]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [bstree_search] *)</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that [bstree_search] returns true if the given key is
found. Otherwise, it returns false.

</P
><P
>&#13;Given a binary search tree and a key, the following function
[bstree_insert] inserts the key into the tree:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1095"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
bstree_insert
<span class="keyword">(</span>
  t0<span class="keyword">:</span> <span class="staexp">bstree</span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> t0 <span class="keyword">of</span>
<span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> B <span class="keyword">(</span>E<span class="keyword">,</span> k0<span class="keyword">,</span> E<span class="keyword">)</span>
<span class="keyword">|</span> B <span class="keyword">(</span>t1<span class="keyword">,</span> k<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span> B <span class="keyword">(</span>bstree_insert <span class="keyword">(</span>t1<span class="keyword">,</span> k0<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> t2<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span> B <span class="keyword">(</span>t1<span class="keyword">,</span> k<span class="keyword">,</span> bstree_insert <span class="keyword">(</span>t2<span class="keyword">,</span> k0<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="comment">(*k0 = k*)</span> <span class="keyword">=&gt;</span> t0 <span class="comment">// [k0] found and no actual insertion</span>
  <span class="keyword">end</span> <span class="comment">// end of [B]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [bstree_insert] *)</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that [bstree_insert] inserts the key only if it is not already stored
inside the given tree. Also, if inserted, the key is always stored in a newly
created leaf node.

</P
><P
>&#13;Please find
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATATYPE/bstree.dats"
TARGET="_top"
>on-line</A
>
the entirety of the code in this section plus some additional code for
testing.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_evaluating_integer_expressions"
>Example: Evaluating Integer Expressions</A
></H2
><P
>&#13;For representing integer expressions, we declare a datatype
<FONT
COLOR="RED"
>IEXP</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1104"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">IEXP <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPcst <span class="keyword">of</span> <span class="staexp">int</span></span> <span class="comment">// constants</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPneg <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// negative</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPadd <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// addition</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPsub <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// subtraction</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPmul <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// multiplication</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPdiv <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span></span> <span class="comment">// division</span>
<span class="comment">// end of [IEXP]</span>
</p></PRE
><P
></P
></DIV
>


The meaning of the constructors associated with <FONT
COLOR="RED"
>IEXP</FONT
> should be
obvious. A value of the type <FONT
COLOR="RED"
>IEXP</FONT
> is often referred to as an
abstract syntax tree. For instance, the abstract syntax tree for the
expression (~1+(2-3)*4) is the following one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1108"
></A
><PRE
CLASS="programlisting"
>IEXPadd(IEXPneg(IEXPcst(1)), IEXPmul(IEXPsub(IEXPcst(2), IEXPcst(3)), IEXPcst(4)))
</PRE
><P
></P
></DIV
>


Translating an integer expression written in some string form into an
abstract syntax tree is called parsing, which we will not do here. The
following defined function <FONT
COLOR="RED"
>eval_iexp</FONT
> takes the abstract syntax
tree of an integer expression and returns an integer that is the value of
the expression:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1111"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
eval_iexp
  <span class="keyword">(</span>e0<span class="keyword">:</span> <span class="staexp">IEXP</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> e0 <span class="keyword">of</span>
<span class="keyword">|</span> IEXPcst <span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=&gt;</span> n
<span class="keyword">|</span> IEXPneg <span class="keyword">(</span>e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">~</span>eval_iexp <span class="keyword">(</span>e<span class="keyword">)</span>
<span class="keyword">|</span> IEXPadd <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> + eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPsub <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> - eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPmul <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> * eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPdiv <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> / eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [eval_iexp] *)</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>&#13;Suppose we also allow the construct if-then-else to be use in forming
integer expressions. For instance, we may write an integer expression like
(if 1+2 &#60;= 3*4 then 5+6 else 7-8). Note that the test (1+2 &#60;= 3*4) is a
boolean expression rather than an integer expression. This indicates that
we also need to declare a datatype <FONT
COLOR="RED"
>BEXP</FONT
> for representing
boolean expressions. Furthermore, <FONT
COLOR="RED"
>IEXP</FONT
> and <FONT
COLOR="RED"
>BEXP</FONT
>
should be defined mutually recursively as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1117"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">IEXP <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPcst <span class="keyword">of</span> <span class="staexp">int</span></span> <span class="comment">// integer constants</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPneg <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// negative</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPadd <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// addition</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPsub <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// subtraction</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPmul <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// multiplication</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPdiv <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// division</span>
  <span class="keyword">|</span> <span class="dynexp">IEXPif <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">BEXP</span><span class="comment">(*test*)</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="comment">(*then*)</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="comment">(*else*)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [IEXP]</span>

<span class="keyword">and</span> <span class="staexp">BEXP <span class="keyword">=</span> <span class="comment">// [and] for combining datatype declarations</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPcst <span class="keyword">of</span> <span class="staexp">bool</span></span> <span class="comment">// boolean constants</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPneg <span class="keyword">of</span> <span class="staexp">BEXP</span></span> <span class="comment">// negation</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPconj <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">BEXP</span><span class="keyword">,</span> <span class="staexp">BEXP</span><span class="keyword">)</span></span> <span class="comment">// conjunction</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPdisj <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">BEXP</span><span class="keyword">,</span> <span class="staexp">BEXP</span><span class="keyword">)</span></span> <span class="comment">// disjunction</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPeq <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// equal-to</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPneq <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// not-equal-to</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPlt <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// less-than</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPlte <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// less-than-equal-to</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPgt <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span> <span class="comment">// greater-than</span>
  <span class="keyword">|</span> <span class="dynexp">BEXPgte <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">IEXP</span><span class="keyword">,</span> <span class="staexp">IEXP</span><span class="keyword">)</span></span></span> <span class="comment">// greater-than-equal-to</span>
<span class="comment">// end of [BEXP]</span>
</p></PRE
><P
></P
></DIV
>


Evidently, we also need to evaluate boolean expressions when evaluating
integer expressions. The following two functions <FONT
COLOR="RED"
>eval_iexp</FONT
> and
<FONT
COLOR="RED"
>eval_bexp</FONT
> for evaluating integer and boolean expressions,
respectively, are defined mutually recursively as can be expected:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1121"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
eval_iexp
<span class="keyword">(</span>
  e0<span class="keyword">:</span> <span class="staexp">IEXP</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> e0 <span class="keyword">of</span>
<span class="keyword">|</span> IEXPcst n <span class="keyword">=&gt;</span> n
<span class="keyword">|</span> IEXPneg <span class="keyword">(</span>e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">~</span>eval_iexp <span class="keyword">(</span>e<span class="keyword">)</span>
<span class="keyword">|</span> IEXPadd <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> + eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPsub <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> - eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPmul <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> * eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> IEXPdiv <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> / eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span>
<span class="keyword">|</span> IEXPif
  <span class="keyword">(</span>
    e_test<span class="keyword">,</span> e_then<span class="keyword">,</span> e_else
  <span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    eval_iexp <span class="keyword">(</span><span class="keyword">if</span> eval_bexp <span class="keyword">(</span>e_test<span class="keyword">)</span> <span class="keyword">then</span> e_then <span class="keyword">else</span> e_else<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">// end of [IEXPif]</span>
<span class="comment">//</span>
<span class="keyword">)</span> <span class="comment">(* end of [eval_iexp] *)</span>

<span class="keyword">and</span>
eval_bexp
<span class="keyword">(</span>
  e0<span class="keyword">:</span> <span class="staexp">BEXP</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> e0 <span class="keyword">of</span>
<span class="keyword">|</span> BEXPcst b <span class="keyword">=&gt;</span> b
<span class="keyword">|</span> BEXPneg <span class="keyword">(</span>e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">~</span>eval_bexp <span class="keyword">(</span>e<span class="keyword">)</span>
<span class="keyword">|</span> BEXPconj <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">if</span> eval_bexp <span class="keyword">(</span>e1<span class="keyword">)</span> <span class="keyword">then</span> eval_bexp <span class="keyword">(</span>e2<span class="keyword">)</span> <span class="keyword">else</span> false
<span class="keyword">|</span> BEXPdisj <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">if</span> eval_bexp <span class="keyword">(</span>e1<span class="keyword">)</span> <span class="keyword">then</span> true <span class="keyword">else</span> eval_bexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPeq <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> <span class="keyword">=</span> eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPneq <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> != eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPlt <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> <span class="keyword">&lt;</span> eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPlte <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> &lt;= eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPgt <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> <span class="keyword">&gt;</span> eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="keyword">|</span> BEXPgte <span class="keyword">(</span>e1<span class="keyword">,</span> e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval_iexp <span class="keyword">(</span>e1<span class="keyword">)</span> &gt;= eval_iexp <span class="keyword">(</span>e2<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [eval_bexp] *)</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>&#13;The integer and boolean expressions used in this example are all constant
expressions containing no variables. Therefore, there is no need for an
environment to evaluate them. I will present a more advanced example
elsewhere to demonstrate how an evaluator for a simple call-by-value
functional programming language like the core of ATS can be implemented.
</P
><P
>&#13;Please find
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATATYPE/intexp.dats"
TARGET="_top"
>on-line</A
>
the entirety of the code in this section plus some additional code for
testing.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="parametric_polymorphism"
></A
>Chapter 5. Parametric Polymorphism</H1
><P
>&#13;Code sharing is of paramount importance in programming.  In a typed
programming language, we often encounter a situation where the same
functionality is needed for values of different types. For instance, we may
need to compute the length of a list while the elements in the list can be
characters, integers, strings, etc. Evidently, we want to avoid
implementing a list-length function for each element type as it would
probably be the worst form of code duplication. We want to implement one
single function that can be applied to any list to compute the length of
the list. This list-length function parameterizes over the element type of
a given list, and it behaves uniformly regardless what the element type is.
This is a form of code sharing that is often referred to as
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>parametric polymorphism</I
></SPAN
>, which should be distinguished from
other forms of polymorphism such as inheritance polymorphism in
object-oriented programming.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_POLYMORPH"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="function_templates"
>Function Templates</A
></H2
><P
>&#13;A function template is a code template that implements a function.
In the following code, two functions are defined to swap values:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1135"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">charint <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span></span>
<span class="keyword">typedef</span> <span class="staexp">intchar <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">char</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> swap_char_int <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">charint</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intchar</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> swap_int_char <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">intchar</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charint</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


If types are ignored, the bodies of <FONT
COLOR="RED"
>swap_char_int</FONT
> and
<FONT
COLOR="RED"
>swap_int_char</FONT
> are identical. In order to avoid this kind of
code duplication, we can first implement a function template
<FONT
COLOR="RED"
>swap</FONT
> as follows and then implement <FONT
COLOR="RED"
>swap_char_int</FONT
>
and <FONT
COLOR="RED"
>swap_int_char</FONT
> based on <FONT
COLOR="RED"
>swap</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1143"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> swap <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> swap_char_int <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">charint</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intchar</span> <span class="keyword">=</span> swap&lt;<span class="staexp">char</span><span class="keyword">,</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xy<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> swap_int_char <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">intchar</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charint</span> <span class="keyword">=</span> swap&lt;<span class="staexp">int</span><span class="keyword">,</span><span class="staexp">char</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xy<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


It should be noted that a function template is not a first-class value in
ATS: There is no expression for representing a function template.  The
syntax <FONT
COLOR="RED"
>{a,b:t@ype}</FONT
> following the keyword <FONT
COLOR="RED"
>fun</FONT
>
represents template parameters or arguments. The unusual symbol
<FONT
COLOR="RED"
>t@ype</FONT
> is a sort for static terms representing types of
unspecified size, where the size of a type is the number of bytes needed
for representing a value of the type (under the assumption that all of the
values of the type have the same size).  There is another sort
<FONT
COLOR="RED"
>type</FONT
> in ATS, which is for static terms representing types of
size equal to one word exactly, that is, 4 bytes on a 32-bit machine or 8
bytes on a 64-bit machine.  The syntax <FONT
COLOR="RED"
>swap&#60;char,int&#62;</FONT
>,
where no space is allowed between <FONT
COLOR="RED"
>swap</FONT
> and <FONT
COLOR="RED"
>&#60;</FONT
> ,
stands for an instance of the function template <FONT
COLOR="RED"
>swap</FONT
> in which
the parameters <FONT
COLOR="RED"
>a</FONT
> and <FONT
COLOR="RED"
>b</FONT
> are replaced with
<FONT
COLOR="RED"
>char</FONT
> and <FONT
COLOR="RED"
>int</FONT
>, respectively.  The syntax
<FONT
COLOR="RED"
>swap&#60;int,char&#62;</FONT
> is interpreted similarly.
</P
><P
>&#13;A different style of implementation of <FONT
COLOR="RED"
>swap</FONT
> is given
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1160"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> swap2 <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where the template parameters are given sequentially (instead of
simultaneously). The following code shows how <FONT
COLOR="RED"
>swap2</FONT
> can be
instantiated to form instances:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1163"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> swap_char_int <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">charint</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intchar</span> <span class="keyword">=</span> swap2&lt;<span class="staexp">char</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xy<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> swap_int_char <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="staexp">intchar</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charint</span> <span class="keyword">=</span> swap2&lt;<span class="staexp">int</span><span class="keyword">&gt;&lt;</span><span class="staexp">char</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xy<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>&#62;&#60;</FONT
> is a special symbol (of the name GTLT) and
no space is allowed between <FONT
COLOR="RED"
>&#62;</FONT
> and <FONT
COLOR="RED"
>&#60;</FONT
>.
</P
><P
>&#13;As another example, a higher-order function template for composing
(closure) functions is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1169"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">cfun <span class="keyword">(</span><span class="staexp">t1<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">t2<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">t1</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">t2</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">,</span>c<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> compose <span class="keyword">(</span>
  f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> g<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">lam</span> x <span class="keyword">=&gt;</span> g<span class="keyword">(</span>f<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> inc_by_1 <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> x+<span class="dynexp">1</span></span>
<span class="dynexp"><span class="keyword">val</span> mul_by_2 <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> x*<span class="dynexp">2</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> f_2x_1 <span class="keyword">=</span> compose&lt;<span class="staexp">int</span><span class="keyword">,</span><span class="staexp">int</span><span class="keyword">,</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>mul_by_2<span class="keyword">,</span> inc_by_1<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> f_2x_2 <span class="keyword">=</span> compose&lt;<span class="staexp">int</span><span class="keyword">,</span><span class="staexp">int</span><span class="keyword">,</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>inc_by_1<span class="keyword">,</span> mul_by_2<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


It should be clear that the value <FONT
COLOR="RED"
>f_2x_1</FONT
> represents the
function that multiplies its integer argument by 2 and then adds 1 to the
result. Similarly, the value <FONT
COLOR="RED"
>f_2x_2</FONT
> represents the function
that adds 1 to its integer argument and then multiplies the result by 2.
</P
><P
>&#13;In ATS, function templates are typechecked but not compiled to code in C.
Instead, they are compiled to an intermediate form.  Only instances of
function templates are compiled to code in C. Suppose we have a function
template <FONT
COLOR="RED"
>foo</FONT
> taking one type parameter and two instances
foo&#60;T1&#62; and foo&#60;T2&#62; are used in a program for some types T1 and
T2. In general, one function in C is generated for each instance of foo
when the program is compiled. However, if T1 and T2 have the same name,
then the two instances may share one function in C.
</P
><P
>&#13;Please note that I may simply use the name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>function</I
></SPAN
> to refer
to a function template from now on if no confusion is expected.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="polymorphic_functions"
>Polymorphic Functions</A
></H2
><P
>&#13;A polymorphic function is rather similar to a function template.
However, the former is a first-class value in ATS while the latter is not.
As an example, the following defined function <FONT
COLOR="RED"
>swap_boxed</FONT
> is
polymorphic:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1181"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> swap_boxed<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The type variables <FONT
COLOR="RED"
>a</FONT
> and <FONT
COLOR="RED"
>b</FONT
> are often referred as
static arguments while <FONT
COLOR="RED"
>xy</FONT
> is a dynamic argument. For example,
the following code makes use of the polymorphic function <FONT
COLOR="RED"
>swap_boxed</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1187"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> AB <span class="keyword">=</span> <span class="keyword">(</span>box<span class="keyword">(</span><span class="dynstr">"A"</span><span class="keyword">)</span><span class="keyword">,</span> box<span class="keyword">(</span><span class="dynstr">"B"</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> BA1 <span class="keyword">=</span> swap_boxed<span class="staexp"><span class="keyword">{</span>boxstr<span class="keyword">,</span>boxstr<span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> BA2 <span class="keyword">=</span> swap_boxed <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// omitting type arguments may be fine</span>
</p></PRE
><P
></P
></DIV
>


where the type <FONT
COLOR="RED"
>boxstr</FONT
> is an explicitly boxed version of
<FONT
COLOR="RED"
>string</FONT
> that is defined as <FONT
COLOR="RED"
>boxed(string)</FONT
>.
Internally, there is really no difference between <FONT
COLOR="RED"
>string</FONT
> and
<FONT
COLOR="RED"
>boxed(string)</FONT
>.  If <FONT
COLOR="RED"
>swap_boxed</FONT
> is called on a pair
of the type (T1, T2) for some types T1 and T2, both T1 and T2 are required
to be boxed. Otherwise, a type-error is reported. For example, calling
<FONT
COLOR="RED"
>swap_boxed</FONT
> on <FONT
COLOR="RED"
>(0, 1)</FONT
> yields a type-error as the
type <FONT
COLOR="RED"
>int</FONT
> is not boxed. One may be attempted to form a boxed
integer like <FONT
COLOR="RED"
>box(0)</FONT
>, but doing so leads to a type-error as
there is no assumption made about the size of an integer value of the type
<FONT
COLOR="RED"
>int</FONT
> in ATS.

</P
><P
>&#13;When calling a polymorphic function, we often omit passing static
arguments explicitly and expect them to be synthesized by the
compiler. However, there are also occasions, which are not uncommon, where
static arguments need to be supplied explicitly as either they cannot be
successfully synthesized or what is synthesized is not exactly what is
expected by the programmer.
</P
><P
>&#13;It is also possible to pass static arguments sequentially as is
shown in the following style of implementation of a polymorphic function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1202"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> swap2_boxed<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> AB <span class="keyword">=</span> <span class="keyword">(</span>box<span class="keyword">(</span><span class="dynstr">"A"</span><span class="keyword">)</span><span class="keyword">,</span> box<span class="keyword">(</span><span class="dynstr">"B"</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> BA1 <span class="keyword">=</span> swap2_boxed <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// both static arguments to be synthesized</span>
<span class="dynexp"><span class="keyword">val</span> BA2 <span class="keyword">=</span> swap2_boxed<span class="staexp"><span class="keyword">{</span><span class="keyword">...</span><span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// both static arguments to be synthesized</span>
<span class="dynexp"><span class="keyword">val</span> BA3 <span class="keyword">=</span> swap2_boxed<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>boxstr<span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// 1st static argument to be synthesized</span>
<span class="dynexp"><span class="keyword">val</span> BA4 <span class="keyword">=</span> swap2_boxed<span class="staexp"><span class="keyword">{</span>boxstr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// 2nd static argument to be synthesized</span>
<span class="dynexp"><span class="keyword">val</span> BA5 <span class="keyword">=</span> swap2_boxed<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// both static arguments to be synthesized</span>
<span class="dynexp"><span class="keyword">val</span> BA6 <span class="keyword">=</span> swap2_boxed<span class="staexp"><span class="keyword">{</span>boxstr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>boxstr<span class="keyword">}</span></span> <span class="keyword">(</span>AB<span class="keyword">)</span></span> <span class="comment">// both static arguments are provided</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The special syntax <FONT
COLOR="RED"
>{..}</FONT
> indicates to the typechecker that the
static argument (or arguments) involved in the current application should
be synthesized while the special syntax <FONT
COLOR="RED"
>{...}</FONT
> means that the
rest of static arguments should all be synthesized.
</P
><P
>&#13;I have seen two kinds of errors involving polymorphic functions that are
extremely common in practice.

<P
></P
><UL
><LI
><P
>The first kind is depicted in the following example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1210"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> swap_boxed<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Notice that the sort for type variables <FONT
COLOR="RED"
>a</FONT
> and <FONT
COLOR="RED"
>b</FONT
> is
<FONT
COLOR="RED"
>t@ype</FONT
> (instead of <FONT
COLOR="RED"
>type</FONT
>). While this example can
pass typechecking, its compilation results in a compile-time error that may
seem mysterious to many programmers. The simple reason for this error is
that the compiler cannot figure out the size of <FONT
COLOR="RED"
>a</FONT
> and
<FONT
COLOR="RED"
>b</FONT
> when trying to generate code in C as the sort <FONT
COLOR="RED"
>t@ype</FONT
>
is for types of unspecified size.

</P
></LI
><LI
><P
>The second kind is depicted in the following example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1221"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span>type<span class="keyword">}</span></span> swap_boxed <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Strictly speaking, there is really no error in this case. If defined as
such, <FONT
COLOR="RED"
>swap_boxed</FONT
> is a function template instead of a
polymorphic function. However, such a function template is severely
restricted as it cannot be instantiated with types that are not boxed.
While this could be intended, it is very unlikely.
</P
></LI
></UL
>

Given the potential confusion, why do we need both function templates and
polymorphic functions?  At this stage, it is certainly plausible that we
program only with function templates and make no use of polymorphic
functions. However, polymorphic functions simply become indispensible in
the presence dependent types. There will actually be numerous occasions
where we encounter polymorphic function templates, that is, templates for
polymorphic functions.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="polymorphic_datatypes"
>Polymorphic Datatypes</A
></H2
><P
>&#13;Code sharing also applies to datatype declarations. For instance, a
commonly used polymorphic datatype <FONT
COLOR="RED"
>list0</FONT
> is declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1228"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">list0 <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">list0_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp">list0_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [list0]</span>
</p></PRE
><P
></P
></DIV
>


More precisely, <FONT
COLOR="RED"
>list0</FONT
> is a type constructor. Given a type T, we
can form a type <FONT
COLOR="RED"
>list0(T)</FONT
> for lists consisting of elements of
the type T. For instance, <FONT
COLOR="RED"
>list0(char)</FONT
> is for character lists,
<FONT
COLOR="RED"
>list0(int)</FONT
> for integer lists, <FONT
COLOR="RED"
>list0(list0(int))</FONT
> for lists
whose elements are themselves integer lists, etc.  To a great extent, the
need for function templates or polymorphic functions largely stems from the
availability of polymorphic datatypes. As an example, a function template
<FONT
COLOR="RED"
>list0_length</FONT
> is implemented as follows for computing the length
of any given list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1236"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_length
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>_<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span> + list0_length&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_length] *)</span>
</p></PRE
><P
></P
></DIV
>


When applying <FONT
COLOR="RED"
>list0_length</FONT
> to a list xs, we can in general
write <FONT
COLOR="RED"
>list0_length(xs)</FONT
>, expecting the typechecker to synthesize
a proper type parameter for <FONT
COLOR="RED"
>list0_length</FONT
>.  We may also write
<FONT
COLOR="RED"
>list0_length&#60;</FONT
><FONT
COLOR="RED"
>T</FONT
><FONT
COLOR="RED"
>&#62;(xs)</FONT
> if the
elements of xs are of the type T. The latter style, though a bit more
verbose, is likely to yield more informative messages in case type-errors
occur.

</P
><P
>&#13;Another commonly used polymorphic datatype <FONT
COLOR="RED"
>option0</FONT
> is declared as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1246"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">option0 <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">option0_none <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp">option0_some <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">a</span></span></span>
<span class="comment">// end of [option0]</span>
</p></PRE
><P
></P
></DIV
>


A typical use of <FONT
COLOR="RED"
>option0</FONT
> is to perform some kind of
error-handling. Suppose that we are to implement a function doing integer
division and we want to make sure that the function returns even if it is
called in a case where the divisor equals 0. This can be done as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1249"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> divopt
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">option0</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> y != <span class="dynexp">0</span> <span class="keyword">then</span> option0_some<span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span><span class="keyword">(</span>x/y<span class="keyword">)</span> <span class="keyword">else</span> option0_none<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
<span class="comment">// end of [divopt]</span>
</p></PRE
><P
></P
></DIV
>


By inspecting what <FONT
COLOR="RED"
>divopt</FONT
> returns, we can tell whether integer
division has been done normally or an error of divsion-by-zero has
occurred. A realistic use of <FONT
COLOR="RED"
>option0</FONT
> is shown in the following
implementation of <FONT
COLOR="RED"
>list0_last</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1254"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list0_last
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">option0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> x <span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> option0_none<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> option0_some<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>loop <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_last]</span>
</p></PRE
><P
></P
></DIV
>


When applied to a list, <FONT
COLOR="RED"
>list0_last</FONT
> returns an optional
value. If the value matches the pattern <FONT
COLOR="RED"
>option0_none()</FONT
>, then
the list is empty. Otherwise, the value is formed by applying
<FONT
COLOR="RED"
>option0_some</FONT
> to the last element of the given list.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_function_templates_on_lists"
>Example: Function Templates on Lists</A
></H2
><P
>&#13;In functional programming, lists are ubiquitous. We implement as follows
some commonly used function templates on lists. It should be noted that
these templates are all available in some library of ATS, where they may be
implemented in a significantly more efficient manner due to the use of
certain programming features (such as linear datatypes) that have not been
covered so far.
</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_POLYMORPH/listfuns.dats"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_append"
>Appending: <FONT
COLOR="RED"
>list0_append</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_append(xs, ys)</FONT
> returns a list that is the concatenation
of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1270"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_append
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    list0_cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> list0_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [list0_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_append] *)</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_append</FONT
> is not
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_reverse_append"
>Reverse-Appending: <FONT
COLOR="RED"
>list0_reverse_append</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_reverse_append(xs, ys)</FONT
> returns a list that is the
concatenation of the reverse of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1279"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_reverse_append
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    list0_reverse_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> list0_cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [list0_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_reverse_append] *)</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_reverse_append</FONT
> is
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_reverse"
>Reversing: <FONT
COLOR="RED"
>list0_reverse</FONT
></A
></H3
><P
>&#13;Given a list xs, <FONT
COLOR="RED"
>list0_reverse(xs)</FONT
> returns the
reverse of xs:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1287"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_reverse
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span> list0_reverse_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> list0_nil<span class="keyword">)</span></span>
<span class="comment">// end of [list0_reverse]</span>
</p></PRE
><P
></P
></DIV
>

</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_map"
>Mapping: <FONT
COLOR="RED"
>list0_map</FONT
></A
></H3
><P
>&#13;Given a list xs of the type <FONT
COLOR="RED"
>list0(T1)</FONT
> for some type T1 and a
closure function <FONT
COLOR="RED"
>f0</FONT
> of the type T1 -&#60;cloref1&#62; T2 for some type T2,
<FONT
COLOR="RED"
>list0_map(xs, f0)</FONT
> returns a list ys of the type <FONT
COLOR="RED"
>list0(T2)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1297"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_map
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> f0<span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">b</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">b</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_cons<span class="staexp"><span class="keyword">{</span>b<span class="keyword">}</span></span><span class="keyword">(</span>f0<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> list0_map&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> f0<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_map] *)</span>
</p></PRE
><P
></P
></DIV
>


The length of ys equals that of xs and each element y in ys equals f0(x),
where x is the corresponding element in xs.  Clearly, this implementation
of <FONT
COLOR="RED"
>list0_map</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_foldleft"
>Left-Folding: <FONT
COLOR="RED"
>list0_foldleft</FONT
></A
></H3
><P
>&#13;Given xs, ini and f0, <FONT
COLOR="RED"
>list0_foldleft(ini, xs, f0)</FONT
> computes the
value of the expression f0(... f0(f0(ini, xs[0]), xs[1]) ..., xs[n-1]), where
n is the length of xs and xs[i] refers to element i in xs for each i &#60; n.
The following implementation of <FONT
COLOR="RED"
>list0_foldleft</FONT
> is tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1306"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_foldleft
<span class="keyword">(</span>
  ini<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">,</span> xs0<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> f0<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs0 <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ini
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_foldleft&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>f0<span class="keyword">(</span>ini<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">,</span> f0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_foldleft] *)</span>
</p></PRE
><P
></P
></DIV
>


</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_foldright"
>Right-Folding: <FONT
COLOR="RED"
>list0_foldright</FONT
></A
></H3
><P
>&#13;Given xs, res and f0, <FONT
COLOR="RED"
>list0_foldright(xs, res, f0)</FONT
> computes the
value of the expression f0(xs[0], f0(xs[1], f0(... f0(xs[n-1], res) ...))), where
n is the length of xs and xs[i] refers to element i in xs for each i &#60; n.
The following implementation of <FONT
COLOR="RED"
>list0_foldright</FONT
> is not tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1314"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_foldright
<span class="keyword">(</span>
  xs0<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">b</span><span class="keyword">,</span> f0<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">b</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">b</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs0 <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  f0<span class="keyword">(</span>x<span class="keyword">,</span> list0_foldright&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> res<span class="keyword">,</span> f0<span class="keyword">)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_zip"
>Zipping: <FONT
COLOR="RED"
>list0_zip</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
>
and <FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively,
<FONT
COLOR="RED"
>list0_zip(xs, ys)</FONT
> returns a list zs of the type
<FONT
COLOR="RED"
>list0(@(T1, T2))</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1324"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list0_zip
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span>
ys<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">@(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
  <span class="keyword">typedef</span> <span class="staexp">ab <span class="keyword">=</span> <span class="keyword">@(</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span> <span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
<span class="keyword">|</span> <span class="keyword">(</span>list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span>
   list0_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    list0_cons<span class="staexp"><span class="keyword">{</span>ab<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list0_zip&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">(* (cons,cons) *)</span>
<span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_zip]</span>
</p></PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs equals @(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list0_zip</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list0_zipwith"
>Zipping with: <FONT
COLOR="RED"
>list0_zipwith</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
> and
<FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&#60;cloref1&#62; T3 for some type T3,
<FONT
COLOR="RED"
>list0_zipwith(xs, ys, f0)</FONT
> returns a list zs of the type
<FONT
COLOR="RED"
>list0(T3)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1335"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>
 b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_zipwith
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span>
<span class="keyword">,</span> f0<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">c</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
<span class="keyword">|</span> <span class="keyword">(</span>list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span>
   list0_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    list0_cons<span class="staexp"><span class="keyword">{</span>c<span class="keyword">}</span></span><span class="keyword">(</span>f0<span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list0_zipwith&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;&lt;</span><span class="staexp">c</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> f0<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list0_zipwith] *)</span>
</p></PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f0(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list0_zipwith</FONT
> is not tail-recursive.  Note that
<FONT
COLOR="RED"
>list0_zipwith</FONT
> behaves exactly like <FONT
COLOR="RED"
>list0_zip</FONT
>
if its third argument <FONT
COLOR="RED"
>f0</FONT
> is replaced with <FONT
COLOR="RED"
>lam
(x, y) =&#62; @(x, y)</FONT
>.  This function template is also given the name
<FONT
COLOR="RED"
>list0_map2</FONT
> for the obvious reason.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_mergesort"
>Example: Mergesort on Lists</A
></H2
><P
>&#13;Mergesort is a simple sorting algorithm that is guaranteed to be
log-linear.  It is stable in the sense that the order of two equal elements
always stay the same after sorting. I give as follows a typical functional
style of implementation of mergesort on lists.

</P
><P
>&#13;First, let us introduce abbreviations
for the list constructors <FONT
COLOR="RED"
>list0_nil</FONT
> and <FONT
COLOR="RED"
>list0_cons</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1349"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="neuexp"><span class="keyword">#define</span> :: list0_cons</span> <span class="comment">// writing [::] for list0_cons</span>
<span class="neuexp"><span class="keyword">#define</span> cons0 list0_cons</span> <span class="comment">// writing [cons0] for list0_cons</span>
<span class="neuexp"><span class="keyword">#define</span> nil0 list0_nil</span> <span class="comment">// writing [nil0] for list0_nil</span>
</p></PRE
><P
></P
></DIV
>


Note that the operator <FONT
COLOR="RED"
>::</FONT
> is already given the infix status.
For instance, the list consisting of the first 5 natural numbers can be
constructed as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1352"
></A
><PRE
CLASS="programlisting"
>cons0(0, cons0(1, 2 :: 3 :: 4 :: nil0((*void*))))
</PRE
><P
></P
></DIV
>


In practice, there is of course no point in mixing <FONT
COLOR="RED"
>cons0</FONT
>
with <FONT
COLOR="RED"
>::</FONT
>.

</P
><P
>&#13;We next implement a function template <FONT
COLOR="RED"
>merge</FONT
> to merge two given
ordered lists into a single ordered one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1358"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">lte <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">bool</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> merge <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> cons0 <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> ys <span class="keyword">of</span>
    <span class="keyword">|</span> cons0 <span class="keyword">(</span>y<span class="keyword">,</span> ys1<span class="keyword">)</span> <span class="keyword">=&gt;</span>
        <span class="keyword">if</span> x lte y <span class="keyword">then</span>
          cons0<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> ys<span class="keyword">,</span> lte<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">else</span>
          cons0<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>y<span class="keyword">,</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys1<span class="keyword">,</span> lte<span class="keyword">)</span><span class="keyword">)</span>
        <span class="comment">// end of [if]</span>
    <span class="keyword">|</span> nil0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs
    <span class="keyword">)</span> <span class="comment">// end of [cons0]</span>
  <span class="keyword">|</span> nil0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
<span class="keyword">)</span></span> <span class="comment">(* end of [merge] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For instance, suppose that the two given lists are (1, 3, 4, 8) and (2, 5,
6, 7, 9), and the comparison function (the third argument of
<FONT
COLOR="RED"
>merge</FONT
>) is the standard less-than-or-equal-to function on
integers. Then the list returned by <FONT
COLOR="RED"
>merge</FONT
> is (1, 2, 3, 4, 5, 6,
7, 8, 9). The syntax <FONT
COLOR="RED"
>lte</FONT
> means that the particular occurrence
of <FONT
COLOR="RED"
>lte</FONT
> following the backslash symbol (<FONT
COLOR="RED"
>\</FONT
>) is
given the infix status, and thus the expression <FONT
COLOR="RED"
>x \lte y</FONT
>
means the same as <FONT
COLOR="RED"
>lte(x, y)</FONT
>.
</P
><P
>&#13;The following function template <FONT
COLOR="RED"
>mergesort</FONT
> implements the
standard mergesort algorithm:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1369"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> mergesort
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> n <span class="keyword">=</span> list0_length&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> msort
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">2</span> <span class="keyword">then</span> split<span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">,</span> lte<span class="keyword">,</span> n/<span class="dynexp">2</span><span class="keyword">,</span> nil0<span class="keyword">)</span> <span class="keyword">else</span> xs
<span class="comment">//</span>
<span class="keyword">and</span> split
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> xsf<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val-</span>cons0 <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
  <span class="keyword">in</span>
    split <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">,</span> lte<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">,</span> cons0<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> xsf<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> xsf <span class="keyword">=</span> list0_reverse&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xsf<span class="keyword">)</span></span> <span class="comment">// make sorting stable!</span>
    <span class="dynexp"><span class="keyword">val</span> xsf <span class="keyword">=</span> msort <span class="keyword">(</span>xsf<span class="keyword">,</span> n/<span class="dynexp">2</span><span class="keyword">,</span> lte<span class="keyword">)</span> <span class="keyword">and</span> xs <span class="keyword">=</span> msort <span class="keyword">(</span>xs<span class="keyword">,</span> n-n/<span class="dynexp">2</span><span class="keyword">,</span> lte<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xsf<span class="keyword">,</span> xs<span class="keyword">,</span> lte<span class="keyword">)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  msort <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">,</span> lte<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mergesort]</span>
</p></PRE
><P
></P
></DIV
>


Suppose we want to sort the list (8, 3, 4, 1, 2, 7, 6, 5, 9); we first
divide it into two lists: (8, 3, 4, 1) and (2, 7, 6, 5, 9); by performing
mergesort on each of them, we obtain two ordered lists: (1, 3, 4, 8) and
(2, 5, 6, 7, 9); by merging these two ordered list, we obtain the ordered
list (1, 2, 3, 4, 5, 6, 7, 8, 9), which is a permutation of the originally
given list (8, 3, 4, 1, 2, 7, 6, 5, 9).
</P
><P
>&#13;Note that the function template <FONT
COLOR="RED"
>merge</FONT
> is not tail-recursive as
the call to <FONT
COLOR="RED"
>merge</FONT
> in its body is not a tail-call. This can be a
serious problem in practice: It is almost certain that a stack overflow is
to occur if the above implementation of mergesort is employed to sort a
list that is very long (e.g., containing 1,000,000 elements or more). I
will later give a tail-recursive implementation of the <FONT
COLOR="RED"
>merge</FONT
>
function in ATS that makes use of linear types.  </P
><P
>&#13;Please find the entire code in this section plus some additional code for
testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_POLYMORPH/mergesort.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="support-for-practical-programming"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
>II. Support for Practical Programming</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>6. <A
HREF="#effecftul_programming_features"
>Effectful Programming Features</A
></DT
><DT
>7. <A
HREF="#modularity"
>Modularity</A
></DT
><DT
>8. <A
HREF="#Cinteraction"
>Interaction with C</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="effecftul_programming_features"
></A
>Chapter 6. Effectful Programming Features</H1
><P
>&#13;Effectful programming features are those that can generate effects at
run-time. But what is really an effect? The answer to this question is
rather complex as it depends on the model of evaluation. I will gradually
introduce various kinds of effects in this book. In sequential programming,
that is, constructing programs to be evaluated sequentially (in contrast to
concurrently), an expression is effectless if there exists a value such
that the expression and the value cannot be distinguished as far as
evaluation is concerned. For instance, the expression <FONT
COLOR="RED"
>1+2</FONT
> is
effectless as it cannot be distinguished from the value <FONT
COLOR="RED"
>3</FONT
>. An
effectless expression is also said to be pure.  On the other hand, an
effectful expression is one that can be distinguished from any given
values. For instance, the expression <FONT
COLOR="RED"
>print("Hello")</FONT
> is
effectful as its evaluation results in an observable behavior that
distinguishes the expression from any values.  In this case,
<FONT
COLOR="RED"
>print("Hello")</FONT
> is said to certain I/O effect.  If the
evaluation of an expression never terminates, then the expression is also
effectul. For instance, let us define a function <FONT
COLOR="RED"
>loop</FONT
> as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1387"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> loop<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> loop<span class="keyword">(</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Then the expression <FONT
COLOR="RED"
>loop()</FONT
> can be distinguished from
any values in the following context:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1390"
></A
><PRE
CLASS="programlisting"
>let val _ = [] in print("Terminated") end</PRE
><P
></P
></DIV
>


If the hole <FONT
COLOR="RED"
>[]</FONT
> in the context is replaced with
<FONT
COLOR="RED"
>loop()</FONT
>, then the evaluation of the resulting expression
continues forever.  If the hole <FONT
COLOR="RED"
>[]</FONT
> is replaced with any value,
then the evaluation leads to the string "Terminated" being printed out.
The expression <FONT
COLOR="RED"
>loop</FONT
> is said to contain non-termination effect.
</P
><P
>&#13;I will cover programming features related to exceptional control-flow,
persistent memory storage and simple I/O in this chapter, which are all of
common use in practical programming.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_EFFECTFUL/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="exceptions"
>Exceptions</A
></H2
><P
>&#13;The exception mechanism provides an efficient means for reporting a special
condition encountered during program evaluation. Often such a special
condition indicates an error, but it is not uncommon to employ exceptions
to address issues that are not related to errors.
</P
><P
>&#13;The type <FONT
COLOR="RED"
>exn</FONT
> is predefined in ATS. One may think of
<FONT
COLOR="RED"
>exn</FONT
> as an extensible datatype for which new constructors can
always be declared. For instance, two exception constructors are declared
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1405"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">exception</span> <span class="dynexp">FatalError0 <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="keyword">exception</span> <span class="dynexp">FatalError1 <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The constructor <FONT
COLOR="RED"
>FatalError0</FONT
> is nullary while the constructor
<FONT
COLOR="RED"
>FatalError1</FONT
> is unary.  Exception values, that is, values of
the type <FONT
COLOR="RED"
>exn</FONT
> can be formed by applying exception constructors
to proper arguments. For instance, <FONT
COLOR="RED"
>FatalError0()</FONT
> and
<FONT
COLOR="RED"
>FatalError1("division-by-zero")</FONT
> are two exception values (or
simply exceptions). In the following program, a function for integer
division is implemented:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1412"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">exception</span> <span class="dynexp">DivisionByZero <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> divexn<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> y != <span class="dynexp">0</span> <span class="keyword">then</span> x / y <span class="keyword">else</span> <span class="dynexp"><span class="keyword">$raise</span> DivisionByZero<span class="keyword">(</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [divexn]</span>
</p></PRE
><P
></P
></DIV
>


When the function call <FONT
COLOR="RED"
>divexn(1, 0)</FONT
> is evaluated, the exception
<FONT
COLOR="RED"
>DivisionByZero()</FONT
> is raised. The keyword <FONT
COLOR="RED"
>$raise</FONT
> in ATS
is solely for raising exceptions.
</P
><P
>&#13;A raise-expression is of the form (<FONT
COLOR="RED"
>$raise</FONT
> exp) for some
expression exp.  Clearly, if the evaluation of exp returns a value, then
the evaluation of (<FONT
COLOR="RED"
>$raise</FONT
> exp) leads to a raised
exception. Therefore, the evaluation of a raise-expression can never return
a value, and this justifies that a raise-expression can be given any type.
</P
><P
>&#13;A raised exception can be captured. If it is not captured, the raised
exception aborts the program evaluation that issued it in the first
place. In ATS, a try-expression (or try-with-expression) is of the form
(<FONT
COLOR="RED"
>try</FONT
> exp <FONT
COLOR="RED"
>with</FONT
> clseq), where <FONT
COLOR="RED"
>try</FONT
> is a
keyword, exp is an expression, <FONT
COLOR="RED"
>with</FONT
> is also a keyword, and
clseq is a sequence of matching clauses. When evaluating such a
try-expression, we first evaluate exp. If the evaluation of exp leads to a
value, then the value is also the value of the try-expression. If the
evaluation of exp leads to a raised exception, then we match the exception
against the guards of the matching clauses in clseq. If there is a match,
the raised exception is caught and we continue to evaluate the body of the
first clause whose guard is matched. If there is no match, the raised
exception is uncaught. In a try-expression, the with-part is often referred
to as an exception-handler.
</P
><P
>Let us now see an example that involves raising and capturing an
exception. In the following program, three functions are defined to compute
the product of the integers in a given list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1426"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> listprod1
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span>
  <span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> x * listprod1<span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [listprod1] *)</span>

<span class="dynexp"><span class="keyword">fun</span> listprod2
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span>
  <span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      <span class="keyword">if</span> x <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="dynexp">0</span> <span class="keyword">else</span> x * listprod2<span class="keyword">(</span>xs<span class="keyword">)</span>
    <span class="comment">// end of [list0_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [listprod2] *)</span>

<span class="dynexp"><span class="keyword">fun</span> listprod3
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">exception</span> <span class="dynexp">ZERO <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">fun</span> aux<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span>
    <span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
        <span class="keyword">if</span> x <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="dynexp"><span class="keyword">$raise</span> ZERO<span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">else</span> x * aux<span class="keyword">(</span>xs<span class="keyword">)</span></span>
      <span class="comment">// end of [list0_cons]</span>
  <span class="comment">// end of [aux]</span>
<span class="keyword">in</span>
  <span class="dynexp"><span class="keyword">try</span> aux<span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">with</span> <span class="keyword">~</span>ZERO<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0</span>
<span class="keyword">end</span></span> <span class="comment">// end of [listprod3]</span>
</p></PRE
><P
></P
></DIV
>


While these functions can all be defined tail-recursively, they are not so
as to make a point that should be clear shortly. Undoubtedly, we all know the
following simple fact:

<P
></P
><UL
><LI
><P
>If the integer 0 occurs in a given list, then the product
of the integers in the list is 0 regardless what other integers are.
</P
></LI
></UL
>

The function <FONT
COLOR="RED"
>listprod1</FONT
> is defined in a standard manner, and it
does not make any use of the stated fact.  The function
<FONT
COLOR="RED"
>listprod2</FONT
> is defined in a manner that makes only partial use of
the stated fact. To see the reason, let us evaluate a call to
<FONT
COLOR="RED"
>listprod2</FONT
> on <FONT
COLOR="RED"
>[1, 2, 3, 0, 4, 5, 6]</FONT
>, which denotes a
list consisting of the 7 mentioned integers. The evaluation of this call
eventually leads to the evaluation of
<FONT
COLOR="RED"
>1*(2*(3*(listprod([0,4,5,6]))))</FONT
>, which then leads to
<FONT
COLOR="RED"
>1*(2*(3*0))</FONT
>, and then to <FONT
COLOR="RED"
>1*(2*0)</FONT
>, and then to
<FONT
COLOR="RED"
>1*0</FONT
>, and finally to <FONT
COLOR="RED"
>0</FONT
>. However, what we really want
is for the evaluation to return 0 immediately once the integer 0 is
encountered in the list, and this is accomplished by the function
<FONT
COLOR="RED"
>listprod3</FONT
>. When evaluating a call to <FONT
COLOR="RED"
>listprod3</FONT
> on
<FONT
COLOR="RED"
>[1, 2, 3, 0, 4, 5, 6]</FONT
>, we eventually reach the evaluation of
the following expression:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1443"
></A
><PRE
CLASS="programlisting"
>try 1*(2*(3*(aux([0,4,5,6])))) with ~ZERO() =&#62; 0
</PRE
><P
></P
></DIV
>


Evaluating <FONT
COLOR="RED"
>aux([0,4,5,6])</FONT
> leads to the exception
<FONT
COLOR="RED"
>ZERO()</FONT
> being raised, and this raised exception is caught and
<FONT
COLOR="RED"
>0</FONT
> is returned as the value of the call to
<FONT
COLOR="RED"
>listprod3</FONT
>.  Note that the pattern guard of the matching clause
following the keyword <FONT
COLOR="RED"
>with</FONT
> is <FONT
COLOR="RED"
>~ZERO()</FONT
>.  I will
explain the need for the tilde symbol <FONT
COLOR="RED"
>~</FONT
> elsewhere. For now, it
suffices to say that <FONT
COLOR="RED"
>exn</FONT
> is a linear type and each exception
value is a linear value, which must be consumed or re-raised. The tilde
symbol <FONT
COLOR="RED"
>~</FONT
> indicates that the value matching the pattern
following <FONT
COLOR="RED"
>~</FONT
> is consumed (and the memory for holding the value
is freed).
</P
><P
>&#13;Exceptions are not a programming feature that is easy to master, and
misusing exceptions is abundant in practice. So please be patient when
learning the feature and be cautious when using it.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_testing_for_braun_trees"
>Example: Testing for Braun Trees</A
></H2
><P
>&#13;Braun trees are special binary trees that can be defined
inductively as follows:

<P
></P
><UL
><LI
><P
>If a binary tree is empty, then it is a Braun tree.
</P
></LI
><LI
><P
>If both children of a binary tree are Braun trees and the
size of the left child minus the size of the right child equals 0 or 1,
then the binary tree is a Braun tree.
</P
></LI
></UL
>

Given a natural number n, there is exactly one Braun tree of size n.  It is
straightforward to prove that Braun trees are balanced.
</P
><P
>&#13;A polymorphic datatype is declared as follows for representing binary trees:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1465"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">tree <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">tree_nil <span class="keyword">of</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">tree_cons <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="comment">(*left*)</span><span class="keyword">,</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="comment">(*right*)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [tree] // end of [datatype]</span>
</p></PRE
><P
></P
></DIV
>


The following defined function <FONT
COLOR="RED"
>brauntest0</FONT
> tests whether a
given binary tree is a Braun tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1468"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> size
<span class="keyword">(</span>
t0<span class="keyword">:</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> t0 <span class="keyword">of</span>
<span class="keyword">|</span> tree_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
<span class="keyword">|</span> tree_cons<span class="keyword">(</span>_<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span> + size<span class="keyword">(</span>tl<span class="keyword">)</span> + size<span class="keyword">(</span>tr<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [size] *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> brauntest0
<span class="keyword">(</span>
t0<span class="keyword">:</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> t0 <span class="keyword">of</span>
<span class="keyword">|</span> tree_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
<span class="keyword">|</span> tree_cons<span class="keyword">(</span>_<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> test <span class="keyword">=</span> brauntest0<span class="keyword">(</span>tl<span class="keyword">)</span> andalso brauntest0<span class="keyword">(</span>tr<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> test
      <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> dif <span class="keyword">=</span> size<span class="keyword">(</span>tl<span class="keyword">)</span>-size<span class="keyword">(</span>tr<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">(</span>dif<span class="keyword">=</span><span class="dynexp">0</span><span class="keyword">)</span> orelse <span class="keyword">(</span>dif<span class="keyword">=</span><span class="dynexp">1</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> false
    <span class="comment">// end of [if]</span>
  <span class="keyword">end</span> <span class="comment">// end of [tree_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [brauntest0] *)</span>
</p></PRE
><P
></P
></DIV
>


The implementation of <FONT
COLOR="RED"
>brauntest0</FONT
> follows the definition of
Braun trees closely. If applied to binary trees of size n, the
time-complexity of the function <FONT
COLOR="RED"
>size</FONT
> is O(n) and the
time-complexity of the function <FONT
COLOR="RED"
>brauntest0</FONT
> is O(n(log(n))).
</P
><P
>&#13;In the following program, the defined function <FONT
COLOR="RED"
>brauntest1</FONT
> also
tests whether a given binary tree is a Braun tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1475"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> brauntest1
<span class="keyword">(</span>
t0<span class="keyword">:</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">exception</span> <span class="dynexp">Negative <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">fun</span>
  aux
  <span class="keyword">(</span>
  t0<span class="keyword">:</span> <span class="staexp">tree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">(</span>
    <span class="keyword">case+</span> t0 <span class="keyword">of</span>
    <span class="keyword">|</span> tree_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
    <span class="keyword">|</span> tree_cons
        <span class="keyword">(</span>_<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> szl <span class="keyword">=</span> aux<span class="keyword">(</span>tl<span class="keyword">)</span>
        <span class="keyword">and</span> szr <span class="keyword">=</span> aux<span class="keyword">(</span>tr<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> dif <span class="keyword">=</span> szl - szr</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>dif<span class="keyword">=</span><span class="dynexp">0</span> orelse dif<span class="keyword">=</span><span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">then</span> <span class="dynexp">1</span>+szl+szr <span class="keyword">else</span> <span class="dynexp"><span class="keyword">$raise</span> Negative<span class="keyword">(</span><span class="keyword">)</span></span>
      <span class="keyword">end</span> <span class="comment">// end of [tree_cons]</span>
  <span class="keyword">)</span></span> <span class="comment">(* end of [aux] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp"><span class="keyword">try</span> <span class="keyword">let</span>
    <span class="keyword">val</span> _ <span class="keyword">=</span> aux<span class="keyword">(</span>t0<span class="keyword">)</span>
  <span class="keyword">in</span>
    true <span class="comment">// [t] is a Braun tree</span>
  <span class="keyword">end</span> <span class="keyword">with</span>
    <span class="keyword">~</span>Negative<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false</span> <span class="comment">// [t] is not a Braun tree</span>
  <span class="comment">// end of [try]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [brauntest1]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, a binary tree cannot be a Braun tree if one of its subtrees,
proper or improper, is not a Braun tree. The auxiliary function
<FONT
COLOR="RED"
>aux</FONT
> is defined to return the size of a binary tree if the tree
is a Braun tree or raise an exception otherwise. When the evaluation of the
try-expression in the body of <FONT
COLOR="RED"
>brauntest1</FONT
> starts, the call to
<FONT
COLOR="RED"
>aux</FONT
> on a binary tree t is first evaluated. If the evaluation of
this call returns, then t is a Braun tree and the boolean value
<FONT
COLOR="RED"
>true</FONT
> is returned as the value of the try-expression. Otherwise,
the exception <FONT
COLOR="RED"
>Negative()</FONT
> is raised and then caught, and the
boolean value <FONT
COLOR="RED"
>false</FONT
> is returned as the value of the
try-expression.  The time complexity of <FONT
COLOR="RED"
>brauntest1</FONT
> is the same
as that of <FONT
COLOR="RED"
>aux</FONT
>, which is O(n).
</P
><P
>&#13;The use of the exception mechanism in the implementation of
<FONT
COLOR="RED"
>brauntest1</FONT
> is a convincing one because the range between the
point where an exception is raised and the point where the raised exception
is captured can span many function calls. If this range is short (e.g.,
spanning only one function call) in a case, then the programmer should
probably investigate whether it is a sensible use of the exception
mechanism. For instance, the use of exception in the following example may
seem interesting but it actually leads to very inefficient code:


<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1487"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list0_length
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="dynexp"><span class="keyword">try</span> 1 + list0_length<span class="keyword">(</span>xs<span class="keyword">.</span>tail<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">with</span> <span class="keyword">~</span>ListSubscriptExn<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0</span></span>
<span class="comment">// end of [list0_length]</span>
</p></PRE
><P
></P
></DIV
>


Therefore, making use of exceptions in this style should be avoided.

</P
><P
>&#13;Please find the entirety of the code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_EFFECTFUL/brauntest.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="references"
>References</A
></H2
><P
>&#13;A reference is just a singleton array, that is, an array containing one
element.  Given a type T, a reference for storing a value of the type T is
given the type ref(T).  The following simple program makes use of all the
essential functionalities on references:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1494"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> intr <span class="keyword">=</span> ref&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span></span> <span class="comment">// create a ref and init. it with 0</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>intr := <span class="keyword">!</span>intr + <span class="dynexp">1</span></span> <span class="comment">// increase the integer at [intr] by 1</span>
</p></PRE
><P
></P
></DIV
>


The first line creates a reference for storing an integer and initializes
it with the value 0 and then names it <FONT
COLOR="RED"
>intr</FONT
>. Note that this
style of reference creation cannot be separated from its
initialization. The second line updates the reference <FONT
COLOR="RED"
>intr</FONT
> with
its current value plus 1. In general, given a reference r of type ref(T)
for some T, the expression !r means to fetch the value stored at r, which
is of the type T. However, !r can also be used as a left-value. For
instance, the assignment (!r := exp) means to evaluate exp into a value and
then store the value into r. Therefore, the value stored in
<FONT
COLOR="RED"
>intr</FONT
> is 1 after the second line in the above program is
evaluated.
</P
><P
>&#13;Various functions and function templates on references are declared in the
file <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/reference.sats"
TARGET="_top"
>reference.sats</A
>, which
is automatically loaded by <B
CLASS="command"
>atsopt</B
>. In particular, it is
also possible to read from and write to a reference by using the function
templates <FONT
COLOR="RED"
>ref_get_elt</FONT
> and <FONT
COLOR="RED"
>ref_set_elt</FONT
> of the following
interfaces, respectively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1504"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> ref_get_elt<span class="keyword">(</span>r<span class="keyword">:</span> <span class="staexp">ref</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span> <span class="comment">// !r</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> ref_set_elt<span class="keyword">(</span>r<span class="keyword">:</span> <span class="staexp">ref</span> <span class="staexp">a</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// !r := x</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;References are often misused in practice, especially, by beginners of
functional programming who had some previous exposure to imperative
programming languages such C and Java. Such programmers often think that
they can just "translate" their programs in C or Java into functional
programs. For example, the following defined function <FONT
COLOR="RED"
>sumup</FONT
> is
such an example, which sums up all the integers between 1 and a given
integer, inclusive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1508"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> sumup
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> ref&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> ref&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">fun</span> loop<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> <span class="keyword">!</span>i &lt;= n <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">!</span>res := <span class="keyword">!</span>res + <span class="keyword">!</span>i<span class="keyword">;</span> <span class="keyword">!</span>i := <span class="keyword">!</span>i + <span class="dynexp">1</span><span class="keyword">;</span> loop<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> <span class="keyword">!</span>res
<span class="keyword">end</span></span> <span class="comment">// end of [sumup]</span>
</p></PRE
><P
></P
></DIV
>


This is a correct but poor implementation, and its style, though not the
worst of its kind, is deplorable. As references are allocated in heap,
reading from or writing to a reference can be much more time-consuming than
reading from or writing to a register. So, this implementation of
<FONT
COLOR="RED"
>sumup</FONT
> is unlikely to be time-efficient.  Every call to
<FONT
COLOR="RED"
>sumup</FONT
> creates two references in heap and leaves them there when
it returns, and the memory allocated for such references can only be
reclaimed through garbage collection (GC). So, this implementation of
<FONT
COLOR="RED"
>sumup</FONT
> is not memory-efficient.  More importantly, a program
making heavy use of references is often difficult to reason about.
</P
><P
>&#13;I consider references a dangerous feature in functional
programming. If you want to run your program without GC, please do not
create references in the body of a function (besides many other
restrictions). If you find that you are in need of references to
"translate" imperative programs into functional ones, then it is most
likely that you are lost and you have not learned well to program in a
functional style yet.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_counter_implementation"
>Example: A Counter Implementation</A
></H2
><P
>&#13;Let us see as follows the implementation of a counter-like object in the
style of object-oriented programming (OOP).  The type <FONT
COLOR="RED"
>counter</FONT
>
for counters is defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1518"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span>
<span class="staexp">counter <span class="keyword">=</span> <span class="keyword">'{</span>
  <span class="stalab">get</span><span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span>
<span class="keyword">,</span> <span class="stalab">inc</span><span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">,</span> <span class="stalab">reset</span><span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">}</span></span> <span class="comment">// end of [counter]</span>
</p></PRE
><P
></P
></DIV
>


The three fields of <FONT
COLOR="RED"
>counter</FONT
> are closure functions that
correspond to methods associated with an object: getting the count of the
counter, increasing the count of the counter by 1 and resetting the count
of the counter to 0. The following defined function <FONT
COLOR="RED"
>newCounter</FONT
>
is for creating a counter object (represented as a boxed record of closure
functions):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1522"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> newCounter
<span class="keyword">(</span>
<span class="comment">// argumentless</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">counter</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> count <span class="keyword">=</span> ref&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="keyword">in</span> <span class="keyword">'{</span>
  <span class="dynlab">get</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>count
<span class="keyword">,</span> <span class="dynlab">inc</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>count := <span class="keyword">!</span>count + <span class="dynexp">1</span>
<span class="keyword">,</span> <span class="dynlab">reset</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>count := <span class="dynexp">0</span>
<span class="keyword">}</span> <span class="keyword">end</span></span> <span class="comment">// end of [newCounter]</span>
</p></PRE
><P
></P
></DIV
>


The state of each created counter object is stored in a reference, which
can only be accessed by the three closure functions in the record that
represents the object. This is often referred to as state encapsulation
in OOP.
</P
><P
>&#13;I myself think that the above counter implementation is of rather
a poor style.  It is also possible to protect the integrity of a state by
simply making it abstract.  I will present elsewhere another counter
implementation based on a linear abstract type (that is, abstract viewtype
in ATS), where counters can be created and then safely freed.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="arrays"
>Arrays</A
></H2
><P
>&#13;I mentioned earlier that a reference is just an array of size 1.  I would
now like to state that an array of size n is just n references allocated
consecutively.  These references can also be called cells, and they are
numbered from 0 until n-1, inclusive.
</P
><P
>&#13;Given an array of size n, an integer is a valid index for this array if it
is a natural number strictly less than n. Otherwise, the integer is out of
the bounds of the array.  For an array named A, the expression A[i] means
to fetch the content of the cell in A that is numbered i if i is a valid
index for A. The expression A[i] can also be used as a left value. For
instance, the assignment (A[i] := exp) means to evaluate exp to a value and
then store the value into the cell in A that is numbered i if i is a valid
index.
</P
><P
>&#13;What happens if the index i in A[i] is invalid, that is, it is out of the
bounds of the array A?  In this case, A[i] is referred to as out-of-bounds
array subscription and evaluating A[i] leads to a raised exception where
the exception is <FONT
COLOR="RED"
>ArraySubscriptExn()</FONT
>.  One simple and reliable
way to tell whether an integer is a valid index for a given array is to
compare it with the size of the array at run-time.  Given a type T, the
type <FONT
COLOR="RED"
>arrszref(T)</FONT
> is for an array paired with its size in which
elements of the type T are stored. I will loosely refer to values of the
type <FONT
COLOR="RED"
>arrszref(T)</FONT
> as arrays from now on.  In case there is a
clear need to avoid potential confusion, I may also refer to them as
array0-values.
</P
><P
>&#13;Various functions and function templates on array0-values are declared in
the file <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/arrayref.sats"
TARGET="_top"
>arrayref.sats</A
>,
which is automatically loaded by <B
CLASS="command"
>atsopt</B
>. For instance,
three function templates and one polymorphic function on arrays are
depicted by the following interfaces:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1536"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="comment">// template</span>
arrszref_make_elt
  <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">a</span></span> <span class="comment">// array creation</span>
<span class="comment">//</span>
<span class="comment">// polymorphic fun:</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> arrszref_get_size
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span></span> <span class="comment">// size of an array</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="comment">// template</span>
arrszref_get_elt_at<span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span> <span class="comment">// A[i]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="comment">// template</span>
arrszref_set_elt_at<span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// A[i] := x</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


As for programming with arrays that carry no size information,
it is a topic to be covered after dependent types are introduced.

</P
><P
>&#13;Like in C, there are many types of integer values in ATS. The type
<FONT
COLOR="RED"
>size_t</FONT
> is essentially for unsigned long integers. The functions
for converting between the type <FONT
COLOR="RED"
>int</FONT
> and the type
<FONT
COLOR="RED"
>size_t</FONT
> are <FONT
COLOR="RED"
>g0int2uint_int_size</FONT
> and
<FONT
COLOR="RED"
>g0uint2int_size_int</FONT
>.  Given a type T and two values
<FONT
COLOR="RED"
>asz</FONT
> and <FONT
COLOR="RED"
>init</FONT
> of the types <FONT
COLOR="RED"
>size_t</FONT
> and T,
respectively, <FONT
COLOR="RED"
>arrszref_make_elt&#60;T&#62; (asz, init)</FONT
> returns an
array of the type <FONT
COLOR="RED"
>arrszref(T)</FONT
> such that the size of the array
is <FONT
COLOR="RED"
>asz</FONT
> and each cell in the array is initialized with the value
<FONT
COLOR="RED"
>init</FONT
>. Given an array A of the type <FONT
COLOR="RED"
>arrszref(T)</FONT
> for
some T, <FONT
COLOR="RED"
>arrszref_get_size(A)</FONT
> returns the size of A, which is of
the type <FONT
COLOR="RED"
>size_t</FONT
>. For convenience,
<FONT
COLOR="RED"
>arrszref_get_size(A)</FONT
> can be written as <FONT
COLOR="RED"
>A.size()</FONT
>.
As for array access and update, the functions
<FONT
COLOR="RED"
>arrszref_get_elt_at</FONT
> and <FONT
COLOR="RED"
>arrszref_set_elt_at</FONT
> can be
called. For convenience, the bracket notation can be used to call these
functions.  
</P
><P
>&#13;In the following program, the function template
<FONT
COLOR="RED"
>insertion_sort</FONT
> implements the standard insertion sort on
arrays:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1560"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insertion_sort
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">arrszref</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  loop<span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">fun</span>
  ins
  <span class="keyword">(</span>
   x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i &gt;= <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">(</span>
      <span class="keyword">if</span> cmp<span class="keyword">(</span>x<span class="keyword">,</span> <span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">)</span> <span class="keyword">&lt;</span> <span class="dynexp">0</span>
        <span class="keyword">then</span> <span class="keyword">(</span><span class="dynexp">A[i+1<span class="keyword">]</span></span> := <span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">;</span> ins<span class="keyword">(</span>x<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">else</span> <span class="keyword">(</span><span class="dynexp">A[i+1<span class="keyword">]</span></span> := x<span class="keyword">)</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">A[0<span class="keyword">]</span></span> := x</span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [ins]</span>
  <span class="dynexp"><span class="keyword">val</span> asz <span class="keyword">=</span>
    g0uint2int_size_int<span class="keyword">(</span>A<span class="dynexp"><span class="keyword">.</span>size</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">fun</span> loop<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> asz <span class="keyword">then</span> <span class="keyword">(</span>ins<span class="keyword">(</span><span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">;</span> loop<span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [insertion_sort] *)</span>
</p></PRE
><P
></P
></DIV
>


The comparison function <FONT
COLOR="RED"
>cmp</FONT
> should return 1, -1, and 0 if its
first argument is greater than, less than and equal to its second one,
respectively.

</P
><P
>&#13;Note that the entire code in this section plus some additional code
for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_EFFECTFUL/insort.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_ordering_permutations"
>Example: Ordering Permutations</A
></H2
><P
>Given a natural number n, we want to print out all the permutations
consisting of integers ranging from 1 to n, inclusive. In addition, we
want to print them out according to the lexicographic ordering on integer
sequences. For instance, we want the following output to be generated when
n is 3:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1568"
></A
><PRE
CLASS="programlisting"
>1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
</PRE
><P
></P
></DIV
>

</P
><P
>Let us first define a function as follows for printing out an array
of integers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1571"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
print_intarray
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrszref</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  loop<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> asz <span class="keyword">=</span>
  g0uint2int_size_int<span class="keyword">(</span>A<span class="dynexp"><span class="keyword">.</span>size</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">// The integers are to be separated by the string [sep]</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> asz <span class="keyword">then</span>
      <span class="keyword">(</span><span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> print sep<span class="keyword">;</span> print <span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">;</span> loop<span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">,</span> sep<span class="keyword">)</span><span class="keyword">)</span></span>
    <span class="comment">// end of [if]</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [print_intarray] *)</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>&#13;We next implement two functions <FONT
COLOR="RED"
>lrotate</FONT
> and <FONT
COLOR="RED"
>rrotate</FONT
>
for rearranging the elements in a given integer array:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1576"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> lrotate
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">int</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> lshift <span class="keyword">(</span>
    A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">int</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> j
    <span class="keyword">then</span> <span class="keyword">(</span><span class="dynexp">A[i<span class="keyword">]</span></span> := <span class="dynexp">A[i+1<span class="keyword">]</span></span><span class="keyword">;</span> lshift<span class="keyword">(</span>A<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [if]</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> j <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> tmp <span class="keyword">=</span> <span class="dynexp">A[i<span class="keyword">]</span></span></span> <span class="keyword">in</span> lshift<span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">;</span> <span class="dynexp">A[j<span class="keyword">]</span></span> := tmp
  <span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [lrotate]</span>

<span class="dynexp"><span class="keyword">fun</span> rrotate
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">int</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> rshift <span class="keyword">(</span>
    A<span class="keyword">:</span> <span class="staexp">arrszref</span> <span class="staexp">int</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> j
    <span class="keyword">then</span> <span class="keyword">(</span><span class="dynexp">A[j<span class="keyword">]</span></span> := <span class="dynexp">A[j-1<span class="keyword">]</span></span><span class="keyword">;</span> rshift<span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">,</span> j-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [if]</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> j <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> tmp <span class="keyword">=</span> <span class="dynexp">A[j<span class="keyword">]</span></span></span> <span class="keyword">in</span> rshift<span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">;</span> <span class="dynexp">A[i<span class="keyword">]</span></span> := tmp
  <span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [rrotate]</span>
</p></PRE
><P
></P
></DIV
>


When applied to an array and two valid indexes i and j for the array such
that i is less than or equal to j, <FONT
COLOR="RED"
>lrotate</FONT
> moves simultaneously
the content of cell i into cell j and the content of cell k to cell k-1 for
k ranging from i+1 to j, inclusive. The function <FONT
COLOR="RED"
>rrotate</FONT
> is
similar to <FONT
COLOR="RED"
>lrotate</FONT
> but shuffles elements in the opposite
direction.
</P
><P
>Given a natural number n, the following defined function
<FONT
COLOR="RED"
>permute</FONT
> prints out all the permutations consisting of integers
ranging from 1 to n, inclusive while arranging the output according to
the lexicographic ordering on integer sequences.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1583"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
permute
<span class="keyword">(</span>
 n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  aux<span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
  <span class="neuexp"><span class="keyword">#define</span> i2sz g0int2uint_int_size</span>
<span class="comment">//</span>
<span class="comment">// Creating array A of size n</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> A <span class="keyword">=</span>
  arrszref_make_elt&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>i2sz<span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">// Initializing A</span>
<span class="comment">// with integers from 1 to n, inclusive</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> init<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span> <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">fun</span> init<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
      <span class="keyword">if</span> i <span class="keyword">&lt;</span> n
        <span class="keyword">then</span> <span class="keyword">(</span><span class="dynexp">A[i<span class="keyword">]</span></span> := i+<span class="dynexp">1</span><span class="keyword">;</span> init<span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span></span>
      <span class="comment">// end of [if]</span>
  <span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [val]</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">fun</span> aux
    <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>
    <span class="keyword">if</span> i &lt;= n
      <span class="keyword">then</span> aux2<span class="keyword">(</span>i<span class="keyword">,</span> i<span class="keyword">)</span>
      <span class="keyword">else</span> <span class="keyword">(</span>
        print_intarray<span class="keyword">(</span>A<span class="keyword">)</span><span class="keyword">;</span> print_newline<span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">)</span> <span class="comment">(* end of [else] *)</span>
  <span class="keyword">)</span> <span class="comment">(* end of [aux] *)</span>
<span class="comment">//</span>
  <span class="keyword">and</span> aux2
    <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>
    <span class="keyword">if</span> j &lt;= n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
        rrotate<span class="keyword">(</span>A<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">,</span> j-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">;</span> aux<span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">;</span> lrotate<span class="keyword">(</span>A<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">,</span> j-<span class="dynexp">1</span><span class="keyword">)</span>
      <span class="keyword">)</span></span> <span class="comment">// end of [val]</span>
    <span class="keyword">in</span>
      aux2 <span class="keyword">(</span>i<span class="keyword">,</span> j + <span class="dynexp">1</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]</span>
  <span class="keyword">)</span></span> <span class="comment">(* end of [aux2] *)</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [permute] *)</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>where</FONT
> is a keyword, and the expression
(exp <FONT
COLOR="RED"
>where</FONT
> <FONT
COLOR="RED"
>{</FONT
> decseq <FONT
COLOR="RED"
>}</FONT
>)
for some expression exp and declaration sequence decseq is equivalent to
the let-expression of the form (<FONT
COLOR="RED"
>let</FONT
> decseq <FONT
COLOR="RED"
>in</FONT
> exp
<FONT
COLOR="RED"
>end</FONT
>). To understand the behavior of the function
<FONT
COLOR="RED"
>aux</FONT
>, let us evaluate <FONT
COLOR="RED"
>aux(1)</FONT
> while assuming that
<FONT
COLOR="RED"
>n</FONT
> is 4 and the 4 elements of the array <FONT
COLOR="RED"
>A</FONT
> are 1, 2,
3, and 4. It should be fairly straightforward to see that this evaluation
leads to the evaluation of <FONT
COLOR="RED"
>aux(2)</FONT
> for 4 times: the array
<FONT
COLOR="RED"
>A</FONT
> contains (1, 2, 3, 4) for the first time, and (2, 1, 3, 4)
for the second time, and (3, 1, 2, 4) for the third time, and (4, 1, 2, 3)
for the fourth time. With some inductive reasoning, it should not be
difficult to see that evaluating <FONT
COLOR="RED"
>aux(1)</FONT
> indeed leads to all the
permutations being output according to the lexicographic ordering on
integer sequences.
</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_EFFECTFUL/permord.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="matrices"
>Matrices</A
></H2
><P
>&#13;A matrix in ATS is just a two-dimensional array but it is represented by a
one-dimensional array and the representation is of the row-major style (in
contrast to the column-major style).  Given a type T, the type
<FONT
COLOR="RED"
>mtrxszref(T)</FONT
> is for a matrix combined with its number of rows
and number of columns such that each element stored in the matrix is of the
type T. I will loosely refer to values of the type <FONT
COLOR="RED"
>mtrxszref(T)</FONT
>
as matrices from now on.  If there is a clear need to avoid potential
confusion, I may also refer to them as matrix0-values.
</P
><P
>&#13;Given a matrix M of dimension m by n, the expression M[i,j] means to
fetch the content of the cell in M that is indexed by (i, j), where i and j
are natural numbers strictly less than m and n, respectively.  The
expression M[i,j] can also be used as a left value. For instance, the
assignment (M[i,j] := exp) means to evaluate exp to a value and then store
the value into the cell in M that is indexed by (i, j).
</P
><P
>&#13;Various functions and function templates on matrix0-values are declared in
the file <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/matrixref.sats"
TARGET="_top"
>matrixref.sats</A
>,
which is automatically loaded by <B
CLASS="command"
>atsopt</B
>. For instance,
three function templates and two polymorphic functions on matrices are
depicted by the following interfaces:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1610"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
mtrxszref_make_elt <span class="comment">// template</span>
  <span class="keyword">(</span>row<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> col<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> mtrxszref_get_nrow<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="keyword">(</span>M<span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span></span> <span class="comment">// polyfun</span>
<span class="dynexp"><span class="keyword">fun</span> mtrxszref_get_ncol<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="keyword">(</span>M<span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span></span> <span class="comment">// polyfun</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
mtrxszref_get_elt_at <span class="comment">// template</span>
  <span class="keyword">(</span>M<span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span> <span class="comment">// M[i,j]</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
mtrxszref_set_elt_at <span class="comment">// template</span>
  <span class="keyword">(</span>M<span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// M[i,j] := x</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Given a type T and three values <FONT
COLOR="RED"
>nrow</FONT
>, <FONT
COLOR="RED"
>ncol</FONT
> and
<FONT
COLOR="RED"
>init</FONT
> of the types <FONT
COLOR="RED"
>size_t</FONT
>, <FONT
COLOR="RED"
>size_t</FONT
> and T,
respectively, <FONT
COLOR="RED"
>mtrxszref_make_elt&#60;T&#62; (row, col, init)</FONT
>
returns a matrix of the type <FONT
COLOR="RED"
>mtrxszref(T)</FONT
> such that the
dimension of the matrix is <FONT
COLOR="RED"
>nrow</FONT
> by <FONT
COLOR="RED"
>ncol</FONT
> and each
cell in the matrix is initialized with the value <FONT
COLOR="RED"
>init</FONT
>. Given a
matrix M of the type <FONT
COLOR="RED"
>mtrxszref(T)</FONT
> for some T,
<FONT
COLOR="RED"
>mtrxszref_get_nrow(M)</FONT
> and <FONT
COLOR="RED"
>mtrxszref_get_ncol(M)</FONT
>
return the number of rows and the number of columns of M, respectively,
which are both of the type <FONT
COLOR="RED"
>size_t</FONT
>. For convenience,
<FONT
COLOR="RED"
>mtrxszref_get_nrow(M)</FONT
> and <FONT
COLOR="RED"
>mtrxszref_get_ncol(M)</FONT
> can
also be written as <FONT
COLOR="RED"
>M.nrow</FONT
> and <FONT
COLOR="RED"
>M.ncol</FONT
>, respectively.
As for matrix access and update, the function templates
<FONT
COLOR="RED"
>mtrxszref_get_elt_at</FONT
> and <FONT
COLOR="RED"
>mtrxszref_set_elt_at</FONT
> can
be called, respectively. For convenience, bracket notation can used for
these functions.
</P
><P
>&#13;Let us now take a look at an example. The following defined function
<FONT
COLOR="RED"
>mtrxszref_transpose</FONT
> turns a given matrix into its transpose:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1635"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
mtrxszref_transpose
  <span class="keyword">(</span>M<span class="keyword">:</span> <span class="staexp">mtrxszref</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nrow <span class="keyword">=</span> mtrxszref_get_nrow<span class="keyword">(</span>M<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fnx</span> loop1
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> nrow <span class="keyword">then</span> loop2<span class="keyword">(</span>i<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">and</span> loop2
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> j <span class="keyword">&lt;</span> i <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> tmp <span class="keyword">=</span> <span class="dynexp">M[i<span class="keyword">,</span>j<span class="keyword">]</span></span></span>
  <span class="keyword">in</span>
    <span class="dynexp">M[i<span class="keyword">,</span>j<span class="keyword">]</span></span> := <span class="dynexp">M[j<span class="keyword">,</span>i<span class="keyword">]</span></span><span class="keyword">;</span> <span class="dynexp">M[j<span class="keyword">,</span>i<span class="keyword">]</span></span> := tmp<span class="keyword">;</span> loop2<span class="keyword">(</span>i<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> loop1<span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span></span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop1 <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mtrxszref_transpose]</span>
</p></PRE
><P
></P
></DIV
>


The matrix M is assumed to be a square, that is, its number of rows equals
its number of columns. Note that the two functions <FONT
COLOR="RED"
>loop1</FONT
> and
<FONT
COLOR="RED"
>loop2</FONT
> are defined mutually tail-recursively, and the keyword
<FONT
COLOR="RED"
>fnx</FONT
> indicates the need to combine the bodies of
<FONT
COLOR="RED"
>loop1</FONT
> and <FONT
COLOR="RED"
>loop2</FONT
> so that mutual recursive tail-calls
in these function bodies can be compiled into direct local jumps.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_estimating_the_constant_pi"
>Example: Estimating the Constant Pi</A
></H2
><P
>&#13;I present as follows a Monte Carlo approach to estimating the constant Pi,
the ratio of the circumference of a circle over its diameter.
</P
><P
>&#13;Assume that we have a square of the dimension N by N, where N is a
relatively large natural number (e.g., 1000), and a disk of radius 1 that
is contained in the square. Let N2 stand for N*N, that is, the square of N.
If we randomly choose a point inside the square, then the probability for
the point to hit the disk is Pi/N2.
</P
><P
>&#13;The experiment we use to estimate the constant Pi can be described as
follows.  Given a natural number K, let us randomly choose K points inside
the square in K rounds. In each round, we choose exactly one point. If the
point chosen in round k hits on the disk centered at a previously chosen
point, then we record one hit. Clearly, the expected number of hits
recorded in round k is (k-1)*Pi/N2 as k-1 points have already being chosen
in the previous rounds. Therefore, in K rounds, the expected total number
of hits is (K*(K-1)/2)*Pi/N2. If K is fixed to be N2, then the expected
total number of hits is (N2-1)*Pi/2. It can be proven that the total number
of hits divided by N2 converges to Pi/2 (with probability 1) as N
approaches infinity.
</P
><P
>&#13;If we implement the above experiment directly based on the given
description, the time-complexity of the implementation is evidently
proportional to N2*N2 as the time spent in round k is proportional to k,
where k ranges from 1 to N2. An implementation as such is simply
impractical for handling N around the order 1000 (and thus N2 around the
order of 1,000,000). To address the issue, we can impose a grid on the
square, dividing it into N2 unit squares (of the dimension 1 by 1).  We
then associate with each unit square a list of chosen points that are
inside it. In each round, we first choose a point randomly inside the
original square; we next locate the unit square that contains this point;
we then only search the lists associated with the unit square or any of its
neighbors to count the number of hits generated by the point chosen in this
round as this point cannot hit any disks centered at points that are not on
these lists.  As each unit square can have at most 8 neighbors and the
average length of the list associated with each square is less than 1
during the experiment, the time spent during each round is O(1), that is,
bounded by a constant. Hence, the time taken by the entire experiment is
O(N2).
</P
><P
>&#13;An implementation that precisely matches the above description plus some
testing code is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_EFFECTFUL/montecarlo.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="basic_input_and_output"
>Simple Input and Output</A
></H2
><P
>&#13;Handling I/O in ATS properly requires the availability of both dependent
types and linear types, which I will cover elsewhere. In this section, I
only present a means for allowing the programmer to access certain very
basic I/O functionalities.
</P
><P
>&#13;A file handle essentially associates a stream (of bytes) with a file
identifier (represented as an integer).  In ATS, the type for file handles
is <FONT
COLOR="RED"
>FILEref</FONT
>. There are three standard file handles, which are
listed as follows:

</P
><P
></P
><UL
><LI
><P
><FONT
COLOR="RED"
>stdin_ref</FONT
>: standard input
</P
></LI
><LI
><P
><FONT
COLOR="RED"
>stdout_ref</FONT
>: standard output
</P
></LI
><LI
><P
><FONT
COLOR="RED"
>stderr_ref</FONT
>: standard error output
</P
></LI
></UL
><P
>&#13;Various functions on file handles are declared in the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/filebas.sats"
TARGET="_top"
>filebas.sats</A
>, which is
automatically loaded by <B
CLASS="command"
>atsopt</B
>. For instance, the
functions for opening and closing file handles have the following
interfaces:
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1668"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fileref_open_exn
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> fm<span class="keyword">:</span> <span class="staexp">file_mode</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">FILEref</span></span> <span class="comment">// endfun</span>

<span class="dynexp"><span class="keyword">fun</span> fileref_close<span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Note that these two functions abort immediately whenever an error occurs.
The following function is an optional version of
<FONT
COLOR="RED"
>fileref_open_exn</FONT
>, and the caller needs to inspect the value
returned by a call to <FONT
COLOR="RED"
>fileref_open_opt</FONT
> to see if a file handle
is actually obtained.
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1672"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fileref_open_opt
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> fm<span class="keyword">:</span> <span class="staexp">file_mode</span><span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>The type <FONT
COLOR="RED"
>file_mode</FONT
> is for values representing file modes,
which are listed as follows:
</P
><P
></P
><UL
><LI
><P
><FONT
COLOR="RED"
>file_mode_r</FONT
>: opening a file for reading and
positioning the associated stream at the beginning of the file.
</P
></LI
><LI
><P
><FONT
COLOR="RED"
>file_mode_rr</FONT
>: opening a file for both reading and and
writing and positioning the associated stream at the beginning of the file.
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>file_mode_w</FONT
>: truncating a given file to zero length or creating
a new one for writing and positioning the associated stream at the
beginning of the file.
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>file_mode_ww</FONT
>: truncating a given file to zero length or
creating a new one for both reading and writing and positioning the
associated stream at the beginning of the file.
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>file_mode_a</FONT
>: opening a file for writing and positioning the
associated stream at the end of the file.
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>file_mode_aa</FONT
>: opening a file for both reading and writing and
positioning the associated stream at the beginning of the file for reading
and at the end for writing.
</P
></LI
></UL
><P
>&#13;As an example, the following short program opens a file handle, outputs the
string "Hello, world!" plus a newline into the stream associated with the
file handle and then closes the file handle:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1696"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
out <span class="keyword">=</span>
fileref_open_exn<span class="keyword">(</span><span class="dynstr">"hello.txt"</span><span class="keyword">,</span> file_mode_w<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_string<span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"Hello, world!\n"</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fileref_close<span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</p></PRE
><P
></P
></DIV
>


After executing the program, we obtain a file of the name "hello.txt" in
the current working directory containing the expected content. There are
various fprint-functions in ATS for printing out data into the stream
associated with a given file handle. Often the programmer can simply use
the name <FONT
COLOR="RED"
>fprint</FONT
> to refer to these functions due to the support
for overloading in ATS.
</P
><P
>&#13;Another common I/O function is given the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1700"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fileref_get_line_string<span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr1</span></span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>fileref_get_line_string</FONT
> reads a line from the
stream associated with a given file handle, and it returns a value of the
type <FONT
COLOR="RED"
>Strptr1</FONT
>. For the moment, I will simply say that such a
value is just like a string except that it needs to be freed explicitly. As
an example, the following short program echos onto the standard output each
line read from the standard input:


<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1704"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span>
<span class="comment">// argumentless</span>
<span class="keyword">)</span> <span class="keyword">=</span> loop<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> isnot <span class="keyword">=</span>
    fileref_isnot_eof<span class="keyword">(</span>stdin_ref<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isnot <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> line <span class="keyword">=</span>
    fileref_get_line_string<span class="keyword">(</span>stdin_ref<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span><span class="keyword">(</span>stdout_ref<span class="keyword">,</span> line<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> strptr_free<span class="keyword">(</span>line<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="comment">(*loop exits as the end-of-file is reached*)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</p></PRE
><P
></P
></DIV
>


Note that the function <FONT
COLOR="RED"
>strptr_free</FONT
> is called to free a linear
string (of the type <FONT
COLOR="RED"
>Strptr1</FONT
>). Often, typing the CTRL-D
character can terminate the above program for echoing each line of input.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="modularity"
></A
>Chapter 7. Modularity</H1
><P
>&#13;Generally speaking, modularity in programming means to organize programs in
a modular fashion so that they each can be constructed in a relatively
isolated manner and then be combined to function coherently.  I will
introduce in this section some features in ATS that are largely designed to
facilitate program organization.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="types_as_a_form_of_specification"
>Types as a Form of Specification</A
></H2
><P
>&#13;The interface for a function or value specifies a type that any
implementation of the function or value should possess. For instance, the
following code defines a function <FONT
COLOR="RED"
>fact</FONT
> for computing the
factorial of a given integer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1717"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fact <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * fact <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
</p></PRE
><P
></P
></DIV
>


It is also possible to first declare an interface for <FONT
COLOR="RED"
>fact</FONT
> as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1720"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span> fact <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>extern</FONT
> is a keyword in ATS that initiates the declaration
of an interface. Alternative ways to declare an interface for <FONT
COLOR="RED"
>fact</FONT
>
are given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1724"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span> fact <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span></span>
<span class="keyword">extern</span> <span class="dynexp"><span class="keyword">val</span> fact <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


If <FONT
COLOR="RED"
>fact</FONT
> is declared to be a function, then it is required to be
applied when occurring in code. If it is declared to be a value, there is
no such a restriction.
</P
><P
>&#13;A function interface can be considered as a form of specification. For
instance, the above interface for <FONT
COLOR="RED"
>fact</FONT
> specifies that
<FONT
COLOR="RED"
>fact</FONT
> is a function that takes one argument required to be an
integer and returns a value guaranteed to be an integer. What is so special
about this form of specification is that it is formally enforced in ATS
through typechecking: Any well-typed implementation of <FONT
COLOR="RED"
>fact</FONT
> in
ATS must possess the interface declared for it.  Of course, this interface
for <FONT
COLOR="RED"
>fact</FONT
> is not a precise specification as there are
(infinitely) many functions that can be given the same interface. This kind
of imprecision can, however, be reduced or even eliminated,
sometimes. After dependent types are introduced, I will present an
interface for <FONT
COLOR="RED"
>fact</FONT
> such that any implementation of the
interface is guaranteed to implement precisely the factorial function as is
defined by the following two equations:

<P
></P
><UL
><LI
><P
>&#13;fact(0) = 1
</P
></LI
><LI
><P
>&#13;fact(n) = n * fact (n-1) for each natural number n &#62; 0
</P
></LI
></UL
>

</P
><P
>&#13;An implementation for <FONT
COLOR="RED"
>fact</FONT
> as the following one can be given at
any point where the declared interface for <FONT
COLOR="RED"
>fact</FONT
> is accessible:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1741"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> fact <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * fact <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>implement</FONT
> is for initiating an implementation of a
function or value whose interface is already declared. It is fairly common
to see the following style of coding, usually, by a beginning ATS programmer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1744"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> fact <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * fact <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
</p></PRE
><P
></P
></DIV
>


While this implementation can pass typechecking, it is nonetheless of a
poor style: The types provided by the programmer for the argument and the
result of <FONT
COLOR="RED"
>fact</FONT
> are redundant as they can be automatically
synthesized by the typechecker.
</P
><P
>&#13;As an example of an interface for a value, <FONT
COLOR="RED"
>fact10</FONT
> is declared
as follows to be a value of the type <FONT
COLOR="RED"
>int</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1750"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span> <span class="dynexp"><span class="keyword">val</span> fact10 <span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


The following implementation for <FONT
COLOR="RED"
>fact10</FONT
> can be given at any
point where the declared interface for <FONT
COLOR="RED"
>fact10</FONT
> is accessible:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1754"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> fact10 <span class="keyword">=</span> fact <span class="keyword">(</span><span class="dynexp">10</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;As another example, the following code declares an interface for a
polymorphic function named <FONT
COLOR="RED"
>swap_boxed</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1758"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> swap_boxed<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Note that both type variables <FONT
COLOR="RED"
>a</FONT
> and <FONT
COLOR="RED"
>b</FONT
> are boxed.
An implementation for <FONT
COLOR="RED"
>swap_boxed</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1763"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> swap_boxed<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">}</span></span> <span class="keyword">(</span>xy<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The syntax <FONT
COLOR="RED"
>{a,b}</FONT
> is for passing static arguments <FONT
COLOR="RED"
>a</FONT
>
and <FONT
COLOR="RED"
>b</FONT
> to <FONT
COLOR="RED"
>swap_boxed</FONT
> simultaneously. As neither
<FONT
COLOR="RED"
>a</FONT
> nor <FONT
COLOR="RED"
>b</FONT
> is actually used in the body of
<FONT
COLOR="RED"
>swap_boxed</FONT
>, it is allowed to drop <FONT
COLOR="RED"
>{a,b}</FONT
> in this
case.
</P
><P
>&#13;As yet another example, the following code declares an interface for a
function template named <FONT
COLOR="RED"
>swap_tmplt</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1775"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> swap_tmplt <span class="keyword">(</span>xy<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Note that both type variables <FONT
COLOR="RED"
>a</FONT
> and <FONT
COLOR="RED"
>b</FONT
> are of the
sort <FONT
COLOR="RED"
>t@ype</FONT
>, indicating that they can be of any size.

An implementation for <FONT
COLOR="RED"
>swap_tmplt</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1781"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">,</span>b</span><span class="keyword">}</span> swap_tmplt <span class="keyword">(</span>xy<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>xy<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> xy<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;It is a standard practice for a programmer to first design interfaces for
the functions to be supported in a package before actually implementing any
of these functions. When such interfaces are available, application
programs can be constructed to test whether the interface design makes
sense or is convenient for practical use. Please remember that a superb
implementation of a poor design cannot make the design any
better. Therefore, testing a design before actually implementing it is
often of vital importance. This is especially true if the involved design
is complex.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="static_and_dynamic_ats_files"
>Static and Dynamic ATS Files</A
></H2
><P
>&#13;The first letters in the ATS filename extensions <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>sats</I
></SPAN
> and
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>dats</I
></SPAN
> refer to the words <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>static</I
></SPAN
> and
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>dynamic</I
></SPAN
>, respectively.  For instance, <TT
CLASS="filename"
>foo.sats</TT
> is
a name for a static file while <TT
CLASS="filename"
>bar.dats</TT
> is for a dynamic
one. A static file is often referred to as a SATS-file, and it usually
contains interface declarations for functions and values, datatype
declarations, type definitions, etc. The primary purpose of a SATS-file is
for allowing its content to be shared among various other ATS files, either
static or dynamic.
</P
><P
>&#13;Let us now go through a simple example to see a typical use of static
files. Suppose that we want to implement the Ackermann's function, which is
famous for being recursive but not primitive recursive.  In a static file
named <TT
CLASS="filename"
>acker.sats</TT
> (or any other legal filename), we can declare
the following function interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1795"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> acker <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


Please note that one should not use the keyword <FONT
COLOR="RED"
>extern</FONT
> when
declaring an interface for either a function or a value in a static file.
Then in a dynamic file named <TT
CLASS="filename"
>acker.dats</TT
> (or any other legal
filename), we can give the following implementation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1799"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">staload</span> "acker.sats"

<span class="dynexp"><span class="keyword">implement</span>
acker <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> acker <span class="keyword">(</span>m<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">else</span> n+<span class="dynexp">1</span></span>
<span class="comment">// end of [acker]</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>staload</FONT
> indicates to the ATS typechecker that the
file following it is to be statically loaded during
typechecking. Essentially, statically loading a file means to put the
content of the file in a namespace that can be accessed by the following
code.  It is important to note that static loading is different from plain
file inclusion. The latter is also supported in ATS, and it is a feature I
will cover elsewhere.
</P
><P
>&#13;It is also possible to give the following implementation for the declared
function <FONT
COLOR="RED"
>acker</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1804"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">staload</span> ACKER <span class="keyword">=</span> "acker.sats"

<span class="dynexp"><span class="keyword">implement</span> $ACKER<span class="keyword">.</span>acker
  <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> acker <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">fun</span> acker <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 
    <span class="keyword">if</span> m <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
      <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> acker <span class="keyword">(</span>m<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">else</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
    <span class="keyword">else</span> n+<span class="dynexp">1</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [$ACKER.acker]</span>
</p></PRE
><P
></P
></DIV
>


In this case, the namespace for storing the content of the file
<TT
CLASS="filename"
>acker.sats</TT
> is given the name ACKER, and the prefix
<FONT
COLOR="RED"
>$ACKER.</FONT
> (the dollar sign followed by ACKER followed by the dot
symbol) must be attached to any name that refers an entity (a function, a
value, a datatype, a constructor (associated with a datatype), a type
definition, etc.) declared in <TT
CLASS="filename"
>acker.sats</TT
>. When there are many
static files to be loaded, it is often a good practice to assign names to
the namespaces holding these files so that the original source of each
declared entity can be readily tracked down.
</P
><P
>&#13;In another file named <TT
CLASS="filename"
>test_acker.dats</TT
>, let us
write the following code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1811"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">#include</span>
"share/atspre_staload.hats"</span>
<span class="comment">//</span>
<span class="keyword">staload</span> "acker.sats"
<span class="keyword">dynload</span> "acker.dats"

<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">//</span>
<span class="comment">// acker (3, 3) should return 61</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>acker <span class="keyword">(</span><span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">61</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main0]</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>dynload</FONT
> indicates to the ATS compiler to generate a
call to the initializing function associated with the file
<TT
CLASS="filename"
>acker.dats</TT
>. This is mandatory as an error would otherwise be
reported at link-time. Usually, calling the initializing function
associated with a dynamic file is necessary only if there is a value
implemented in the file. In this case, there is only a function implemented
in <TT
CLASS="filename"
>acker.dats</TT
>. If we include the following line somewhere
inside <TT
CLASS="filename"
>acker.dats</TT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1817"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="neuexp"><span class="keyword">#define</span> ATS_DYNLOADFLAG 0</span> <span class="comment">// no need for dynloading at run-time</span>
</p></PRE
><P
></P
></DIV
>


then the line starting with the keyword <FONT
COLOR="RED"
>dynload</FONT
> in
<TT
CLASS="filename"
>test_acker.dats</TT
> is no longer needed. The function
<FONT
COLOR="RED"
>assertloc</FONT
> verifies at run-time that its argument evaluates to
the boolean value <FONT
COLOR="RED"
>true</FONT
>. In the case where the argument
evaluates to <FONT
COLOR="RED"
>false</FONT
>, the function call aborts and a message is
reported that contains the name of the file, which is
<TT
CLASS="filename"
>test_acker.dats</TT
> in this example, and the location at
which the source code of the call is found in the file. If this sounds a
bit confusing, please try to execute a program that contains a call to
<FONT
COLOR="RED"
>assertloc</FONT
> on <FONT
COLOR="RED"
>false</FONT
> and you will see clearly what
happens.
</P
><P
>&#13;The simplest way to compile the two files <TT
CLASS="filename"
>acker.dats</TT
> and
<TT
CLASS="filename"
>test_acker.dats</TT
> is to issue the following command-line:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1830"
></A
><PRE
CLASS="programlisting"
>&#13;<B
CLASS="command"
>atscc</B
> -o test_acker acker.dats test_acker.dats
</PRE
><P
></P
></DIV
>

The generated excutable <TT
CLASS="filename"
>test_acker</TT
> is in the current
working directory.  The compilation can also be performed separately as is
demonstrated below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1834"
></A
><PRE
CLASS="programlisting"
>&#13;<B
CLASS="command"
>atscc</B
> -c acker.dats
<B
CLASS="command"
>atscc</B
> -c test_acker.dats
<B
CLASS="command"
>atscc</B
> -o test_acker acker_dats.o test_acker_dats.o
</PRE
><P
></P
></DIV
>

This style of separate compilation works particularly well when it is
employed by the <B
CLASS="command"
>make</B
> utility.
</P
><P
>If we want to, we can also merge <TT
CLASS="filename"
>acker.sats</TT
> and
<TT
CLASS="filename"
>acker.dats</TT
> into a single filename of the following content:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1843"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> acker <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>

<span class="dynexp"><span class="keyword">implement</span>
acker <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> acker <span class="keyword">(</span>m<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span> acker <span class="keyword">(</span>m-<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">else</span> n+<span class="dynexp">1</span></span>
<span class="comment">// end of [acker]</span>
</p></PRE
><P
></P
></DIV
>


Suppose that this single file is given the name <TT
CLASS="filename"
>acker3.dats</TT
>.
Then the testing code can be written as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1846"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">#include</span>
"share/atspre_staload.hats"</span>
<span class="comment">//</span>
<span class="keyword">staload</span> "acker3.dats"
<span class="keyword">dynload</span> "acker3.dats"

<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">//</span>
<span class="comment">// acker (3, 3) should return 61</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>acker <span class="keyword">(</span><span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">61</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main0]</span>
</p></PRE
><P
></P
></DIV
>


Note that it is perfectly fine for a dynamic ATS file to be statically
loaded. Actually, a static ATS file is really just a special case of
dynamic ATS file in which there is no implementation (of either functions
or values).
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="generic_template_implementation"
>Generic Template Implementation</A
></H2
><P
>&#13;Interfaces for function templates are mostly similar to those for
functions.  For example, the following syntax declares an interface in a
dynamic file for a function template of the name <FONT
COLOR="RED"
>list0_fold_left</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1852"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_fold_left
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">b</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span><span class="keyword">,</span> init<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>t0p</FONT
> is a shorthand for <FONT
COLOR="RED"
>t@ype</FONT
>.</P
><P
>&#13;If the same interface is declared in a static file, the keyword
<FONT
COLOR="RED"
>extern</FONT
> should be dropped. Implementing an interface for a
function template is also mostly similar to implementing one for a
function. The above interface for <FONT
COLOR="RED"
>list0_fold_left</FONT
> is given an
implementation in the following code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1859"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_fold_left
  <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">,</span> init<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">b</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> f <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>xs<span class="keyword">,</span> init<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_fold_left]</span>
</p></PRE
><P
></P
></DIV
>


Note that template parameters are required to appear immediately after the
keyword <FONT
COLOR="RED"
>implement</FONT
>, and they cannot be omitted.  Template
parameters can also be passed sequentially as is shown in the following
short example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1862"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
app2 <span class="keyword">(</span>f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">c</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">c</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">,</span>b</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">c</span><span class="keyword">}</span> app2 <span class="keyword">(</span>f<span class="keyword">,</span> x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> f <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The style of template implementation presented in this section is
referred to as generic template implementation. I will later present a
different style of template implementation, which is often referred to as
specific template implementation.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="specific_template_implementation"
>Specific Template Implementation</A
></H2
><P
>&#13;Implementing an interface for a function template specifically means to
give an implementation for a fixed instance of the template. For instance,
the following interface is for a function template of the name
<FONT
COLOR="RED"
>eq_elt_elt</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1869"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
eq_elt_elt <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// a generic equality</span>
</p></PRE
><P
></P
></DIV
>


There is no meaningful generic implementation for <FONT
COLOR="RED"
>eq_elt_elt</FONT
> as
equality test for values of a type T depends on T.  Two specific template
implementations are given as follows for the instances
<FONT
COLOR="RED"
>eq_elt_elt&#60;int&#62;</FONT
> and <FONT
COLOR="RED"
>eq_elt_elt&#60;double&#62;</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1874"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> eq_elt_elt&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> g0int_eq <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span> eq_elt_elt&lt;<span class="staexp">double</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> g0float_eq <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>eq_int_int</FONT
> and <FONT
COLOR="RED"
>eq_double_double</FONT
> are equality
functions for values of the type <FONT
COLOR="RED"
>int</FONT
> and <FONT
COLOR="RED"
>double</FONT
>,
respectively. It is also possible to give the implementations as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1880"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> eq_elt_elt&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>x <span class="keyword">=</span> y<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span> eq_elt_elt&lt;<span class="staexp">double</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>x <span class="keyword">=</span> y<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


This is allowed as the symbol <FONT
COLOR="RED"
>=</FONT
> is already overloaded with
<FONT
COLOR="RED"
>g0int_eq</FONT
> and <FONT
COLOR="RED"
>g0float_eq</FONT
> (in addition to many other
functions).
</P
><P
>&#13;Let us now see a typical use of specific template implementation.  The
following defined function template <FONT
COLOR="RED"
>listeq</FONT
> implements an
equality function on lists:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1887"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> listeq
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">(</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span>
     list0_cons <span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 
      <span class="keyword">if</span> eq_elt_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">then</span> listeq <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">else</span> false
  <span class="keyword">|</span> <span class="keyword">(</span>list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> false
<span class="keyword">)</span></span> <span class="comment">(* end of [listeq] *)</span>
</p></PRE
><P
></P
></DIV
>


Given two lists xs and ys, <FONT
COLOR="RED"
>listeq</FONT
> returns <FONT
COLOR="RED"
>true</FONT
> if
and only if xs and ys are of the same length and each element in xs equals
the corresponding one in ys (according to <FONT
COLOR="RED"
>eq_elt_elt</FONT
>).
Given a type T, it is clear that the instance
<FONT
COLOR="RED"
>eq_elt_elt&#60;T&#62;</FONT
> is needed if <FONT
COLOR="RED"
>listeq</FONT
> is called
on two lists of the type <FONT
COLOR="RED"
>list0(T)</FONT
>. In other words, a specific
implementation for <FONT
COLOR="RED"
>eq_elt_elt&#60;T&#62;</FONT
> should be given if a
call to <FONT
COLOR="RED"
>listeq</FONT
> is to be made on two lists of the type
<FONT
COLOR="RED"
>list0(T)</FONT
>. Note that the implementation for an instance of a
function template is required to be accessible from the file where the
instance is called.
</P
><P
>As a comparison, the following defined function template
<FONT
COLOR="RED"
>listeqf</FONT
> also implements equality test on two given lists:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1900"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> listeqf
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
<span class="keyword">,</span> eq<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">(</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span>
     list0_cons <span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 
      <span class="keyword">if</span> eq <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">then</span> listeqf <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> eq<span class="keyword">)</span> <span class="keyword">else</span> false
  <span class="keyword">|</span> <span class="keyword">(</span>list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> false
<span class="keyword">)</span></span> <span class="comment">(* end of [listeqf] *)</span>
</p></PRE
><P
></P
></DIV
>


In this case, <FONT
COLOR="RED"
>listeqf</FONT
> takes an additional argument
<FONT
COLOR="RED"
>eq</FONT
> that tests whether two list elements are equal.  As
<FONT
COLOR="RED"
>listeq</FONT
> is a first-order function while <FONT
COLOR="RED"
>listeqf</FONT
> is a
higher-order one, it is likely for the former to be compiled into more
efficient object code. I would like to point out that the library of ATS
makes pervasive use of specifically implemented templates.

</P
><P
>Please find the code presented in this section plus some additional
testing code available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/listeq.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="abstract_types"
>Abstract Types</A
></H2
><P
>&#13;The name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>abstract type</I
></SPAN
> refers to a type such
that values of the type are represented in a way that is completely hidden
from users of the type. This form of information-hiding attempts to ensure
that changes to the implementation of an abstract type cannot introduce
type-errors into well-typed code that makes use of the abstract type. In
ATS as well as in many other programming languages, abstract types play a
pivotal role in support of modular programming. I will present as follows a
concrete example to illustrate a typical use of abstract types in
practice.
</P
><P
>&#13;Suppose that we are to implement a package to provide various
funtionalities on finite sets of integers. We first declare an abstract
type <FONT
COLOR="RED"
>intset</FONT
> as follows for values representing finite sets of
integers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1914"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">abstype</span> intset</span> <span class="comment">// a boxed abstract type</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>abstype</FONT
> indicates that the declared abstract type
<FONT
COLOR="RED"
>intset</FONT
> is boxed, that is, the size of <FONT
COLOR="RED"
>intset</FONT
> is the
same as that of a pointer.  There is a related keyword <FONT
COLOR="RED"
>abst@ype</FONT
>
for introducing unboxed abstract types, which will be explained elsewhere.
We next present an interface for each function or value that we want to
implement in the package:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1920"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">// empty set</span>
<span class="dynexp"><span class="keyword">val</span> intset_empty <span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// singleton set of [x]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_make_sing <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// turning a list into a set</span>
<span class="dynexp"><span class="keyword">fun</span> intset_make_list <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// turning a set into a list</span>
<span class="dynexp"><span class="keyword">fun</span> intset_listize <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span></span>

<span class="comment">// membership test</span>
<span class="dynexp"><span class="keyword">fun</span> intset_ismem <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>

<span class="comment">// computing the size of [xs]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_size <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span></span>

<span class="comment">// adding [x] into [xs]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_add <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// deleting [x] from [xs]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_del <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// union of [xs1] and [xs2]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_union <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// intersection of [xs1] and [xs2]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_inter <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>

<span class="comment">// difference between [xs1] and [xs2]</span>
<span class="dynexp"><span class="keyword">fun</span> intset_differ <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">intset</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intset</span></span>
</p></PRE
><P
></P
></DIV
>


Let us now suppose that the declaration for <FONT
COLOR="RED"
>intset</FONT
> and the
above interfaces are all stored in a file named <TT
CLASS="filename"
>intset.sats</TT
>
(or any other legal name for a static file).
</P
><P
>&#13;Usually, a realistic implementation for finite sets is based on some kind
of balanced trees (e.g., AVL trees, red-black trees). For the purpose of
illustration, I hereby give an implementation in which finite sets of
integers are represented as ordered lists of integers. This implementation
is contained in a file named <TT
CLASS="filename"
>intset.dats</TT
>, which is available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/intset.dats"
TARGET="_top"
>on-line</A
>.  In order to
construct values of an abstract type, we need to concretize it temporarily
by using the following form of declaration:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1927"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">assume</span> intset <span class="keyword">=</span> list0 <span class="keyword">(</span>int<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>assume</FONT
> is a keyword. This assume-declaration equates
<FONT
COLOR="RED"
>intset</FONT
> with the type <FONT
COLOR="RED"
>list0 (int)</FONT
> and this equation is
valid until the end of the scope in which it is introduced. As the
assume-declaration is at the toplevel in <TT
CLASS="filename"
>intset.dats</TT
>,
the assumption that <FONT
COLOR="RED"
>intset</FONT
> equals <FONT
COLOR="RED"
>list0 (int)</FONT
> is valid
until the end of the file. There is a global restriction in ATS that allows
each abstract type to be concretized by an assume-declaration at most
once. More specifically, if an abstract type is concretized in two files
<TT
CLASS="filename"
>foo1.dats</TT
> and <TT
CLASS="filename"
>foo2.dats</TT
>, then
these two files cannot be used together to generate an executable.

The rest of implementation in <FONT
COLOR="RED"
>intset</FONT
> is all standard.  For
instance, the union operation on two given sets of integers is implemented
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1938"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
intset_union
  <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">of</span>
<span class="keyword">|</span> <span class="keyword">(</span>list0_cons <span class="keyword">(</span>x1<span class="keyword">,</span> xs11<span class="keyword">)</span><span class="keyword">,</span>
   list0_cons <span class="keyword">(</span>x2<span class="keyword">,</span> xs21<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span>
        list0_cons<span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span><span class="keyword">(</span>x1<span class="keyword">,</span> intset_union <span class="keyword">(</span>xs11<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span>
        list0_cons<span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span><span class="keyword">(</span>x2<span class="keyword">,</span> intset_union <span class="keyword">(</span>xs1<span class="keyword">,</span> xs21<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="comment">(* sgn = 0 *)</span> <span class="keyword">=&gt;</span>
        list0_cons<span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span><span class="keyword">(</span>x1<span class="keyword">,</span> intset_union <span class="keyword">(</span>xs11<span class="keyword">,</span> xs21<span class="keyword">)</span><span class="keyword">)</span>
    <span class="comment">// end of [case]</span>
  <span class="keyword">end</span> <span class="comment">// end of [(cons, cons)]</span>
<span class="keyword">|</span> <span class="keyword">(</span>list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> xs2
<span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs1
<span class="keyword">)</span></span> <span class="comment">(* end of [intset_union] *)</span>
</p></PRE
><P
></P
></DIV
>


There is also some testing code available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/test_intset.dats"
TARGET="_top"
>on-line</A
>
that makes use of some functions declared in
<TT
CLASS="filename"
>intset.sats</TT
>.  Often testing code as such is
constructed immediately after the interfaces for various functions and
values in a package are declared. This allows these interfaces to be tried
before they are actually implemented so that potential flaws can be exposed
in a timely fashion.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_a_package_for_rationals"
>Example: A Package for Rationals</A
></H2
><P
>&#13;Let us represent a rational number as a pair of integers.  If we declare a
boxed abstract type <FONT
COLOR="RED"
>rat</FONT
> for values representing rational
numbers, then each value of the type <FONT
COLOR="RED"
>rat</FONT
> is stored in
heap-allocated memory, which can only be reclaimed through garbage
collection (GC). Instead, we follow an alternative approach by declaring
<FONT
COLOR="RED"
>rat</FONT
> as an unboxed abstract type. Therefore, a declaration like
the following one is expected:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1948"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">abst@ype</span> rat</span>
</p></PRE
><P
></P
></DIV
>


The problem with this declaration is that it is too abstract. As there is
not information given about the size of the type <FONT
COLOR="RED"
>rat</FONT
>, the ATS
compiler does not even know how much memory is needed for storing a value
of the type <FONT
COLOR="RED"
>rat</FONT
>. However, the programmer should not assume that
such a form of declaration is useless. There are realistic circumstances
where a declaration of this form can be of great importance, and this is a
topic I will cover elsewhere. For now, let us declare an unboxed abstract
type as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1952"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">abst@ype</span> rat <span class="keyword">=</span> <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


This declaration simply informs the ATS compiler that the representation
for values of the type <FONT
COLOR="RED"
>rat</FONT
> is the same as the one for values of
the type <FONT
COLOR="RED"
>(int, int)</FONT
>. However, this information is not made
available to the typechecker of ATS. In particular, if a value of the type
<FONT
COLOR="RED"
>rat</FONT
> is treated as a pair of integers in a program, then a
type-error will surely occur.  </P
><P
>The following code is contained in a file named
<TT
CLASS="filename"
>ratmod.sats</TT
>, which is available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/ratmod.sats"
TARGET="_top"
>on-line</A
>.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1960"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">exception</span> <span class="dynexp">Denominator</span>
<span class="keyword">exception</span> <span class="dynexp">DivisionByZero</span>

<span class="dynexp"><span class="keyword">fun</span> rat_make_int_int <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> q<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">rat</span></span>

<span class="dynexp"><span class="keyword">fun</span> ratneg<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">rat</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">rat</span></span> <span class="comment">// negation</span>
<span class="dynexp"><span class="keyword">fun</span> ratadd<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">rat</span><span class="keyword">,</span> <span class="staexp">rat</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">rat</span></span> <span class="comment">// addition</span>
<span class="dynexp"><span class="keyword">fun</span> ratsub<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">rat</span><span class="keyword">,</span> <span class="staexp">rat</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">rat</span></span> <span class="comment">// subtraction</span>
<span class="dynexp"><span class="keyword">fun</span> ratmul<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">rat</span><span class="keyword">,</span> <span class="staexp">rat</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">rat</span></span> <span class="comment">// multiplication</span>
<span class="dynexp"><span class="keyword">fun</span> ratdiv<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">rat</span><span class="keyword">,</span> <span class="staexp">rat</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">rat</span></span> <span class="comment">// division</span>
</p></PRE
><P
></P
></DIV
>


The exception <FONT
COLOR="RED"
>Denominator</FONT
> is for reporting an erroneous
occasion where a rational number is to be formed with a denominator equal
to zero.  Given two integers representing the numerator and denominator of
a rational number, the function <FONT
COLOR="RED"
>rat_make_int_int</FONT
> returns a
value representing the rational number. The following implementation of
<FONT
COLOR="RED"
>rat_make_int_int</FONT
> can be found in a file named
<TT
CLASS="filename"
>ratmod.dats</TT
>, which is also available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/ratmod.dats"
TARGET="_top"
>on-line</A
>.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1967"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
rat_make_int_int <span class="keyword">(</span>p<span class="keyword">,</span> q<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> make <span class="keyword">(</span>
    p<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> q<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">rat</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> r <span class="keyword">=</span> gcd <span class="keyword">(</span>p<span class="keyword">,</span> q<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">(</span>p / r<span class="keyword">,</span> q / r<span class="keyword">)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [make]</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> q <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="dynexp"><span class="keyword">$raise</span> Denominator</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> q <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> make <span class="keyword">(</span>p<span class="keyword">,</span> q<span class="keyword">)</span> <span class="keyword">else</span> make <span class="keyword">(</span><span class="keyword">~</span>p<span class="keyword">,</span> <span class="keyword">~</span>q<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [rat_make_int_int]</span>
</p></PRE
><P
></P
></DIV
>


Given a pair of integers p and q such that q is not zero, the function
<FONT
COLOR="RED"
>rat_make_int_int</FONT
> returns another pair of integers
p<SUB
>1</SUB
> and q<SUB
>1</SUB
> such that
q<SUB
>1</SUB
> is positive, p<SUB
>1</SUB
> and
q<SUB
>1</SUB
> are coprimes, that is, their greatest common
divisor is 1, and p<SUB
>1</SUB
>/q<SUB
>1</SUB
>
equals p/q. With <FONT
COLOR="RED"
>rat_make_int_int</FONT
>, it is straightforward to
implement as follows the arithmetic operations on rational numbers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1978"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> ratneg <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">~</span>x<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">,</span> x<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">implement</span>
ratadd <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span>
  rat_make_int_int <span class="keyword">(</span>x<span class="dynexp"><span class="keyword">.0</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span> + x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">,</span> x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
<span class="comment">// end of [ratadd]</span>

<span class="dynexp"><span class="keyword">implement</span>
ratsub <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span>
  rat_make_int_int <span class="keyword">(</span>x<span class="dynexp"><span class="keyword">.0</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span> - x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">,</span> x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
<span class="comment">// end of [ratsub]</span>

<span class="dynexp"><span class="keyword">implement</span>
ratmul <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> rat_make_int_int <span class="keyword">(</span>x<span class="dynexp"><span class="keyword">.0</span></span> * y<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">,</span> x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">implement</span>
ratdiv <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="keyword">if</span> y<span class="dynexp"><span class="keyword">.0</span></span> <span class="keyword">&gt;</span> <span class="dynexp">0</span>
  <span class="keyword">then</span> rat_make_int_int <span class="keyword">(</span>x<span class="dynexp"><span class="keyword">.0</span></span> * y<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> x<span class="dynexp"><span class="keyword">.1</span></span> * y<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp"><span class="keyword">$raise</span> DivisionByZero<span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [if]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [ratdiv] *)</span>
</p></PRE
><P
></P
></DIV
>


There is also some testing code available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/test_ratmod.dats"
TARGET="_top"
>on-line</A
> that makes
use of some functions declared in <TT
CLASS="filename"
>ratmod.sats</TT
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_a_functorial_package_for_rationals"
>Example: A Functorial Package for Rationals</A
></H2
><P
>&#13;The previous package for rational numbers contains a serious limitation:
The type for the integers employed in the representation of rational
numbers is fixed to be <FONT
COLOR="RED"
>int</FONT
>. If we ever want to represent
rational numbers based on integers of a different type (for instance,
<FONT
COLOR="RED"
>lint</FONT
> for long integers or <FONT
COLOR="RED"
>llint</FONT
> for long long
integers), then we need to implement another package for rationals based on
such integers. It is clearly advantageous to avoid this style of
programming as it involves code duplication to a great extent.  </P
><P
>&#13;The approach I employ in this section to implement a package for rational
numbers that can address the aforementioned limitation follows the idea of
functors in the programming language Standard ML (SML). Let us first
introduce a type definition as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1989"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span>
<span class="staexp">intmod <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  <span class="stalab">ofint</span><span class="keyword">=</span> <span class="staexp">int</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span>
<span class="keyword">,</span> <span class="stalab">fprint</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span>
<span class="keyword">,</span> <span class="stalab">neg</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// negation</span>
<span class="keyword">,</span> <span class="stalab">add</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// addition</span>
<span class="keyword">,</span> <span class="stalab">sub</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// subtraction</span>
<span class="keyword">,</span> <span class="stalab">mul</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// multiplication</span>
<span class="keyword">,</span> <span class="stalab">div</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// division</span>
<span class="keyword">,</span> <span class="stalab">mod</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// modulo operation</span>
<span class="keyword">,</span> <span class="stalab">cmp</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span> <span class="comment">// comparison</span>
<span class="keyword">}</span></span> <span class="comment">// end of [intmod]</span>
</p></PRE
><P
></P
></DIV
>


Given a type T, <FONT
COLOR="RED"
>intmod(T)</FONT
> is a boxed record type in which each
field is a function type. A value of the type <FONT
COLOR="RED"
>intmod(T)</FONT
> is
supposed to represent a module of integer operations on integers
represented by values of the type T. Similarly, let us introduce another
type definition as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1993"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">abst@ype</span> rat<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>a<span class="keyword">,</span> a<span class="keyword">)</span></span>

<span class="keyword">typedef</span>
<span class="staexp">ratmod <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  <span class="stalab">make</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span>
<span class="keyword">,</span> <span class="stalab">fprint</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">,</span> <span class="stalab">numer</span><span class="keyword">=</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// numerator</span>
<span class="keyword">,</span> <span class="stalab">denom</span><span class="keyword">=</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">a</span> <span class="comment">// denominator</span>
<span class="keyword">,</span> <span class="stalab">neg</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="comment">// negation</span>
<span class="keyword">,</span> <span class="stalab">add</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="comment">// addition</span>
<span class="keyword">,</span> <span class="stalab">sub</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="comment">// subtraction</span>
<span class="keyword">,</span> <span class="stalab">mul</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="comment">// multiplication</span>
<span class="keyword">,</span> <span class="stalab">div</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">rat</span> <span class="staexp">a</span> <span class="comment">// division</span>
<span class="keyword">,</span> <span class="stalab">cmp</span><span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rat</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="comment">// comparison</span>
<span class="keyword">}</span></span> <span class="comment">// end of [ratmod]</span>
</p></PRE
><P
></P
></DIV
>


Given a type T, a value of the type <FONT
COLOR="RED"
>ratmod(T)</FONT
> is supposed to
represent a module of rational operations on rationals represented by
values of the type <FONT
COLOR="RED"
>rat(T)</FONT
>. The function we need to implement can
now be given the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1997"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ratmod_make_intmod <span class="keyword">(</span>int<span class="keyword">:</span> <span class="staexp">intmod</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ratmod</span> <span class="staexp">a</span></span>
</p></PRE
><P
></P
></DIV
>


If applied to a given module of integer operations,
<FONT
COLOR="RED"
>ratmod_make_intmod</FONT
> returns a module of rational operations such
that the integers in the former and the latter modules have the same
representation. Therefore, <FONT
COLOR="RED"
>ratmod_make_intmod</FONT
> behaves like a
functor in SML.  In the following code, let us implement two modules
<FONT
COLOR="RED"
>ratmod_int</FONT
> and <FONT
COLOR="RED"
>ratmod_dbl</FONT
> of rational operations in
which integers are represented as values of the types <FONT
COLOR="RED"
>int</FONT
> and
<FONT
COLOR="RED"
>double</FONT
>, respectively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2005"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">staload</span> M <span class="keyword">=</span> "libc/SATS/math.sats"

<span class="dynexp"><span class="keyword">val</span> ratmod_int <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> intmod_int <span class="keyword">=</span> <span class="keyword">'{</span>
  <span class="dynlab">ofint</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=&gt;</span> i
<span class="keyword">,</span> <span class="dynlab">fprint</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>out<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp"><span class="keyword">$extfcall</span> <span class="keyword">(</span>void<span class="keyword">,</span> "fprintf"<span class="keyword">,</span> out<span class="keyword">,</span> "%i"<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="keyword">,</span> <span class="dynlab">neg</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">~</span>x
<span class="keyword">,</span> <span class="dynlab">add</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x + y
<span class="keyword">,</span> <span class="dynlab">sub</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x - y
<span class="keyword">,</span> <span class="dynlab">mul</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x * y
<span class="keyword">,</span> <span class="dynlab">div</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x / y
<span class="keyword">,</span> <span class="dynlab">mod</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">op</span> mod <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span>
<span class="keyword">,</span> <span class="dynlab">cmp</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> compare <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span>
<span class="keyword">}</span> <span class="keyword">:</span> <span class="staexp">intmod</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span></span> <span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  ratmod_make_intmod&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>intmod_int<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [val]</span>

<span class="dynexp"><span class="keyword">val</span> ratmod_dbl <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> intmod_dbl <span class="keyword">=</span> <span class="keyword">'{</span>
  <span class="dynlab">ofint</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=&gt;</span> g0i2f<span class="keyword">(</span>i<span class="keyword">)</span>
<span class="keyword">,</span> <span class="dynlab">fprint</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>out<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp"><span class="keyword">$extfcall</span> <span class="keyword">(</span>void<span class="keyword">,</span> "fprintf"<span class="keyword">,</span> out<span class="keyword">,</span> "%0.f"<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="keyword">,</span> <span class="dynlab">neg</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">~</span>x
<span class="keyword">,</span> <span class="dynlab">add</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x + y
<span class="keyword">,</span> <span class="dynlab">sub</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x - y
<span class="keyword">,</span> <span class="dynlab">mul</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x * y
<span class="keyword">,</span> <span class="dynlab">div</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> $M<span class="keyword">.</span>trunc <span class="keyword">(</span>x / y<span class="keyword">)</span> <span class="comment">// truncation</span>
<span class="keyword">,</span> <span class="dynlab">mod</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> $M<span class="keyword">.</span>fmod <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span>
<span class="keyword">,</span> <span class="dynlab">cmp</span><span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> compare <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span>
<span class="keyword">}</span> <span class="keyword">:</span> <span class="staexp">intmod</span> <span class="keyword">(</span><span class="staexp">double</span><span class="keyword">)</span></span> <span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  ratmod_make_intmod&lt;<span class="staexp">double</span><span class="keyword">&gt;</span> <span class="keyword">(</span>intmod_dbl<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [ratmod_dbl]</span>
</p></PRE
><P
></P
></DIV
>


An implementation of the function <FONT
COLOR="RED"
>ratmod_make_intmod</FONT
> is
available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/ratfun.dats"
TARGET="_top"
>on-line</A
> and there
is some related testing code available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_MODULARITY/test_ratfun.dats"
TARGET="_top"
>on-line</A
> as well.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="Cinteraction"
></A
>Chapter 8. Interaction with C</H1
><P
>&#13;ATS and C share precisely the same native/flat/unboxed data representation.
As a consequence, there is no need for wrapping/unwrapping or
boxing/unboxing when calling from C a function implemented in ATS or vice
versa, and there is also no run-time overhead for doing so. To a large
extent, ATS can be considered a front-end to C that is equipped with a
highly expressive type system (for specifying program invariants) and a
highly adaptable template system (for facilitating code reuse). In
particular, ATS can often be effectively employed to turn a large task into
subtasks of coherent interfaces, which can be implemented in ATS, C or some
other langauges and then assembled together to form a solution to the orginal
task.
</P
><P
>&#13;As can be expected, C code that appears directly in ATS does not go
through the kind of rigorous typechecking like ATS code should. So it is
recommended that the programmer be extra cautious when making direct use of
C code inside ATS code. In practice, my own experience clearly indicates
that the portion of C code inside my ATS code is highly likely to be the
culprit for most of encountered bugs.

</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_CINTERACT/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="external_name"
>External Global Names</A
></H2
><P
>&#13;A function declared in ATS can be given a global name of C-style so as to
allow the function to appear in both ATS code and C code.  In particular,
the function can be implemented in ATS and called in C or vice versa.
</P
><P
>&#13;In the following code, we see that two functions are declared:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2020"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "ext#fact2_in_c"</span>
</p></PRE
><P
></P
></DIV
>


The first function <FONT
COLOR="RED"
>fact</FONT
> does not have a global name while the
second function <FONT
COLOR="RED"
>fact2</FONT
> is assigned a global name
<FONT
COLOR="RED"
>fact2_in_c</FONT
>.  The symbol <FONT
COLOR="RED"
>ext#</FONT
> indicates that
<FONT
COLOR="RED"
>fact2_in_c</FONT
> is treated as a global function in C and its
prototype needs to be declared (via the <FONT
COLOR="RED"
>extern</FONT
> keyword) before
it can be called. If <FONT
COLOR="RED"
>ext#</FONT
> is written in place of
<FONT
COLOR="RED"
>ext#fact2_in_c</FONT
> in the above declaration, then the global name
for the function <FONT
COLOR="RED"
>fact2</FONT
> in ATS is assumed to be same as the name
of the function in ATS. In other words, writing <FONT
COLOR="RED"
>ext#</FONT
> in the
above declaration is equivalent to writing <FONT
COLOR="RED"
>ext#fact2</FONT
>.

</P
><P
>&#13;Let us assume that <FONT
COLOR="RED"
>fact</FONT
> can be implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2035"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> fact <span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> fact2 <span class="keyword">(</span>n<span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


When compiling this implementation, the ATS compiler needs to form function
names in the generated C code to refer to <FONT
COLOR="RED"
>fact</FONT
> and
<FONT
COLOR="RED"
>fact2</FONT
>.  For the former, the function name in the C code is
determined by a set of rules (which take into account the issue of
namespace).  For the latter, the function name is simply chosen to be the
assigned global name <FONT
COLOR="RED"
>fact2_in_c</FONT
>. As is suggested by the name of
<FONT
COLOR="RED"
>fact2_in_c</FONT
>, this function can be directly implemented in C as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2041"
></A
><PRE
CLASS="programlisting"
>&#13;int
fact2_in_c (int n, int res)
{
  while (n &#62; 0) { res *= n ; n -= 1 ; } ; return res ;
}
</PRE
><P
></P
></DIV
>

It is also allowed to implement <FONT
COLOR="RED"
>fact2</FONT
> in ATS
directly as is shown below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2044"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
fact2 <span class="keyword">(</span>n<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> fact2 <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">,</span> n*res<span class="keyword">)</span> <span class="keyword">else</span> res</span>
</p></PRE
><P
></P
></DIV
>


This implementation of <FONT
COLOR="RED"
>fact2</FONT
> can be called in C
through the name <FONT
COLOR="RED"
>fact2_in_c</FONT
>.
</P
><P
>&#13;If both <FONT
COLOR="RED"
>fact2</FONT
> and <FONT
COLOR="RED"
>fact2_in_c</FONT
> are implemented (the
former in ATS and the latter in C), then a link-time error is to be
issued to indicate that <FONT
COLOR="RED"
>fact2_in_c</FONT
> is implemented repeatedly.
</P
><P
>&#13;One can also declare <FONT
COLOR="RED"
>fact2</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2054"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#fact2_in_c"</span>
</p></PRE
><P
></P
></DIV
>


The symbol <FONT
COLOR="RED"
>mac#</FONT
> indicates that <FONT
COLOR="RED"
>fact2_in_c</FONT
> is
treated like a macro in C. In particular, <FONT
COLOR="RED"
>fact2_in_c</FONT
> can be
called without its prototype being declared first. As a matter of fact, it
may not even have a prototype. This style of declaration naturally expects
<FONT
COLOR="RED"
>fact2_in_c</FONT
> to be implemented in C directly.
</P
><P
>&#13;It is also allowed to use <FONT
COLOR="RED"
>sta#</FONT
> in place of <FONT
COLOR="RED"
>mac#</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2063"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "sta#fact2_in_c"</span>
</p></PRE
><P
></P
></DIV
>


If declared in this style, which only occurs rarely in practice,
then <FONT
COLOR="RED"
>fact2_in_c</FONT
> is treated like a static function in C.
</P
><P
>&#13;For the sake of completeness, I mention as follows another way of declaring
a static function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2067"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">static</span> <span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


This style of declaration is automatically translated into the following one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2069"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "sta#"</span>
</p></PRE
><P
></P
></DIV
>


where the use of <FONT
COLOR="RED"
>sta#</FONT
> means that the name referring to <FONT
COLOR="RED"
>fact2</FONT
>
in C is simply <FONT
COLOR="RED"
>fact2</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="external_types_and_values"
>External Types and Values in ATS</A
></H2
><P
>&#13;External types and values can be readily formed in ATS to refer to types
and values declared in C.

</P
><P
>&#13;Suppose that there is a type in C of the name <FONT
COLOR="RED"
>some_type_in_c</FONT
>,
then this type can be referred to in ATS as
<FONT
COLOR="RED"
>$extype"some_type_in_c"</FONT
>. For instance, type definitions are
introduced in the following code for some external types in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2080"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">Cint <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extype</span>"int"</span></span>
<span class="keyword">typedef</span> <span class="staexp">Clint <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extype</span>"long int"</span></span>
<span class="keyword">typedef</span> <span class="staexp">Cllint <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extype</span>"long long int"</span></span>
<span class="keyword">typedef</span> <span class="staexp">Cint2 <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extype</span>"struct{ int x; int y; }"</span></span>
</p></PRE
><P
></P
></DIV
>


Suppose that there is a value in C of the name <FONT
COLOR="RED"
>some_value_in_c</FONT
>,
then this value can be referred to in ATS as <FONT
COLOR="RED"
>$extval(<FONT
COLOR="RED"
>T</FONT
>, "some_value_in_c")</FONT
>,
where T is a type in ATS assigned to this value.  For instance, macro
definitions are introduced in the following code for some external values
in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2085"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">macdef</span> NULL <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>ptr<span class="keyword">,</span> "0"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> stdin_ref <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>FILEref<span class="keyword">,</span> "stdin"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> stdout_ref <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>FILEref<span class="keyword">,</span> "stdout"<span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


External values can also be formed to refer to functions in C as done
in the following code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2087"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">macdef</span> atoi <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>string <span class="keyword">-&gt;</span> int<span class="keyword">,</span> "atoi"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> atol <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>string <span class="keyword">-&gt;</span> lint<span class="keyword">,</span> "atol"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> atof <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>string <span class="keyword">-&gt;</span> double<span class="keyword">,</span> "atof"<span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


Note that there are other ways in ATS that are often more approriate for
directly referring to functions in C.  Typically, the primary purpose of
forming an external value in ATS is to allow a constant declared in C to be
directly referred to in ATS code.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="inclusion_of_external_code"
>Inclusion of External Code in ATS</A
></H2
><P
>&#13;Just like including assembly code inside C code, it is straightforward to
include C code inside ATS code. For instance, the example appearing at the
beginning of this chapter can be written as follows in a single file:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2092"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "ext#fact2_in_c"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span> fact <span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> fact2 <span class="keyword">(</span>n<span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="extcode"><span class="extcode">%{
int
fact2_in_c (int n, int res)
{
  while (n &gt; 0) { res *= n ; n -= 1 ; } ; return res ;
}
%}</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For C code to appear inside ATS code, it needs to enclosed by the symbols
<FONT
COLOR="RED"
>%{</FONT
> (opening) and <FONT
COLOR="RED"
>%}</FONT
> (closing). Essentially,
whatever code appearing between these two symbols is pasted into the
generated C code at an unspecified position. If the enclosed code is
intended to be put at the beginning of the generated C code, then the
symbol <FONT
COLOR="RED"
>%{^</FONT
> should be used in place of <FONT
COLOR="RED"
>%{</FONT
>.  If the
enclosed code is intended to be put at the bottom of the generated C code,
then the symbol <FONT
COLOR="RED"
>%{$</FONT
> should be used in place of <FONT
COLOR="RED"
>%{</FONT
>.

</P
><P
>&#13;It is also allowed to put C code between the symbols
<FONT
COLOR="RED"
>%{#</FONT
> and <FONT
COLOR="RED"
>%}</FONT
>. Suppose that there is a file of the
name <TT
CLASS="filename"
>foo.sats</TT
> that contains C code included in this manner.
If <TT
CLASS="filename"
>foo.sats</TT
> is staloaded in another file of the name
<TT
CLASS="filename"
>foo.dats</TT
>, then the lines between <FONT
COLOR="RED"
>%{#</FONT
> and
<FONT
COLOR="RED"
>%}</FONT
> in <TT
CLASS="filename"
>foo.sats</TT
> are pasted into the C code
generated from compiling <TT
CLASS="filename"
>foo.dats</TT
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="calling_external_functions"
>Calling External Functions in ATS</A
></H2
><P
>&#13;It is straightforward to make calls to external functions in ATS.
For instance, the following code demonstrates a typical way to do so:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2113"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">local</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> __fprintf
  <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">,</span> <span class="staexp">string</span><span class="comment">(*fmt*)</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#fprintf"</span>
<span class="keyword">in</span> <span class="comment">(* in of [local] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">12</span></span>
<span class="dynexp"><span class="keyword">val</span> _ <span class="keyword">=</span> __fprintf <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> <span class="dynstr">"fact(%i) = %i\n"</span><span class="keyword">,</span> N<span class="keyword">,</span> fact<span class="keyword">(</span>N<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</p></PRE
><P
></P
></DIV
>


where the function <FONT
COLOR="RED"
>fprintf</FONT
> (declared in <TT
CLASS="filename"
>stdio.h</TT
>)
is given a (local) name <FONT
COLOR="RED"
>__fprintf</FONT
> and an interface appropriate
for the call to be made.

</P
><P
>&#13;There is also built-in support for calling external functions in ATS directly.
For instance, the following code does essentially the same as the code
presented above:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2119"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">12</span></span>
<span class="dynexp"><span class="keyword">val</span> _ <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extfcall</span><span class="keyword">(</span>int<span class="keyword">,</span> "fprintf"<span class="keyword">,</span> stdout_ref<span class="keyword">,</span> "fact(%i) = %i\n"<span class="keyword">,</span> N<span class="keyword">,</span> fact<span class="keyword">(</span>N<span class="keyword">)</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


When <FONT
COLOR="RED"
>$extfcall</FONT
> is employed to make an external function call,
its first argument is the return type of the call, and its second argument
is the name of the called function (represented as a string), and its rest
of arguments are the arguments of the called function.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="unsafe_c-style_programming_in_ats"
>Unsafe C-style Programming in ATS</A
></H2
><P
>&#13;ATS is probably not a programming language easy for one to write code in.
While ATS provides many features to support safe (low-level) programming,
it may take a long time and some great efforts for a programmer to learn
and then master these features before he or she can make effective use of
them.  In this section, I would like to present some ATS code written in
C-style that makes typical use of certain unsafe programming features in
ATS. This is a programming style that should be familiar to any programmer
who can write C code competently.

</P
><P
>&#13;There are always occasions where one may find it sensible to program in
unsafe C-style. Sometimes, one just wants to get a running implementation
and then relies on testing to detect and fix bugs. Sometimes, one simply
does not know enough of ATS needed to implement a function in a safe
programming manner. This list of occasions can be readily extended as one
wishes. I myself do unsafe C-style programming in ATS frequently, and I see
it as a necessary skill for anyone who not just only wants to be able to
write code in ATS but also wants to do it highly productively. Let us now
see a concrete example of unsafe C-style programming in ATS.

</P
><P
>&#13;Suppose that we want to implement a function for comparing two given
strings according to the standard lexicographic ordering. Let us name
the function <FONT
COLOR="RED"
>strcmp</FONT
> and give it the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2128"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> strcmp <span class="keyword">(</span>str1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> str2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


Given two strings <FONT
COLOR="RED"
>str1</FONT
> and <FONT
COLOR="RED"
>str2</FONT
>,
<FONT
COLOR="RED"
>strcmp(str1, str2)</FONT
> is expected to return 1, -1, and 0 if
<FONT
COLOR="RED"
>str1</FONT
> is greater than, less than, and equal to <FONT
COLOR="RED"
>str2</FONT
>,
respectively. An implementation of <FONT
COLOR="RED"
>strcmp</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2136"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
strcmp <span class="keyword">(</span>str1<span class="keyword">,</span> str2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop
<span class="keyword">(</span>
  p1<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> c1 <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">uchar</span><span class="keyword">&gt;</span><span class="keyword">(</span>p1<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> c2 <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">uchar</span><span class="keyword">&gt;</span><span class="keyword">(</span>p2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> c1 <span class="keyword">&gt;</span> c2 <span class="keyword">=&gt;</span>  <span class="dynexp">1</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> c1 <span class="keyword">&lt;</span> c2 <span class="keyword">=&gt;</span> <span class="keyword">~</span><span class="dynexp">1</span>
  <span class="keyword">|</span> _ <span class="comment">(* c1 = c2 *)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>
      <span class="keyword">if</span> $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span><span class="keyword">(</span>c1<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span>
        <span class="keyword">then</span> <span class="dynexp">0</span> <span class="keyword">else</span> loop <span class="keyword">(</span>ptr0_succ&lt;<span class="staexp">uchar</span><span class="keyword">&gt;</span><span class="keyword">(</span>p1<span class="keyword">)</span><span class="keyword">,</span> ptr0_succ&lt;<span class="staexp">uchar</span><span class="keyword">&gt;</span><span class="keyword">(</span>p2<span class="keyword">)</span><span class="keyword">)</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>string2ptr<span class="keyword">(</span>str1<span class="keyword">)</span><span class="keyword">,</span> string2ptr<span class="keyword">(</span>str2<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [strcmp] *)</span>
</p></PRE
><P
></P
></DIV
>


For a programmer familar with C, the above implementation of
<FONT
COLOR="RED"
>strcmp</FONT
> should be easily accessible.  There are a variety of
unsafe functions declared in <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/unsafe.sats"
TARGET="_top"
>unsafe.sats</A
>. Given a type T and a pointer p, <FONT
COLOR="RED"
>ptr0_get&#60;T&#62;(p)</FONT
>
fetches the value of the type T stored at the location to which p
points.  Note that <FONT
COLOR="RED"
>ptr0_get</FONT
> is inherently unsafe as there is
simply no guarantee that p actually points to a valid memory location where
a value of the type T is stored.  The function <FONT
COLOR="RED"
>cast</FONT
>, which is
also inherently unsafe, casts the type of a given value into any chosen
type.  The function template <FONT
COLOR="RED"
>ptr0_succ</FONT
>, which is declared in
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/pointer.sats"
TARGET="_top"
>pointer.sats</A
>, is
type-safe. Given a type T, <FONT
COLOR="RED"
>ptr0_succ&#60;T&#62;(p)</FONT
> returns the
pointer that is n bytes after p, where n equals the size of T.

</P
><P
>&#13;Please find the entire code for this example
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_CINTERACT/strcmp.dats"
TARGET="_top"
>on-line</A
>.

</P
><P
>&#13;For a function like <FONT
COLOR="RED"
>strcmp</FONT
>, one can readily implement it in C
directly. For instance, an implementation of <FONT
COLOR="RED"
>strcmp</FONT
> in C, which
is essentially a translation of the above implementation of <FONT
COLOR="RED"
>strcmp</FONT
>
in ATS, is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2152"
></A
><PRE
CLASS="programlisting"
>int strcmp (char *p1, char *p2)
{
  int res ;
  unsigned char c1, c2;
  while (1)
  {
    c1 = *p1; c2 = *p2;
    if (c1 &#62; c2) { res =  1; break; } ;
    if (c1 &#60; c2) { res = -1; break; } ;
    if ((int)c1==0) { res = 0 ; break ; } else { p1++; p2++; } ;
  }
  return res ;
}
</PRE
><P
></P
></DIV
>


However, writing ATS code in C-style can often have advantages over writing
C code directly. For instance, there is direct support in ATS but not in C
for implementing function templates.  In C, one is essentially forced to
rely on rather involved use of macros to implement function templates,
which makes the code not only difficult to follow but also notoriously
error-prone. Let us now see as follows a function template implementation
in ATS that is partly type-unsafe.

</P
><P
>&#13;Suppose we want a function for copying into a given array the elements
stored in a list. Let us name the function <FONT
COLOR="RED"
>array_copy_from_list</FONT
>
and give it the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2156"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
array_copy_from_list <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">array0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Given a type T, <FONT
COLOR="RED"
>array0(T)</FONT
> is for an array0-value containing a
pointer p and a size n such that p points to a C-style array storing n
elements of the type T.

</P
><P
>&#13;For the moment, let us require that the size of the array A equals the
length of the list xs when <FONT
COLOR="RED"
>array_copy_from_list(A, xs)</FONT
> is
called.  Following is an implementation of <FONT
COLOR="RED"
>array_copy_from_list</FONT
>
in ATS that makes use of an unsafe function (<FONT
COLOR="RED"
>ptr0_set</FONT
>) declared
in <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/unsafe.sats"
TARGET="_top"
>unsafe.sats</A
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2164"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
array_copy_from_list
  <span class="keyword">(</span>A<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_set&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p<span class="keyword">,</span> x<span class="keyword">)</span></span> <span class="keyword">in</span> loop <span class="keyword">(</span>ptr0_succ&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p<span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list0_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>array0_get_ref<span class="keyword">(</span>A<span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_copy_from_list]</span>
</p></PRE
><P
></P
></DIV
>


Given a type T, a pointer p, and a value x of the type T,
<FONT
COLOR="RED"
>ptr0_set&#60;T&#62;(p, x)</FONT
> stores the value x at the location to
which p points.  Like <FONT
COLOR="RED"
>ptr0_get</FONT
>, <FONT
COLOR="RED"
>ptr0_set</FONT
> is
inherently unsafe as there is simply no guarantee that p actually points to
a valid memory location where a value of the type T can be stored.  The
function <FONT
COLOR="RED"
>array0_get_ref</FONT
>, which is declared in
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/libats/ML/SATS/array0.sats"
TARGET="_top"
>array0.sats</A
>, returns the
pointer to the C-style array associated with a given array0-value.

</P
><P
>&#13;Please find the entire code for this example
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_CINTERACT/ArrayCopyFromList.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="exporting_types_and_values"
>Exporting Types in ATS for Use in C</A
></H2
><P
>&#13;There is also support in ATS for exporting types to make them available for
use in C directly. In the following example, a typedef of the name
<FONT
COLOR="RED"
>int_and_string</FONT
> is expected to be declared in the generated C
code for values that are assigned the type <FONT
COLOR="RED"
>(int, string)</FONT
> in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2178"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="extcode"><span class="keyword">typedef</span> "int_and_string" <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">string</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Essentially, <FONT
COLOR="RED"
>int_and_string</FONT
> is defined in C as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2181"
></A
><PRE
CLASS="programlisting"
>typedef
struct {
  int atslab__0; void *atslab__1; 
} int_and_string ;
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;Sometimes, we want to construct in C values of a datatype declared in ATS.
For instance, let us try to construct a value of the form
<FONT
COLOR="RED"
>cons2(i, d)</FONT
> in C for an integer i and a double d, where
<FONT
COLOR="RED"
>cons2</FONT
> is a data constructor associated with the following
declared datatype <FONT
COLOR="RED"
>abc</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2187"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span> <span class="staexp">abc <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">cons1 <span class="keyword">of</span> <span class="staexp">int</span></span> <span class="keyword">|</span> <span class="dynexp">cons2 <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">double</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


Whenever a data constructor is declared, a corresponding (linear) type
constructor is created whose name equals the concatenation of the name of
the data constructor and the string "_pstruct". So in the case of the above
declared datatype <FONT
COLOR="RED"
>abc</FONT
>, the type constructors
<FONT
COLOR="RED"
>cons1_pstruct</FONT
> and <FONT
COLOR="RED"
>cons2_pstruct</FONT
> are created, and
these type constructors can be used to form types for boxed values
constructed with the data constructors <FONT
COLOR="RED"
>cons1</FONT
> and <FONT
COLOR="RED"
>cons2</FONT
>.

</P
><P
>&#13;In the following declaration,
the type <FONT
COLOR="RED"
>cons2_pstruct(int, double)</FONT
> in ATS
is exported to C under the name <FONT
COLOR="RED"
>cons2_node</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2197"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="extcode"><span class="keyword">vtypedef</span> "cons2_node" <span class="keyword">=</span> <span class="staexp">cons2_pstruct</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">double</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Implicitly, a typedef in C of the name <FONT
COLOR="RED"
>cons2_node_</FONT
> is also
introduced for the unboxed portion of a value constructed with the data
constructor <FONT
COLOR="RED"
>cons2</FONT
>. Essentially, we have the following generated
code in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2201"
></A
><PRE
CLASS="programlisting"
>typedef
struct {
int contag ; // constructor tag
int atslab__0; double atslab__1; 
} cons2_node_ ;
typedef cons2_node_ *cons2_node ;
</PRE
><P
></P
></DIV
>


It is now straightforward to create a value of the form <FONT
COLOR="RED"
>cons2(i,d)</FONT
> in C directly:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2204"
></A
><PRE
CLASS="programlisting"
>cons2_node
cons2_make
(
  int i, double d
) {
  cons2_node p ;
  p = ATS_MALLOC(sizeof(cons2_node_)) ;
  p-&#62;contag = 1 ;
  p-&#62;atslab__0 = i ;
  p-&#62;atslab__1 = d ;
  return p ;
} /* end of [cons2_make] */
</PRE
><P
></P
></DIV
>


Note that the tags for <FONT
COLOR="RED"
>cons1</FONT
> and <FONT
COLOR="RED"
>cons2</FONT
> are 0 and 1,
respectively, as <FONT
COLOR="RED"
>cons1</FONT
> and <FONT
COLOR="RED"
>cons2</FONT
> are the first and
second constructors associated with the datatype <FONT
COLOR="RED"
>abc</FONT
>.

</P
><P
>&#13;By assigning an interface to <FONT
COLOR="RED"
>cons2_make</FONT
> in ATS, we can readily
check whether <FONT
COLOR="RED"
>cons2_make</FONT
> behaves as expected:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2214"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
cons2_make<span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">abc</span> <span class="keyword">=</span> "mac#"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val-</span>cons2<span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2.34</span><span class="keyword">)</span> <span class="keyword">=</span> cons2_make<span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2.34</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;In general, it is essential for a pragrammer to acquire a solid
understanding of low-level data representation of a programming language in
order to use that language in low-level systems programming. The low-level
data representation of ATS can be readily explained in terms of types in C,
making it straightforward, when needed, to construct and manipulate
ATS-values in C directly.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example-constructing_a_statically_allocated_list"
>Example: Constructing a Statically Allocated List</A
></H2
><P
>&#13;In embedded programming, static memory allocation is often preferred
due to dynamic memory allocation being less predictable.  I present as
follows an example in which a list is constructed with statically allocated
memory. This example also strongly attests to ATS and C being intimately
related.

</P
><P
>&#13;In order to statically allocate memory for list-nodes, we need to first
form a type for list-nodes so that we can inform the C compiler how
much memory is needed for each list-node. In the following code, the type
<FONT
COLOR="RED"
>list_node</FONT
> in ATS is for boxed list-nodes, and this type is
exported to C under the same name:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2222"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">list_node <span class="keyword">=</span>
<span class="staexp">list_cons_pstruct</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span><span class="staexp">ptr</span><span class="keyword">)</span></span> <span class="comment">// [list_node] for boxed nodes</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="extcode"><span class="keyword">vtypedef</span> "list_node" <span class="keyword">=</span> <span class="staexp">list_node</span></span> <span class="comment">// exporting [list_node] to C</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Exporting <FONT
COLOR="RED"
>list_node</FONT
> to C also introduces (implicitly) a
typedef <FONT
COLOR="RED"
>list_node_</FONT
> in C for unboxed list-nodes. So the
following type <FONT
COLOR="RED"
>list_node_</FONT
> in ATS is precisely what we want
(for unboxed list-nodes):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2227"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">list_node_ <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extype</span>"list_node_"</span></span> <span class="comment">// [list_node_] for unboxed nodes</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The following code statically allocates an array of list-nodes and then
initialize these nodes, turning the array into a list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2230"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">local</span>

<span class="neuexp"><span class="keyword">#define</span> N 10</span>

<span class="comment">(*
** static allocation
*)</span>
<span class="keyword">var</span> nodes <span class="keyword">=</span> <span class="dynexp"><span class="keyword">@[</span>list_node_<span class="keyword">]</span><span class="keyword">[</span>N<span class="keyword">]</span><span class="keyword">(</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> i <span class="keyword">&lt;</span> N <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>list_node<span class="keyword">}</span></span><span class="keyword">(</span>p<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val+</span>list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> res</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
  <span class="keyword">)</span> <span class="keyword">=</span> x := i*i</span>
  <span class="dynexp"><span class="keyword">val</span> p <span class="keyword">=</span> ptr_succ&lt;<span class="staexp">list_node_</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> i + <span class="dynexp">1</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> N <span class="keyword">then</span> xs := p <span class="keyword">else</span> xs := the_null_ptr
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> _<span class="comment">(*ptr*)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>ptr<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>x</span><span class="keyword">,</span> <span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>xs</span> <span class="keyword">|</span> res<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>

<span class="keyword">in</span> <span class="comment">(* in of [local] *)</span>

<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span>nodes<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs_static <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>list<span class="keyword">(</span>int<span class="keyword">,</span>N<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>nodes</span><span class="keyword">|</span><span class="dynexp"><span class="keyword">addr@</span></span>nodes<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"xs_static = "</span><span class="keyword">,</span> xs_static<span class="keyword">)</span></span> <span class="comment">// 0, 1, 4, 9, 16, ...</span>

<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</p></PRE
><P
></P
></DIV
>


The implementation of <FONT
COLOR="RED"
>loop</FONT
> makes extensive use of
unsafe C-style programming in ATS. For someone familiar with C, it
should be straightforward to visualize the C code that corresponds to
this implementation directly.
</P
><P
>&#13;Please find the entire code for this example
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_CINTERACT/StaticAllocList.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="programming-with-dependent-types"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
>III. Programming with Dependent Types</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>9. <A
HREF="#introduction-to-dependent-types"
>Introduction to Dependent Types</A
></DT
><DT
>10. <A
HREF="#datatype_refinement"
>Datatype Refinement</A
></DT
><DT
>11. <A
HREF="#theorem-proving_in_ats_lf"
>Theorem-Proving in ATS/LF</A
></DT
><DT
>12. <A
HREF="#programming_with_theorem-proving"
>Programming with Theorem-Proving</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="introduction-to-dependent-types"
></A
>Chapter 9. Introduction to Dependent Types</H1
><P
>&#13;The types we have encountered so far in this book are often not adequately
precise in capturing programming invariants. For instance, if we assign the
type <FONT
COLOR="RED"
>int</FONT
> to both of integers 0 and 1, then we simply cannot
distinguish 0 from 1 at the level of types. This means that 0 and 1 are
interchangeable as far as typechecking is concerned. In other words, we
cannot expect a program error to be caught during typechecking if the error
is caused by 0 being mistyped as 1. This form of imprecision in types can
become a crippling limitation if we ever want to build a type-based
specification language that is reasonably expressive for practical use.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPTYPES/"
TARGET="_top"
>on-line</A
>
the code employed for illustration in this chapter plus some additional
code for testing.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="enhanced_expressiveness_for_specification"
>Enhanced Expressiveness for Specification</A
></H2
><P
>&#13;The primary purpose of introducing dependent types into the type system of
ATS is to greatly enhance the expressiveness of types so that they can be
employed to capture program invariants with much greater precision.
Generally speaking, dependent types are types dependent on values of
expressions. For instance, <FONT
COLOR="RED"
>bool</FONT
> is a type constructor in ATS
that forms a type <FONT
COLOR="RED"
>bool(b)</FONT
> when applied to a given boolean value
b. As this type can only be assigned to a boolean expression of the value
b, it is often referred to as a singleton type, that is, a type for exactly
one value. Clearly, the meaning of <FONT
COLOR="RED"
>bool(b)</FONT
> depends on the
boolean value b.  Similarly, <FONT
COLOR="RED"
>int</FONT
> is a type constructor in ATS
that forms a type <FONT
COLOR="RED"
>int(i)</FONT
> when applied to a given integer
i. This type is also a singleton type as it can only be assigned to an
integer expression of the value i. Please note that both <FONT
COLOR="RED"
>bool</FONT
>
and <FONT
COLOR="RED"
>int</FONT
> are overloaded as they also refer to (non-dependent)
types.  I will gradually introduce many other examples of dependent types.
In particular, I will present a flexible means for the programmer to
declare dependent datatypes.
</P
><P
>&#13;The statics of ATS is a simply-typed language, and the types in this
language are called <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>sorts</I
></SPAN
> so as to avoid some
potential confusion (with the types for dynamic terms). The following four
listed sorts are commonly used:

<P
></P
><UL
><LI
><P
>&#13;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>bool</I
></SPAN
>: for static terms of boolean values
</P
></LI
><LI
><P
>&#13;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
>: for static terms of integer values
</P
></LI
><LI
><P
>&#13;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type</I
></SPAN
>: for static terms representing boxed types (for dynamic terms)
</P
></LI
><LI
><P
>&#13;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
>: for static terms representing unboxed types (for dynamic terms)
</P
></LI
></UL
>

The sorts <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>bool</I
></SPAN
> and <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
> are classified as
predicative sorts while the sorts <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type</I
></SPAN
> and <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
>
are impredicative. A boxed type is a static term of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type</I
></SPAN
> while an unboxed type is a static term of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
>. As types, <FONT
COLOR="RED"
>bool</FONT
> and <FONT
COLOR="RED"
>int</FONT
> are
static terms of the sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
>. As type constructors,
<FONT
COLOR="RED"
>bool</FONT
> and <FONT
COLOR="RED"
>int</FONT
> are static terms of the sorts
(<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>bool -&#62; t@ype</I
></SPAN
>) and (<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int -&#62; t@ype</I
></SPAN
>),
respectively.  Also note that the type constructor <FONT
COLOR="RED"
>list0</FONT
> is of
the sort (<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype -&#62; type</I
></SPAN
>), which indicates that
<FONT
COLOR="RED"
>list0</FONT
> forms a boxed type when applied to an unboxed one.  There
are a variety of built-in static functions in ATS for constructing static
terms of the sorts <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>bool</I
></SPAN
> and <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
>, and I list as
follows some of these functions together with the sorts assigned to them:

<P
></P
><UL
><LI
><P
>&#13;~ (negation): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int) -&#62; int</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;+ (addition): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; int</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;- (subtraction): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; int</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;* (multiplication): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; int</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;/ (division): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; int</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#62; (greater-than): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#62;= (greater-than-or-equal-to): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#60; (less-than): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#60;= (less-than-or-equal-to): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;== (equal-to): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;!= (not-equal-to): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#60;&#62; (not-equal-to): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;~ (boolean negation): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(bool) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;|| (disjunction): <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(bool, bool) -&#62; bool</I
></SPAN
>
</P
></LI
><LI
><P
>&#13;&#38;&#38; (conjunction) : <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(bool, bool) -&#62; bool</I
></SPAN
>
</P
></LI
></UL
>

By combining a sort with one or more predicates, we can define a subset
sort. For instance, the following subset sorts are defined in the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/basics_pre.sats"
TARGET="_top"
>basics_pre.sats</A
>, which is
automatically loaded by the ATS compiler:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2333"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">sortdef</span> nat <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> a &gt;= 0<span class="keyword">}</span></span> <span class="comment">// for natural numbers</span>
<span class="staexp"><span class="keyword">sortdef</span> pos <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> a &gt;= 1<span class="keyword">}</span></span>  <span class="comment">// for positive numbers</span>
<span class="staexp"><span class="keyword">sortdef</span> neg <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> a &lt;= <span class="keyword">~</span>1<span class="keyword">}</span></span>  <span class="comment">// for negative numbers</span>

<span class="staexp"><span class="keyword">sortdef</span> nat1 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> nat <span class="keyword">|</span> a <span class="keyword">&lt;</span> 1<span class="keyword">}</span></span> <span class="comment">// for 0</span>
<span class="staexp"><span class="keyword">sortdef</span> nat2 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> nat <span class="keyword">|</span> a <span class="keyword">&lt;</span> 2<span class="keyword">}</span></span> <span class="comment">// for 0, 1</span>
<span class="staexp"><span class="keyword">sortdef</span> nat3 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> nat <span class="keyword">|</span> a <span class="keyword">&lt;</span> 3<span class="keyword">}</span></span> <span class="comment">// for 0, 1, 2</span>
<span class="staexp"><span class="keyword">sortdef</span> nat4 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> nat <span class="keyword">|</span> a <span class="keyword">&lt;</span> 4<span class="keyword">}</span></span> <span class="comment">// for 0, 1, 2, 3</span>
</p></PRE
><P
></P
></DIV
>


Note that predicates can be sequenced together with the semicolon
symbol (;) to form a conjunction:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2335"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">sortdef</span> nat2 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> 0 &lt;= a<span class="keyword">;</span> a <span class="keyword">&lt;</span> 2<span class="keyword">}</span></span> <span class="comment">// for 0, 1</span>
<span class="staexp"><span class="keyword">sortdef</span> nat3 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> 0 &lt;= a<span class="keyword">;</span> a <span class="keyword">&lt;</span> 3<span class="keyword">}</span></span> <span class="comment">// for 0, 1, 2</span>
<span class="staexp"><span class="keyword">sortdef</span> sgn <span class="keyword">=</span> <span class="keyword">{</span> i<span class="keyword">:</span>int <span class="keyword">|</span> <span class="keyword">~</span>1 &lt;= i<span class="keyword">;</span> i &lt;= 1 <span class="keyword">}</span></span> <span class="comment">// for ~1, 0, 1</span>
</p></PRE
><P
></P
></DIV
>


It is also possible to define the subset sorts <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>nat2</I
></SPAN
>
and <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>nat3</I
></SPAN
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2339"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">sortdef</span> nat2 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> a == 0 || a == 1<span class="keyword">}</span></span> <span class="comment">// for 0, 1</span>
<span class="staexp"><span class="keyword">sortdef</span> nat3 <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span> int <span class="keyword">|</span> 0 &lt;= a &amp;&amp; a &lt;= 2<span class="keyword">}</span></span> <span class="comment">// for 0, 1, 2</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>||</FONT
> and <FONT
COLOR="RED"
>&#38;&#38;</FONT
> stands for disjunction and
conjunction, respectively.

</P
><P
>In order to unleash the expressiveness of dependent types, we need
to employ both universal and existential quantification over static
variables. For instance, the type <FONT
COLOR="RED"
>Int</FONT
> in ATS is defined as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2345"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">Int <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>a<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// for unspecified integers</span>
</p></PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>[a:int]</FONT
> means existential quantification over
a static variable <FONT
COLOR="RED"
>a</FONT
> of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
>. Essentially, this means that for each value of
the type <FONT
COLOR="RED"
>Int</FONT
>, there exists an integer I such that the value is
of the type <FONT
COLOR="RED"
>int(I)</FONT
>. Therefore, any value that can be given the
type <FONT
COLOR="RED"
>int</FONT
> can also be given the type <FONT
COLOR="RED"
>Int</FONT
>. A type
like <FONT
COLOR="RED"
>Int</FONT
> is often referred to as an existentially quantified
type.  As another example, the type <FONT
COLOR="RED"
>Nat</FONT
> in ATS is defined as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2356"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">Nat <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>a<span class="keyword">:</span>int <span class="keyword">|</span> a &gt;= 0<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// for natural numbers</span>
</p></PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>[a:int | a &#62;= 0]</FONT
> means existential
quantification over a static variable <FONT
COLOR="RED"
>a</FONT
> of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
> that satisfies the constraint <FONT
COLOR="RED"
>a &#62;= 0</FONT
>.
Therefore, each value of the type <FONT
COLOR="RED"
>Nat</FONT
> can be assigned the type
<FONT
COLOR="RED"
>int(I)</FONT
> for some integer I satisfying I &#62;= 0. Given that
<FONT
COLOR="RED"
>int(I)</FONT
> is a singleton type, the value equals I and is thus a
natural number. This means that the type <FONT
COLOR="RED"
>Nat</FONT
> is for natural
numbers. The definition of <FONT
COLOR="RED"
>Nat</FONT
> can also be given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2367"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">Nat <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>a<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// for natural numbers</span>
</p></PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>[a:nat]</FONT
> is just a form of syntactic sugar that
automatically expands into <FONT
COLOR="RED"
>[a:int | a &#62;= 0]</FONT
>.
</P
><P
>At this point, types have already become much more expressive. For
instance, we could only assign the type <FONT
COLOR="RED"
>(int) -&#62; int</FONT
> to a
function that maps integers to natural numbers (e.g., the function that
computes the absolute value of a given integer), but we can now do better
by assigning it the type <FONT
COLOR="RED"
>(Int) -&#62; Nat</FONT
>, which is clearly more
precise. In order to relate at the level of types the return value of a
function to its arguments, we need universal quantification. For instance,
the following universally quantified type is for a function that returns
the successor of its integer argument:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2374"
></A
><PRE
CLASS="programlisting"
>{i:int} int (i) -&#62; int (i+1)
</PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>{i:int}</FONT
> means universal quantification over a
static variable <FONT
COLOR="RED"
>i</FONT
> of the sort <FONT
COLOR="RED"
>int</FONT
> and the scope
of this quantification is the function type following it.  One may think
that this function type is also a singleton type as the only function of
this type is the successor function on integers. Actually, there are
infinitely may partial functions that can be given this type as well.  For
the successor function on natural numbers, we can use the following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2379"
></A
><PRE
CLASS="programlisting"
>{i:int | i &#62;= 0} int (i) -&#62; int (i+1)
</PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>{i:int | i &#62;= 0}</FONT
> means universal
quantification over a static variable <FONT
COLOR="RED"
>i</FONT
> of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
> that satisfies the constraint <FONT
COLOR="RED"
>i &#62;= 0</FONT
>.
This type can also be written as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2385"
></A
><PRE
CLASS="programlisting"
>{i:nat} int (i) -&#62; int (i+1)
</PRE
><P
></P
></DIV
>


where the syntax <FONT
COLOR="RED"
>{i:nat}</FONT
> automatically expands into
<FONT
COLOR="RED"
>{i:int | i &#62;= 0}</FONT
>.  I list as follows the interfaces for some
commonly used functions on integers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2389"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> g1int_neg <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">i</span><span class="keyword">)</span></span> <span class="comment">// negation</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_add <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// addition</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_sub <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">-</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// subtraction</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_mul <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// multiplication</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_div <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">/</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// division</span>

<span class="dynexp"><span class="keyword">fun</span> g1int_lt <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp"><span class="keyword">&lt;</span></span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// less-than</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_lte <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp">&lt;=</span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// less-than-or-equal-to</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_gt <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// greater-than</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_gte <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp">&gt;=</span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// greater-than-or-equal-to</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_eq <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp">==</span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// equal-to</span>
<span class="dynexp"><span class="keyword">fun</span> g1int_neq <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp">!=</span> <span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// not-equal-to</span>
</p></PRE
><P
></P
></DIV
>


These interfaces are all declared in the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/integer.sats"
TARGET="_top"
>integer.sats</A
>, which is
automatically loaded by the ATS compiler. Note that
the functions listed here can all be referred to by their
standard names:
~ for g1int_neg,
+ for g1int_add,
- for g1int_sub,
* for g1int_mul,
/ for g1int_div,
&#60; for g1int_lt,
&#60;= for g1int_lte,
&#62; for g1int_gt,
&#62;= for g1int_gte,
= for g1int_eq,
!= for g1int_neq,
&#60;&#62; for g1int_neq (most of the time).

</P
><P
>&#13;It is now a proper moment for me to raise an interesting question: What
does a dependently typed interface for the factorial function look like?
After seeing the above examples, it is only natural for one to expect
something along the following line of thought:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2393"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> g1int_fact<span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">fact</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>fact</I
></SPAN
> is a static version of the factorial function. The
very problem with this solution is that a static function like
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>fact</I
></SPAN
> cannot be defined in ATS.  The statics of ATS is a
simply-typed language that does not allow any recursive means to be
employed in the construction of static terms. This design is adopted
primarily to ensure that the equality on static terms can be decided based
on a practical algorithm. As typechecking involving dependent types
essentially turns into verifying whether a set of equalities (and some
built-in predicates) on static terms hold, such a design is of vital
importance to the goal of supporting practical programming with dependent
types.

In order to assign an interface to the factorial function that precisely
matches the definition of the function, we need to employ a mechanism in ATS
for combining programming with theorem-proving.  This is a topic I will
cover later.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="constraint-solving_during_typechecking"
>Constraint-Solving during Typechecking</A
></H2
><P
>&#13;Typechecking in ATS involves generating and solving constraints.
As an example, the code below implements the well-known factorial
function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2400"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
fact<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="staexp">r</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * fact <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
<span class="comment">// end of [fact]</span>
</p></PRE
><P
></P
></DIV
>


In this implementation, the function <FONT
COLOR="RED"
>fact</FONT
> is assigned the
following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2403"
></A
><PRE
CLASS="programlisting"
>{n:nat} int(n) -&#62; [r:nat] int(r)
</PRE
><P
></P
></DIV
>


which means that <FONT
COLOR="RED"
>fact</FONT
> returns a natural number r when applied
to a natural number n. When the code is typechecked, the following
constraints need to be solved:

<P
></P
><UL
><LI
><P
>&#13;For each natural number n, n &#62; 0 implies n - 1 &#62;= 0
</P
></LI
><LI
><P
>For each natural number n and each natural number r<SUB
>1</SUB
>, n &#62; 0 implies n * r<SUB
>1</SUB
>&#62;= 0
</P
></LI
><LI
><P
>&#13;For each natural number n, 1 &#62;= 0 holds.
</P
></LI
></UL
>

The first constraint is generated due to the call <FONT
COLOR="RED"
>fact(x-1)</FONT
>,
which requires that <FONT
COLOR="RED"
>x-1</FONT
> be a natural number. The second
constraint is generated in order to verify that <FONT
COLOR="RED"
>x * fact(x-1)</FONT
>
is a natural number under the assumption that <FONT
COLOR="RED"
>fact(x-1)</FONT
> is a
natural number.  The third constraint is generated in order to verify that
<FONT
COLOR="RED"
>1</FONT
> is a natural number.  The first and the third constraints can
be readily solved by the constraint solver in ATS, which is based on the
Fourier-Motzkin variable elimination method. However, the second constraint
cannot be handled by the constraint solver as it is nonlinear: The
constraint cannot be turned into a linear integer programming problem due
to the occurrence of the nonlinear term (n*r<SUB
>1</SUB
>).  While nonlinear
constraints cannot be handled automatically by the constraint solver in
ATS, the programmer can verify them by constructing proofs in ATS
explicitly. I will cover the issue of explicit proof construction in an
elaborated manner elsewhere.
</P
><P
>&#13;By default, the constraint-solver implemented for ATS/Postiats makes use of
the standard arithmetic of infinite precision.  For the sake of efficiency,
one may also choose to use machine-level arithmetic for solving integer
constraints. Due to potential arithmetic overflow, results returned by the
constraint-solver that uses machine-level arithmetic can be incorrect (but
I have so far not knowingly encountered such a situation in practice).
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_string_processing"
>Example: String Processing</A
></H2
><P
>&#13;A string in ATS is represented in the same manner as in C: It is a sequence
of adjacently stored non-null characters followed by the null character,
and its length is the number of non-null characters in the sequence.
Conventionally, such strings are often referred to as C-style strings,
which are notoriously difficult to be processed safely (as is clearly
indicated by so many bugs and breaches due to misusing such strings). As a
matter of fact, ATS is the first practical programming language that I know
can fully support safe processing of C-style strings. In ATS,
<FONT
COLOR="RED"
>string</FONT
> is a type constructor of the sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int) -&#62;
type</I
></SPAN
>.

Given a static integer n, <FONT
COLOR="RED"
>string(n)</FONT
> is the type for strings of
length n. Note that <FONT
COLOR="RED"
>string</FONT
> also refers to a non-dependent type
for strings of unspecified length, which is basically equivalent to the
type <FONT
COLOR="RED"
>String</FONT
> defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2430"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">String <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The following two functions are commonly used for traversing a given string:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2432"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> string_is_atend
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [string_is_atend]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> string_isnot_atend
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span> <span class="staexp"><span class="keyword">&lt;</span></span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [string_isnot_atend]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Obviously, either one of them can be implemented based on the other. As an
example, the following code implements a function that computes the length
of a given string:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2434"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
string_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
    <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> string_isnot_atend <span class="keyword">(</span>str<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">then</span> loop <span class="keyword">(</span>str<span class="keyword">,</span> succ<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> i</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>str<span class="keyword">,</span> i2sz<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [string_length]</span>
</p></PRE
><P
></P
></DIV
>


Note that the function <FONT
COLOR="RED"
>loop</FONT
> in the body of
<FONT
COLOR="RED"
>string_length</FONT
> is defined tail-recursively, which can then be
translated into a genuine loop in the generated C code.  Although this
implementation of <FONT
COLOR="RED"
>string_length</FONT
> looks fairly plain right now,
it was actually an exciting achievement in the pursuit of practical
programming with dependent types.
</P
><P
>&#13;The following two functions are for accessing and updating characters
stored in strings:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2440"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">charNZ <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>int <span class="keyword">|</span> c != 0<span class="keyword">]</span></span> <span class="staexp">char</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
string_get_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span><span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charNZ</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> string_get_at</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
string_set_char_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span><span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">charNZ</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> string_set_char_at</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The type constructor <FONT
COLOR="RED"
>char</FONT
> is of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(char) -&#62; t@ype</I
></SPAN
>, which takes a static
character c to form a singleton type <FONT
COLOR="RED"
>char(c)</FONT
> for the only
character equal to c. Thus, the type <FONT
COLOR="RED"
>charNZ</FONT
> is for all non-null
characters. The following defined function <FONT
COLOR="RED"
>string_find</FONT
>
traverses a string from left to right to check whether a given character
occurs in the string:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2447"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">sizeLt <span class="keyword">(</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
string_find<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option</span> <span class="keyword">(</span><span class="staexp">sizeLt</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">typedef</span> <span class="staexp">res <span class="keyword">=</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">fun</span> loop<span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>
    str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> isnot <span class="keyword">=</span> string_isnot_atend <span class="keyword">(</span>str<span class="keyword">,</span> i<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> isnot <span class="keyword">then</span>
      <span class="keyword">if</span> <span class="keyword">(</span>c0 <span class="keyword">=</span> <span class="dynexp">str[i<span class="keyword">]</span></span><span class="keyword">)</span> <span class="keyword">then</span> Some<span class="staexp"><span class="keyword">{</span>res<span class="keyword">}</span></span><span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">else</span> loop <span class="keyword">(</span>str<span class="keyword">,</span> c0<span class="keyword">,</span> succ<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
  <span class="keyword">end</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>str<span class="keyword">,</span> c0<span class="keyword">,</span> i2sz<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [string_find]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


If the character <FONT
COLOR="RED"
>c0</FONT
> occurs in the string <FONT
COLOR="RED"
>str</FONT
>, then
a value of the form <FONT
COLOR="RED"
>Some(i)</FONT
> is returned, when i refers to the
position of the first occurrence of <FONT
COLOR="RED"
>c0</FONT
> (counting from left to
right). Otherwise, the value <FONT
COLOR="RED"
>None()</FONT
> is returned.
</P
><P
>&#13;There is some inherent inefficiency in the implementation of
<FONT
COLOR="RED"
>string_find</FONT
>: A given position <FONT
COLOR="RED"
>i</FONT
> is first checked to
see if it is strictly less than the length of the string <FONT
COLOR="RED"
>str</FONT
> by
calling <FONT
COLOR="RED"
>string_isnot_atend</FONT
>, and, if it is, the character stored
at the position in the string is fetched by calling
<FONT
COLOR="RED"
>string_get_at</FONT
>. These two function calls are merged into one in
the following implementation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2460"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="comment">// This implementation does the same as [string_find]</span>
<span class="comment">// but should be more efficient.</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
string_find2<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option</span> <span class="keyword">(</span><span class="staexp">sizeLt</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop<span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span>
<span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option</span> <span class="keyword">(</span><span class="staexp">sizeLt</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">typedef</span> <span class="staexp">res <span class="keyword">=</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> c <span class="keyword">=</span> string_test_at <span class="keyword">(</span>str<span class="keyword">,</span> i<span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">if</span> c != <span class="dynexp">'\000'</span> <span class="keyword">then</span>
  <span class="keyword">(</span>
    <span class="keyword">if</span> <span class="keyword">(</span>c0 <span class="keyword">=</span> c<span class="keyword">)</span>
      <span class="keyword">then</span> Some<span class="staexp"><span class="keyword">{</span>res<span class="keyword">}</span></span><span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">else</span> loop<span class="keyword">(</span>str<span class="keyword">,</span> c0<span class="keyword">,</span> succ<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span>
    <span class="comment">// end of [if]</span>
  <span class="keyword">)</span> <span class="keyword">else</span> None<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>str<span class="keyword">,</span> c0<span class="keyword">,</span> i2sz<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [string_find2]</span>
</p></PRE
><P
></P
></DIV
>


The interface for the function <FONT
COLOR="RED"
>string_test_at</FONT
> is given as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2463"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
string_test_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>char <span class="keyword">|</span> <span class="keyword">(</span>c != NUL &amp;&amp; i <span class="keyword">&lt;</span> n<span class="keyword">)</span> || <span class="keyword">(</span>c == NUL &amp;&amp; i &gt;= n<span class="keyword">)</span><span class="keyword">]</span></span> <span class="staexp">char</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span></span>
<span class="comment">// end of [string_test_at]</span>
</p></PRE
><P
></P
></DIV
>


By checking the return value of a call to <FONT
COLOR="RED"
>string_test_at</FONT
>,
we can readily tell whether the position <FONT
COLOR="RED"
>i</FONT
> is at the end of
the string <FONT
COLOR="RED"
>str</FONT
>.
</P
><P
>&#13;Handling strings safely and efficiently is a complicated matter in
programming language design, and a great deal of information about a
programming language can often be revealed by simply studying its treatment
of strings. In ATS, properly processing C-style strings also makes
essential use of linear types, which I will cover in another part of this
book.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_binary_search_on_arrays"
>Example: Binary Search on Arrays</A
></H2
><P
>&#13;Given a type T of the sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
> and a static integer I (i.e.,
a static term of the sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>int</I
></SPAN
>), <FONT
COLOR="RED"
>arrayref(T, I)</FONT
> is
a boxed type for arrays of size I in which each stored element is of the
type T. Note that such arrays have no size information attached to them.
The following interface is for a function template
<FONT
COLOR="RED"
>array_make_elt</FONT
> that can be called to create an array (with no
size information attached to it):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2476"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
array_make_elt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> elt<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">arrayref</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Given a static integer I, the type <FONT
COLOR="RED"
>size_t(I)</FONT
> is a singleton
type for a value of the type size_t in C that represents the integer equal
to I. The function templates for reading from and writing to an array cell
have the following interfaces:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2479"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
arrayref_get_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayref_get_at</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
arrayref_set_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayref_set_at</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that these two function templates do not incur any run-time
array-bounds checking: The types assigned to them guarantee that each index
used for array subscripting is always legal, that is, within the bounds of
the array being subscripted.
</P
><P
>&#13;As a convincing example of practical programming with dependent types, the
following code implements the standard binary search algorithm on an ordered
array:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2482"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> bsearch_arr<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int <span class="keyword">|</span>
   0 &lt;= i<span class="keyword">;</span> i &lt;= j+1<span class="keyword">;</span> j+1 &lt;= n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> l<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> u<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">j</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">if</span> l &lt;= u <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> m <span class="keyword">=</span> l + half <span class="keyword">(</span>u - l<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> <span class="dynexp">A[m<span class="keyword">]</span></span></span>
    <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> cmp <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> sgn &gt;= <span class="dynexp">0</span> <span class="keyword">then</span> loop <span class="keyword">(</span>A<span class="keyword">,</span> m+<span class="dynexp">1</span><span class="keyword">,</span> u<span class="keyword">)</span> <span class="keyword">else</span> loop <span class="keyword">(</span>A<span class="keyword">,</span> l<span class="keyword">,</span> m-<span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> u <span class="comment">// end of [if]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>A<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [bsearch_arr]</span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>loop</FONT
> defined in the body of
<FONT
COLOR="RED"
>bsearch_arr</FONT
> searches the segment of the array <FONT
COLOR="RED"
>A</FONT
>
between the indices <FONT
COLOR="RED"
>l</FONT
> and <FONT
COLOR="RED"
>u</FONT
>, inclusive.  Clearly,
the type assigned to <FONT
COLOR="RED"
>loop</FONT
> indicates that the integer values i
and j of the arguments <FONT
COLOR="RED"
>l</FONT
> and <FONT
COLOR="RED"
>u</FONT
> must satisfy the
precondition consisting of the constraints 0 &#60;= i, i &#60;= j+1, and j+1 &#60;= n,
where n is the size of the array being searched.  The progress we have made
by introducing dependent types into ATS should be evident in this example:
We can not only specify much more precisely than before but also enforce
effectively the enhanced precision in specification.
</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPTYPES/bsearch_arr.dats"
TARGET="_top"
>on-line</A
> the
code employed for illustration in this section plus some additional code
for testing.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="termination-checking_for_recursive_functions"
>Termination-Checking for Recursive Functions</A
></H2
><P
>&#13;There is a mechanism in ATS that allows the programmer to supply
termination metrics for checking whether recursively defined functions are
terminating.  It will soon become clear that this mechanism of
termination-checking plays a fundamental role in the design of ATS/LF, a
theorem-proving subsystem of ATS, where proofs are constructed as total
functional programs.
</P
><P
>&#13;A termination metric is just a tuple of natural numbers and the standard
lexicographic ordering on natural numbers is used to order such tuples. In
the following example, a singleton metric <FONT
COLOR="RED"
>n</FONT
> is supplied to
verify that the recursive function <FONT
COLOR="RED"
>fact</FONT
> is terminating, where
<FONT
COLOR="RED"
>n</FONT
> is the value of the integer argument of <FONT
COLOR="RED"
>fact</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2502"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> fact <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * fact <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
<span class="comment">// end of [fact]</span>
</p></PRE
><P
></P
></DIV
>


Note that the metric attached to the recursive call <FONT
COLOR="RED"
>fact(x-1)</FONT
>
is <FONT
COLOR="RED"
>n-1</FONT
>, which is strictly less than the initial metric
<FONT
COLOR="RED"
>n</FONT
>. Essentially, termination-checking in ATS verifies that the
metric attached to each recursive call in the body of a function is
strictly less that the initial metric attached to the function.
</P
><P
>&#13;A more difficult and also more interesting example is given as follows,
where the MacCarthy's 91-function is implemented:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2508"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> f91 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">max</span><span class="keyword">(</span><span class="staexp">101</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">,</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>j<span class="keyword">:</span>int <span class="keyword">|</span> <span class="keyword">(</span>i <span class="keyword">&lt;</span> 101 &amp;&amp; j==91<span class="keyword">)</span> || <span class="keyword">(</span>i &gt;= 101 &amp;&amp; j==i-10<span class="keyword">)</span><span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">j</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x &gt;= <span class="dynexp">101</span> <span class="keyword">then</span> x-<span class="dynexp">10</span> <span class="keyword">else</span> f91 <span class="keyword">(</span>f91 <span class="keyword">(</span>x+<span class="dynexp">11</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [f91]</span>
</p></PRE
><P
></P
></DIV
>


The metric supplied to verify the termination of <FONT
COLOR="RED"
>f91</FONT
> is
<FONT
COLOR="RED"
>max(101-i,0)</FONT
>, where <FONT
COLOR="RED"
>i</FONT
> is the value of the
integer argument of <FONT
COLOR="RED"
>f91</FONT
>. Please try to verify manually that
this metric suffices for verifying the termination of <FONT
COLOR="RED"
>f91</FONT
>.
</P
><P
>&#13;As another example, the following code implements the Ackermann's function,
which is well-known for being recursive but not primitive recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2516"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> acker
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">m</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Nat</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">if</span> y <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> acker <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">,</span> acker <span class="keyword">(</span>x<span class="keyword">,</span> y-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> acker <span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">else</span> y + <span class="dynexp">1</span></span>
<span class="comment">// end of [acker]</span>
</p></PRE
><P
></P
></DIV
>


The metric supplied for verifying the termination of <FONT
COLOR="RED"
>acker</FONT
> is a
pair <FONT
COLOR="RED"
>(m,n)</FONT
>, where <FONT
COLOR="RED"
>m</FONT
> and <FONT
COLOR="RED"
>n</FONT
> are values of
the two integer arguments of <FONT
COLOR="RED"
>acker</FONT
>. The metrics attached to the
three recursive calls to <FONT
COLOR="RED"
>acker</FONT
> are, from left to right,
<FONT
COLOR="RED"
>(m-1,k)</FONT
> for some natural number k, <FONT
COLOR="RED"
>(m,n-1)</FONT
>, and
<FONT
COLOR="RED"
>(m-1,1)</FONT
>. Clearly, these metrics are all strictly less than the
initial metric <FONT
COLOR="RED"
>(m,n)</FONT
> according to the lexicographic ordering on
pairs of natural numbers.
</P
><P
>&#13;Termination-checking for mutually recursive functions is similar.  In the
following example, <FONT
COLOR="RED"
>isevn</FONT
> and <FONT
COLOR="RED"
>isodd</FONT
> are defined
mutually recursively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2531"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> isevn
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">2</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span> true <span class="keyword">else</span> isodd <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">and</span> isodd
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">2</span><span class="staexp">*</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> not <span class="keyword">(</span>isevn <span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The metrics supplied for verifying the termination of <FONT
COLOR="RED"
>isevn</FONT
> and
<FONT
COLOR="RED"
>isodd</FONT
> are <FONT
COLOR="RED"
>2*n</FONT
> and <FONT
COLOR="RED"
>2*n+1</FONT
>, respectively,
where <FONT
COLOR="RED"
>n</FONT
> is the value of the integer argument of
<FONT
COLOR="RED"
>isevn</FONT
> and also the value of the integer argument of
<FONT
COLOR="RED"
>isodd</FONT
>.  Clearly, if the metrics <FONT
COLOR="RED"
>(n, 0)</FONT
> and
<FONT
COLOR="RED"
>(n, 1)</FONT
> are supplied for <FONT
COLOR="RED"
>isevn</FONT
> and
<FONT
COLOR="RED"
>isodd</FONT
>, respectively, the termination of these two functions can
also be verified.  Note that it is required that the metrics for mutually
recursively defined functions be tuples of the same length.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="dependent_types_for_debugging"
>Example: Dependent Types for Debugging</A
></H2
><P
>&#13;Given an integer x &#62;= 0, the integer square root of x is the greatest
integer i satisfying i * i &#60;= x.  An implementation of the integer square
root function is given as follows based on the method of binary search:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2547"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
isqrt
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
search
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> l<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> diff <span class="keyword">=</span> r - l</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> diff <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> m <span class="keyword">=</span> l + <span class="keyword">(</span>diff / <span class="dynexp">2</span><span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="comment">// x &lt; m * m can overflow easily</span>
      <span class="keyword">if</span> x / m <span class="keyword">&lt;</span> m
        <span class="keyword">then</span> search <span class="keyword">(</span>x<span class="keyword">,</span> l<span class="keyword">,</span> m<span class="keyword">)</span> <span class="keyword">else</span> search <span class="keyword">(</span>x<span class="keyword">,</span> m<span class="keyword">,</span> r<span class="keyword">)</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]</span>
  <span class="keyword">|</span> _ <span class="comment">(* diff &lt;= 0 *)</span> <span class="keyword">=&gt;</span> l <span class="comment">(* the result is found *)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [search]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  search <span class="keyword">(</span>x<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> x<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [isqrt]</span>
</p></PRE
><P
></P
></DIV
>


This implementation passes typechecking, but it seems to be looping forever
when tested. Instead of going into the standard routine of debugging (e.g.,
by inserting calls to some printing functions), let us attempt to identify
the cause for infinite looping by proving the termination of the function
<FONT
COLOR="RED"
>search</FONT
> through the use of dependent types. Clearly, the
function <FONT
COLOR="RED"
>search</FONT
> is assigned the function type <FONT
COLOR="RED"
>(int,
int, int) -&#62; int</FONT
>, meaning that <FONT
COLOR="RED"
>search</FONT
> takes three integers as
its arguments and returns an integer as its result, and there is not much
else that can be gathered from a non-dependent type as such. However, the
programmer may have thought that the function <FONT
COLOR="RED"
>search</FONT
> should
possess the following invariants (if implemented correctly):

<P
></P
><UL
><LI
><P
>&#13;l * l &#60;= x and x &#60;= r * r must hold when <FONT
COLOR="RED"
>search(x, l, r)</FONT
> is called.
</P
></LI
><LI
><P
>&#13;Assume l * l &#60;= x &#60; r * r for some integers x, l, r.  If a recursive
call <FONT
COLOR="RED"
>search(x, l1, r1)</FONT
> for some integers l1 and r1 is
encountered in the body of <FONT
COLOR="RED"
>search(x, l, r)</FONT
>, then r1-l1 &#60; r-l
must hold. This invariant implies that <FONT
COLOR="RED"
>search</FONT
> is terminating.
</P
></LI
></UL
>

Though the first invariant can be captured in the type system of ATS, it is
somewhat involved to do so due to the need for handling nonlinear
constraints. Instead, let us try to assign <FONT
COLOR="RED"
>search</FONT
> the following
dependent function type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2564"
></A
><PRE
CLASS="programlisting"
>{x:nat} {l,r:nat | l &#60; r} .&#60;r-l&#62;. (int(x), int(l), int(r)) -&#62; int
</PRE
><P
></P
></DIV
>


which captures a weaker invariant stating that l &#60; r must hold when
<FONT
COLOR="RED"
>search(x, l, r)</FONT
> is called. The termination metric
<FONT
COLOR="RED"
>.&#60;r-l&#62;.</FONT
> is provided for checking that the function
<FONT
COLOR="RED"
>search</FONT
> is terminating. When we assign <FONT
COLOR="RED"
>search</FONT
> the
dependent function type, we have to modify its body as certain errors are
otherwise reported during typechecking. The following code we obtain after
proper modification does pass typechecking:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2570"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
isqrt
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">x</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
search
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>l<span class="keyword">,</span>r<span class="keyword">:</span>nat <span class="keyword">|</span> l <span class="keyword">&lt;</span> r<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">r</span><span class="staexp">-</span><span class="staexp">l</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">x</span><span class="keyword">,</span> l<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">l</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">r</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> diff <span class="keyword">=</span> r - l</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="dynexp">0</span> <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> diff <span class="keyword">&gt;</span> <span class="dynexp">1</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> m <span class="keyword">=</span> l + half<span class="keyword">(</span>diff<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> x / m <span class="keyword">&lt;</span> m
        <span class="keyword">then</span> search <span class="keyword">(</span>x<span class="keyword">,</span> l<span class="keyword">,</span> m<span class="keyword">)</span> <span class="keyword">else</span> search <span class="keyword">(</span>x<span class="keyword">,</span> m<span class="keyword">,</span> r<span class="keyword">)</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]</span>
  <span class="keyword">|</span> _ <span class="comment">(* diff &lt;= 1 *)</span> <span class="keyword">=&gt;</span> l <span class="comment">(* the result is found *)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [search]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> search <span class="keyword">(</span>x<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">0</span>
<span class="keyword">end</span></span> <span class="comment">// end of [isqrt]</span>
</p></PRE
><P
></P
></DIV
>


It is now rather clear that infinite looping in the previous implementation
of <FONT
COLOR="RED"
>search</FONT
> may happen if <FONT
COLOR="RED"
>search(x, l, r)</FONT
> is called
in a situaltion where <FONT
COLOR="RED"
>r-l</FONT
> equals 1 as this call can potentially
lead to another call to <FONT
COLOR="RED"
>search</FONT
> of the same arguments. However,
such a call leads to a type-error after <FONT
COLOR="RED"
>search</FONT
> is assigned the
aforementioned dependent function type.
</P
><P
>&#13;By being precise and being able to enforce precision effectively, the
programmer will surely notice that his or her need for run-time debugging
is diminishing rapidly.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="datatype_refinement"
></A
>Chapter 10. Datatype Refinement</H1
><P
>&#13;The datatype mechanism in ATS is adopted from ML directly, and it is really
a signatory feature in functional programming. However, the datatypes we
have seen so far are not very precise when employed to classify values. For
instance, given a type T, the type <FONT
COLOR="RED"
>list0(T)</FONT
> is for values
representing both empty and non-empty lists consisting of elements of the
type T. Therefore, empty and non-empty lists cannot be distinguished at the
level of types. This limitation severely diminishes the effectiveness of
datatypes of ML-style in capturing program invariants. In ATS, datatypes of
ML-style can be refined into dependent datatypes of DML-style, where DML
refers to the programming language Dependent ML, the immediate precursor of
ATS. With such refinement, datatypes can classify values with greatly
enhanced precision.
</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPDTREF/"
TARGET="_top"
>on-line</A
>.

</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="dependent_datatypes"
>Dependent Datatypes</A
></H2
><P
>&#13;The syntax for declaring dependent datatypes is mostly similar to the
syntax for declaring non-dependent datatypes: For instance, the dependent
datatype <FONT
COLOR="RED"
>list</FONT
> in ATS is declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2588"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">list<span class="keyword">(</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> list_nil<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// [of ()] is optional</span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> list_cons<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


More precisely, <FONT
COLOR="RED"
>list</FONT
> is declared as a type constructor of the
sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(t@ype, int) -&#62; type</I
></SPAN
>, which means that <FONT
COLOR="RED"
>list</FONT
>
takes an unboxed type and a static integer to form a boxed type. The
keyword <FONT
COLOR="RED"
>t@ype+</FONT
> indicates that <FONT
COLOR="RED"
>list</FONT
> is covariant at
its first parameter (of the sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>t@ype</I
></SPAN
>), that is,
<FONT
COLOR="RED"
>list(T1, I)</FONT
> is considered a subtype of <FONT
COLOR="RED"
>list(T2, I)</FONT
>
if T1 is a subtype of T2.  There is also the keyword <FONT
COLOR="RED"
>t@ype-</FONT
> for
indicating the declared type constructor being contravariant at a
parameter, but it is rarely used in practice. Also, keywords like
<FONT
COLOR="RED"
>type+</FONT
> and <FONT
COLOR="RED"
>type-</FONT
> are interpreted similarly.
</P
><P
>&#13;There two data (or value) constructors <FONT
COLOR="RED"
>list_nil</FONT
> and
<FONT
COLOR="RED"
>list_cons</FONT
> associated with <FONT
COLOR="RED"
>list</FONT
>, which are declared to be
of the following types:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2605"
></A
><PRE
CLASS="programlisting"
>list_nil : {a:t@ype} () -&#62; list(a, 0)
list_cons : {a:t@ype}{n:nat} (a, list(a, n)) -&#62; list(a, n+1)
</PRE
><P
></P
></DIV
>


Given a type T and a static integer I, the type <FONT
COLOR="RED"
>list(T, I)</FONT
> is
for values representing lists of length I in which each element is of the
type T. Hence, the types of <FONT
COLOR="RED"
>list_nil</FONT
> and <FONT
COLOR="RED"
>list_cons</FONT
>
mean that <FONT
COLOR="RED"
>list_nil</FONT
> forms a list of length 0 and
<FONT
COLOR="RED"
>list_cons</FONT
> forms a list of length n+1 if applied to an element
and a list of length n.  Note that it is also possible to declare
<FONT
COLOR="RED"
>list</FONT
> as follows in a more concise style:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2613"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">list <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">list_nil<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// [of ()] is optional</span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> list_cons<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


The use of <FONT
COLOR="RED"
>a:t@ype+</FONT
> (instead of <FONT
COLOR="RED"
>t@ype+</FONT
>) introduces
implicitly a universal quantifier over <FONT
COLOR="RED"
>a</FONT
> for the type assigned
to each data constructor associated with the declared type constructor
<FONT
COLOR="RED"
>list</FONT
>.
</P
><P
>&#13;As an example of programming with dependent datatypes, the following code
implements a function template for computing the length of a given list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2620"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="comment">// .&lt;n&gt;. is a termination metric</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>_<span class="comment">(*x*)</span><span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span> + list_length&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="comment">// end of [list_length]</span>
</p></PRE
><P
></P
></DIV
>


The type assigned to the function <FONT
COLOR="RED"
>list_length</FONT
> indicates that
the function takes a list of length n for any natural number n and returns
an integer of value n. In addition, the function is verified to be
terminating. Therefore, <FONT
COLOR="RED"
>list_length</FONT
> is guaranteed to implement the
function that computes the length of a given list. I now briefly explain
how typechecking can be performed on the definition of
<FONT
COLOR="RED"
>list_length</FONT
>. Let us first see that the the following clause
typechecks:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2625"
></A
><PRE
CLASS="programlisting"
>  | list_cons (_, xs1) =&#62; 1 + list_length (xs1)
</PRE
><P
></P
></DIV
>


What we need to verify is that the expression on the righthand side of the
symbol <FONT
COLOR="RED"
>=&#62;</FONT
> can be assigned the type <FONT
COLOR="RED"
>int(n)</FONT
> under the
assumption that <FONT
COLOR="RED"
>xs</FONT
> matches the pattern on the lefthand side of
the symbol <FONT
COLOR="RED"
>=&#62;</FONT
>.  Let us assume that <FONT
COLOR="RED"
>xs1</FONT
> is of the
type <FONT
COLOR="RED"
>list(a, n1)</FONT
> for some natural number <FONT
COLOR="RED"
>n1</FONT
>, and
this assumption implies that the pattern <FONT
COLOR="RED"
>list_cons(_, xs1)</FONT
> is
of the type <FONT
COLOR="RED"
>list(a, n1+1)</FONT
>.  Clearly, matching <FONT
COLOR="RED"
>xs</FONT
>
against the pattern <FONT
COLOR="RED"
>list_cons(_, xs1)</FONT
> generates a condition
<FONT
COLOR="RED"
>n=n1+1</FONT
>.  It is also clear that <FONT
COLOR="RED"
>list_length(xs1)</FONT
> is
of the type <FONT
COLOR="RED"
>int(n1)</FONT
> and thus <FONT
COLOR="RED"
>1 + list_length(xs1)</FONT
>
is of the type <FONT
COLOR="RED"
>int(1+n1)</FONT
>. As the condition <FONT
COLOR="RED"
>n=n1+1</FONT
>
implies <FONT
COLOR="RED"
>n=1+n1</FONT
>, <FONT
COLOR="RED"
>1 + list_length(xs1)</FONT
> can be given
the type <FONT
COLOR="RED"
>int(n)</FONT
>. So this clause typechecks.  Note that matching
<FONT
COLOR="RED"
>xs</FONT
> against the pattern <FONT
COLOR="RED"
>list_nil()</FONT
> generates the
assumption <FONT
COLOR="RED"
>n=0</FONT
>, which implies that <FONT
COLOR="RED"
>0</FONT
> is of the type
<FONT
COLOR="RED"
>int(n)</FONT
>. Therefore, the following clause typechecks: </P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2652"
></A
><PRE
CLASS="programlisting"
>  | list_nil((*void*)) =&#62; 0
</PRE
><P
></P
></DIV
><P
>&#13;Given that the two clauses typecheck properly, the case-expression
containing them can be assigned the type <FONT
COLOR="RED"
>int(n)</FONT
>. Therefore, the
definition of <FONT
COLOR="RED"
>list_length</FONT
> typechecks.
</P
><P
>&#13;As the recursive call in the body of the above defined function
<FONT
COLOR="RED"
>list_length</FONT
> is not a tail-call, the function may not be able to
handle a long list (e.g., one that contains 1 million elements).  The
following code gives another implementation for computing the length of a
given list:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2659"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_length<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="comment">// loop: {i,j:nat} (list (a, i), int (j)) -&gt; int (i+j)</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
    <span class="comment">// .&lt;i&gt;. is a termination metric</span>
    <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs1<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> j</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_length]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;This time, <FONT
COLOR="RED"
>list_length</FONT
> is based on a tail-recursive function
<FONT
COLOR="RED"
>loop</FONT
> and thus can handle lists of any length in constant stack
space. Note that the type assigned to <FONT
COLOR="RED"
>loop</FONT
> indicates that
<FONT
COLOR="RED"
>loop</FONT
> takes a list of length i and an integer of value j for some
natural numbers i and j and returns an integer of value i+j. Also,
<FONT
COLOR="RED"
>loop</FONT
> is verified to be terminating.

</P
><P
>&#13;There is also a dependent datatype <FONT
COLOR="RED"
>option</FONT
> in ATS for forming
optional values:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2669"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">option<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> bool<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">Some <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">true</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">a</span></span> <span class="keyword">|</span> <span class="dynexp">None <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [option]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;As an example, the following function template <FONT
COLOR="RED"
>list_last</FONT
> tries to
find the last element in a given list:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2673"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_last
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">option</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> xs1 <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs1<span class="keyword">)</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> xs</span> <span class="keyword">in</span> x
    <span class="keyword">end</span> <span class="comment">// end of [list_nil]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>loop <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_last]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The inner function <FONT
COLOR="RED"
>loop</FONT
> is evidently tail-recursive and it is
verified to be terminating.

</P
><P
>&#13;After a programmer becomes familar with <FONT
COLOR="RED"
>list</FONT
> and
<FONT
COLOR="RED"
>option</FONT
>, there is little incentive for him or her to use
<FONT
COLOR="RED"
>list0</FONT
> and <FONT
COLOR="RED"
>option0</FONT
> anymore. Internally, values of
<FONT
COLOR="RED"
>list</FONT
> and <FONT
COLOR="RED"
>list0</FONT
> have exactly the same representation and
there are cast functions of zero run-time cost in ATS for translating
between values of <FONT
COLOR="RED"
>list</FONT
> and <FONT
COLOR="RED"
>list0</FONT
>.  The same applies
to values of <FONT
COLOR="RED"
>option</FONT
> and <FONT
COLOR="RED"
>option0</FONT
> as well.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_function_templates_on_lists_redux"
>Example: Function Templates on Lists (Redux)</A
></H2
><P
>&#13;I have presented previously implementation of some commonly used function
templates on lists formed with the constructors <FONT
COLOR="RED"
>list0_nil</FONT
> and
<FONT
COLOR="RED"
>list0_cons</FONT
>. This time, I present as follows implementation of
the corresponding function templates on lists formed with the constructors
<FONT
COLOR="RED"
>list_nil</FONT
> and <FONT
COLOR="RED"
>list_cons</FONT
>, which make it possible to
assign more accurate types to these templates.

</P
><P
>Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPDTREF/listfuns.dats"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_append"
>Appending: <FONT
COLOR="RED"
>list_append</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list(T, I1)</FONT
> and
<FONT
COLOR="RED"
>list(T, I2)</FONT
> for some type T and integers I1 and I2,
<FONT
COLOR="RED"
>list_append(xs, ys)</FONT
> returns a list of the type
<FONT
COLOR="RED"
>list(T,I1+I2)</FONT
> that is the concatenation of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2705"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_append
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> list_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_append] *)</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list_append</FONT
> is not
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_reverse_append"
>Reverse Appending: <FONT
COLOR="RED"
>list_reverse_append</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list(T, I1)</FONT
> and
<FONT
COLOR="RED"
>list(T, I2)</FONT
> for some type T and integers I1 and I2,
<FONT
COLOR="RED"
>list_reverse_append(xs, ys)</FONT
> returns a list of the type
<FONT
COLOR="RED"
>list(T, I1+I2)</FONT
> that is the concatenation of the reverse of xs
and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2716"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_reverse_append
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list_reverse_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_reverse_append] *)</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list_reverse_append</FONT
> is
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_reverse"
>Reversing: <FONT
COLOR="RED"
>list_reverse</FONT
></A
></H3
><P
>&#13;Given a list xs, <FONT
COLOR="RED"
>list_reverse(xs)</FONT
> returns the reverse of xs,
which is of the same length as xs:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2724"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_reverse<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span> <span class="comment">// defined non-recursively</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> list_reverse_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> list_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [list_reverse]</span>
</p></PRE
><P
></P
></DIV
>

</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_map"
>Mapping: <FONT
COLOR="RED"
>list_map</FONT
></A
></H3
><P
>&#13;Given a list xs of the type <FONT
COLOR="RED"
>list(T1, I)</FONT
> for some type T1 and
integer I and a closure function f of the type <FONT
COLOR="RED"
>T1 -&#60;cloref1&#62; T2</FONT
>
for some T2, <FONT
COLOR="RED"
>list_map(xs)</FONT
> returns a list ys of the type <FONT
COLOR="RED"
>list(T2, I)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2734"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_map
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">b</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil<span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons<span class="keyword">(</span>f x<span class="keyword">,</span> list_map&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_map] *)</span>
</p></PRE
><P
></P
></DIV
>


Each element y in ys equals f(x), where x is the corresponding element in
xs.  Clearly, this implementation of <FONT
COLOR="RED"
>list_map</FONT
> is not
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_zip"
>Zipping: <FONT
COLOR="RED"
>list_zip</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list(T1, I)</FONT
> and
<FONT
COLOR="RED"
>list(T2, I)</FONT
> for some types T1 and T2 and integer I, respectively,
<FONT
COLOR="RED"
>list_zip(xs, ys)</FONT
> returns a list zs of the type <FONT
COLOR="RED"
>list((T1,T2), I)</FONT
>.

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2745"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_zip
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>
      list_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">,</span> list_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>
      list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span>
    <span class="keyword">,</span> list_cons <span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span>
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons<span class="keyword">(</span><span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list_zip&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_zip] *)</span>
</p></PRE
><P
></P
></DIV
>


Each element z in zs equals the pair (x, y), where x and y are the
corresponding elements in xs and ys, respectively.  Clearly, this
implementation of <FONT
COLOR="RED"
>list_zip</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="list_zipwith"
>Zipping with: <FONT
COLOR="RED"
>list_zipwith</FONT
></A
></H3
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list(T1, I)</FONT
> and
<FONT
COLOR="RED"
>list(T2, I)</FONT
> for some types T1 and T2 and integer I,
respectively, and a closure function f of the type <FONT
COLOR="RED"
>(T1, T2)
-&#60;cloref1&#62; T3</FONT
> for some type T3, <FONT
COLOR="RED"
>list_zipwith(xs, ys, f)</FONT
>
returns a list zs of the type <FONT
COLOR="RED"
>list(T3, I)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2757"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_zipwith
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">c</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>
      list_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">,</span> list_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>
      list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span>
    <span class="keyword">,</span> list_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span>
    <span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list_cons<span class="keyword">(</span>f<span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list_zipwith&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;&lt;</span><span class="staexp">c</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
     <span class="comment">// end of (list_cons, list_cons)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_zipwith] *)</span>
</p></PRE
><P
></P
></DIV
>


Each element z in zs equals f(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list_zipwith</FONT
> is not tail-recursive.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_mergesort_redux"
>Example: Mergesort on Lists (Redux)</A
></H2
><P
>&#13;I have previously presented an <A
HREF="#example_mergesort"
>implementation of mergesort on lists</A
>
that are formed with the constructors <FONT
COLOR="RED"
>list0_nil</FONT
> and
<FONT
COLOR="RED"
>list0_cons</FONT
>.  In this section, I give an implementation of
mergesort on lists formed with the constructors <FONT
COLOR="RED"
>list_nil</FONT
> and
<FONT
COLOR="RED"
>list_cons</FONT
>. This implementation is based on the same algorithm
as the previous one but it assigns a type to the implemented sorting
function that guarantees the function to be length-preserving, that is, the
function always returns a list of the same length as the list it sorts.

</P
><P
>The following defined function <FONT
COLOR="RED"
>merge</FONT
> combines two
ordered list (according to a given ordering) into a single ordered list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2770"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">lte <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">bool</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> merge
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs0<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys0<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs0 <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys0
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>
    <span class="keyword">case+</span> ys0 <span class="keyword">of</span>
    <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs0
    <span class="keyword">|</span> list_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys1<span class="keyword">)</span> <span class="keyword">=&gt;</span>
        <span class="keyword">if</span> x <span class="keyword">\</span>lte y
          <span class="keyword">then</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> merge <span class="keyword">(</span>xs1<span class="keyword">,</span> ys0<span class="keyword">,</span> lte<span class="keyword">)</span><span class="keyword">)</span>
          <span class="keyword">else</span> list_cons <span class="keyword">(</span>y<span class="keyword">,</span> merge <span class="keyword">(</span>xs0<span class="keyword">,</span> ys1<span class="keyword">,</span> lte<span class="keyword">)</span><span class="keyword">)</span>
        <span class="comment">// end of [if]</span>
    <span class="keyword">)</span></span> <span class="comment">// end of [list_cons]</span>
<span class="comment">// end of [merge]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Clearly, the type assigned to <FONT
COLOR="RED"
>merge</FONT
> indicates that the function
returns a list whose length equals the sum of the lengths of the two input
lists. Note that a termination metric is present for verifying that
<FONT
COLOR="RED"
>merge</FONT
> is a terminating function.
</P
><P
>&#13;The following defined function <FONT
COLOR="RED"
>mergesort</FONT
> mergesorts a
list according to a given ordering:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2776"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> mergesort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">fun</span> msort
    <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span> <span class="staexp">a</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> n &gt;= <span class="dynexp">2</span>
      <span class="keyword">then</span> split <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">,</span> lte<span class="keyword">,</span> half<span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">,</span> list_nil<span class="keyword">)</span> <span class="keyword">else</span> xs
    <span class="comment">// end of [if]</span>
  <span class="comment">// end of [msort]</span>
  <span class="keyword">and</span> split
    <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 2<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n/2<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">,</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">n</span><span class="staexp">/</span><span class="staexp">2</span><span class="staexp">+</span><span class="staexp">i</span><span class="keyword">)</span>
  <span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> lte<span class="keyword">:</span> <span class="staexp">lte</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> xsf<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">/</span><span class="staexp">2</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
    <span class="keyword">in</span>
      split <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">,</span> lte<span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">,</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xsf<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half<span class="keyword">(</span>n<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> xsf <span class="keyword">=</span> list_reverse&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xsf<span class="keyword">)</span></span> <span class="comment">// make sorting stable!</span>
      <span class="dynexp"><span class="keyword">val</span> xsf <span class="keyword">=</span> list_of_list_vt <span class="keyword">(</span>xsf<span class="keyword">)</span></span> <span class="comment">// linear list -&gt; nonlinear list</span>
      <span class="dynexp"><span class="keyword">val</span> xsf <span class="keyword">=</span> msort <span class="keyword">(</span>xsf<span class="keyword">,</span> n2<span class="keyword">,</span> lte<span class="keyword">)</span> <span class="keyword">and</span> xs <span class="keyword">=</span> msort <span class="keyword">(</span>xs<span class="keyword">,</span> n-n2<span class="keyword">,</span> lte<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      merge <span class="keyword">(</span>xsf<span class="keyword">,</span> xs<span class="keyword">,</span> lte<span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [split]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  msort<span class="keyword">(</span>xs<span class="keyword">,</span> list_length&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> lte<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mergesort]</span>
</p></PRE
><P
></P
></DIV
>


The type assigned to <FONT
COLOR="RED"
>mergesort</FONT
> indicates that
<FONT
COLOR="RED"
>mergesort</FONT
> returns a list of the same length as its input list.
The two inner functions <FONT
COLOR="RED"
>msort</FONT
> and <FONT
COLOR="RED"
>split</FONT
> are
defined mutually recursively, and the termination metrics for them are
pairs of natural numbers that are compared according to the standard
lexicographic ordering on integer sequences. The type assigned to
<FONT
COLOR="RED"
>msort</FONT
> clearly indicates that its integer argument is required
to be the length of its list argument, and a mismatch between the two
surely results in a type-error.  The type assigned to <FONT
COLOR="RED"
>split</FONT
> is
particularly informative, depicting a relation between the arguments and
the return value of the function that can be of great help for someone
trying to understand the code.  The function <FONT
COLOR="RED"
>list_reverse</FONT
>
returns a linear list that is the reverse of its input, and the cast
function <FONT
COLOR="RED"
>list_of_list_vt</FONT
> turns a linear list into a nonlinear
one (while incuring no cost at run-time). I will explain what linear lists
are elsewhere.
</P
><P
>Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPDTREF/mergesort.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="sequentiality_of_pattern_matching"
>Sequentiality of Pattern Matching</A
></H2
><P
>&#13;In ATS, pattern matching is performed sequentially at run-time. In other
words, a clause is selected only if a given value matches the pattern
guard associated with this clause but the value fails to match the pattern
associated with any clause ahead of it. Naturally, one may expect that the
following implementation of <FONT
COLOR="RED"
>list_zipwith</FONT
> also typechecks:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2792"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_zipwith
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">c</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
<span class="keyword">|</span> <span class="keyword">(</span>
    list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span>
  <span class="keyword">,</span> list_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    list_cons<span class="keyword">(</span>f<span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list_zipwith&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;&lt;</span><span class="staexp">c</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_zipwith] *)</span>
</p></PRE
><P
></P
></DIV
>


This, however, is not the case. In ATS, typechecking clauses is done
nondeterministically (rather than sequentially). In this example, the
second clause fails to typecheck as it is done without the assumption of
the given pair <FONT
COLOR="RED"
>(xs, ys)</FONT
> failing to match the pattern
guard associated with the first clause.  The second clause can be modified
slightly as follows to pass typechecking:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2795"
></A
><PRE
CLASS="programlisting"
>  | (_, _) =&#62;&#62; list_nil((*void*))
</PRE
><P
></P
></DIV
>


The use of the symbol <FONT
COLOR="RED"
>=&#62;&#62;</FONT
> (in place of <FONT
COLOR="RED"
>=&#62;</FONT
>)
indicates to the typechecker that this clause needs to be typechecked under
the sequentiality assumption that the given value matching it does not
match the pattern guards associated with any previous clauses. Therefore,
when the modified second clause is typechecked, it can be assumed that the
pair <FONT
COLOR="RED"
>(xs, ys)</FONT
> matching the pattern <FONT
COLOR="RED"
>(_, _)</FONT
> must
match one of the following three patterns:

<P
></P
><UL
><LI
><P
>&#13;<FONT
COLOR="RED"
>(list_cons _, list_nil ())</FONT
>
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>(list_nil (), list_cons _)</FONT
>
</P
></LI
><LI
><P
>&#13;<FONT
COLOR="RED"
>(list_nil (), list_nil ())</FONT
>
</P
></LI
></UL
>

Given that <FONT
COLOR="RED"
>xs</FONT
> and <FONT
COLOR="RED"
>ys</FONT
> are of the same length,
the typechecker can readily infer that <FONT
COLOR="RED"
>(xs, ys)</FONT
> cannot match
either of the first two patterns. After these two patterns are ruled out,
typechecking is essentially done as if the second clause was written as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2814"
></A
><PRE
CLASS="programlisting"
>  | (list_nil(), list_nil()) =&#62; list_nil((*void*))
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;One may be wondering why typechecking clauses is not required to be
done sequentially by default. The simple reason is that this requirement,
if fully enforced, can have a great negative impact on the efficiency of
typechecking. Therefore, it is a reasonable design to provide the
programmer with an explict means to occasionally make use of the
sequentiality assumption needed for typechecking a particular clause.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_fun_red-black_trees"
>Example: Functional Red-Black Trees</A
></H2
><P
>&#13;A red-black tree is defined as a binary tree such that each node in it is
colored red or black and every path from the root to a leaf has the same
number of black nodes while containing no occurrences of two red nodes in a
row.  Clearly, the length of a longest path in each red-black tree is
bounded by 2 times the length of a shortest path in it. Therefore,
red-black trees are a family of balanced trees. The number of black nodes
occurring on each path in a red-black tree is often referred to as the
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>black height</I
></SPAN
> of the tree.

</P
><P
>&#13;Formally, a datatype precisely for red-black trees can be declared in ATS
as follows:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2822"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> BLK 0</span>
<span class="neuexp"><span class="keyword">#define</span> RED 1</span>
<span class="staexp"><span class="keyword">sortdef</span> clr <span class="keyword">=</span> <span class="keyword">{</span>c<span class="keyword">:</span>nat <span class="keyword">|</span> c &lt;= 1<span class="keyword">}</span></span>
<span class="comment">//</span>
<span class="keyword">datatype</span> <span class="staexp">rbtree
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="comment">(*clr*)</span><span class="keyword">,</span> int<span class="comment">(*bh*)</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">rbtree_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>c<span class="keyword">,</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr <span class="keyword">|</span> cl &lt;= 1-c<span class="keyword">;</span> cr &lt;= 1-c<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    rbtree_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="staexp">-</span><span class="staexp">c</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [rbtree]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The color of a tree is the color of its root node or is black if the tree
is empty.  Given a type T, a color C (represented by a integer) and an
integer BH, the type <FONT
COLOR="RED"
>rbtree(T, C, BH)</FONT
> is for red-black trees
carrying elements of the type T that is of the color C and the black height
BH.

</P
><P
>&#13;When implementing various operations (such as insertion and deletion) on a
red-black tree, we often need to first construct intermediate trees that
contain color violations caused by a red node being followed by another red
node and then employ tree rotations to fix such violations. This need makes
the above datatype <FONT
COLOR="RED"
>rbtree</FONT
> too rigid as it cannot be assigned to
any intermediate trees containing color violations. To address this issue,
we can declare <FONT
COLOR="RED"
>rbtree</FONT
> as follows:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2829"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datatype</span> <span class="staexp">rbtree
<span class="keyword">(</span>
  a<span class="keyword">:</span><span class="keyword">t@ype+</span>
<span class="keyword">,</span> int <span class="comment">// color</span>
<span class="keyword">,</span> int <span class="comment">// black height</span>
<span class="keyword">,</span> int <span class="comment">// violations</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// rbtree</span>
  <span class="keyword">|</span> <span class="dynexp">rbtree_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>c<span class="keyword">,</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>int<span class="keyword">}</span></span>
      <span class="staexp"><span class="keyword">{</span>c==BLK &amp;&amp; v==0 || c == RED &amp;&amp; v==cl+cr<span class="keyword">}</span></span>
    rbtree_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="staexp">-</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">(</span>
      <span class="staexp">int</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rbtree0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span>
    <span class="keyword">)</span></span></span> <span class="comment">(* end of [rbtree_cons] *)</span>
<span class="comment">// end of [rbtree]</span>
<span class="comment">//</span>
<span class="keyword">where</span> <span class="staexp">rbtree0<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">c<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">bh<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">rbtree</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;We count each occurrence of two red nodes in a row as one color violation.
Given a type T, a color C (represented by a integer), an integer BH and an
integer V, the type <FONT
COLOR="RED"
>rbtree(T, C, BH, V)</FONT
> is for trees carrying
elements of the type T that is of the color C and the black height BH and
contains exactly V color violations. Therefore, the type
<FONT
COLOR="RED"
>rbtree(T, C, BH, 0)</FONT
> is for valid red-black trees (containing no
color violations).

</P
><P
>&#13;Given a tree containing at most one color violation, an element and another
tree containing no violations, the following operation constructs a valid
red-black tree:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2835"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_l <span class="comment">// right rotation for fixing left insertion</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
  tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> R RED</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">,</span> c<span class="keyword">)</span><span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> c<span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// shallow rot</span>
  <span class="keyword">|</span> <span class="keyword">(</span>cons <span class="keyword">(</span>R<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> b<span class="keyword">,</span> y<span class="keyword">,</span> c<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> c<span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// deep rotation</span>
  <span class="keyword">|</span> <span class="keyword">(</span>a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_l]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;By simply reading the interface of <FONT
COLOR="RED"
>insfix_l</FONT
>, we can see that the
two tree arguments are required to be of the same black height bh for some
natural number bh and the returned tree is of the black height bh+1.

</P
><P
>&#13;The following operation <FONT
COLOR="RED"
>insfix_r</FONT
> is just the mirror image of
<FONT
COLOR="RED"
>insfix_l</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2842"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_r <span class="comment">// left rotation for fixing right insertion</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
  tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> R RED</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>a<span class="keyword">,</span> x<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> b<span class="keyword">,</span> y<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> c<span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> c<span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// shallow rot</span>
  <span class="keyword">|</span> <span class="keyword">(</span>a<span class="keyword">,</span> x<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> b<span class="keyword">,</span> y<span class="keyword">,</span> c<span class="keyword">)</span><span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      cons <span class="keyword">(</span>R<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">,</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> c<span class="keyword">,</span> z<span class="keyword">,</span> d<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// deep rotation</span>
  <span class="keyword">|</span> <span class="keyword">(</span>a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> a<span class="keyword">,</span> x<span class="keyword">,</span> b<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_r]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The preparation for implementing insertion on a red-black tree is all done
by now, and we are ready to see an implementation of insertion guaranteeing
that the tree obtained from inserting an element into a given red-black
tree is always a valid red-black tree itself. This guarantee is precisely
captured in the following interface for insertion:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2845"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> rbtree_insert
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>bh1<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">bh1</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Interestingly, this interface also implies that the tree returned by a call
to <FONT
COLOR="RED"
>rbtree_insert</FONT
> is always black. The code presented below
gives an implementation of <FONT
COLOR="RED"
>rbtree_insert</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2850"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
rbtree_insert
  <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> B BLK</span>
<span class="neuexp"><span class="keyword">#define</span> R RED</span>
<span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
<span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> ins
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">bh</span><span class="keyword">,</span><span class="staexp">c</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span>
<span class="staexp"><span class="keyword">[</span>
  cl<span class="keyword">:</span>clr<span class="keyword">;</span>v<span class="keyword">:</span>nat <span class="keyword">|</span> v &lt;= c
<span class="keyword">]</span></span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      cons<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>R<span class="keyword">,</span> nil<span class="keyword">,</span> x0<span class="keyword">,</span> nil<span class="keyword">)</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>c<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cl</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tl <span class="keyword">=</span> ins <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> c <span class="keyword">=</span> B <span class="keyword">then</span> insfix_l <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">else</span> cons<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cl<span class="keyword">}</span></span> <span class="keyword">(</span>R<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cr</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tr <span class="keyword">=</span> ins <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> c <span class="keyword">=</span> B <span class="keyword">then</span> insfix_r <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">else</span> cons<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cr<span class="keyword">}</span></span> <span class="keyword">(</span>R<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> t <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">// end of [cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [ins] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> t <span class="keyword">=</span> ins <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span> cons <span class="keyword">(</span>R<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>B<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;&gt;</span> t
<span class="keyword">end</span></span> <span class="comment">// end of [rbtree_insert]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that the type assigned to the inner function <FONT
COLOR="RED"
>ins</FONT
> is so
informative that it literally gives an formal explanation about the way in
which insertion works on a red-black tree. Many a programmer implements
red-black trees by simply following an algorithm written in some format of
pseudo code while having little understanding about the innerworkings of
the algorithm. For instance, if the above inner function <FONT
COLOR="RED"
>ins</FONT
> is
implemented in C, few programmers are likely to see that the function
always maintain the black height of a given red-black tree after insertion
but may introduce one color violation if the root of the tree is red. On
the other hand, knowing this invariant is essential to gaining a thorough
understanding of the insertion algorithm on red-black trees.

</P
><P
>&#13;The insertion operation implemented above does not insert an element if it
is already in the given red-black tree. It may be desirable to require that
the operation inform the caller if such a case occurs. For instance, an
exception can be raised for this purpose. An alternative is to give
<FONT
COLOR="RED"
>rbtree_insert</FONT
> a call-by-reference argument so that a flag can be
returned in it to indicate whether the element to be inserted is actually
inserted. I will explain elsewhere what call-by-reference is and how it is
supported in ATS.

</P
><P
>&#13;Often deleting an element from a binary search tree is significantly more
difficult to implement than inserting one.  This is especially so in the
case of a red-black tree.  I refer the interested reader to the libats
library of ATS for some code implementing a deletion operation on red-black
trees that can guarantee based on types each tree returned by the operation
being a valid red-black tree (containing no color violations).

</P
><P
>&#13;Please find the entire code in this section plus some additional code for
testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DEPDTREF/rbtree.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="theorem-proving_in_ats_lf"
></A
>Chapter 11. Theorem-Proving in ATS/LF</H1
><P
>&#13;Within the ATS programming language system, there is a component named
ATS/LF for supporting (interactive) therorem-proving. In ATS/LF,
theorem-proving is done by constructing proofs as total functional
programs. It will soon become clear that this style of theorem-proving can
be combined cohesively with functional programming to yield a programming
paradigm that is considered the signature of ATS: <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>programming
with theorem-proving</I
></SPAN
>. Moreover, ATS/LF can be employed to encode various
deduction systems and their meta-properties.
</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_THMPRVING/"
TARGET="_top"
>on-line</A
>
the code employed for illustration in this chapter plus some additional
code for testing.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="encoding_relations_as_dataprops"
>Encoding Relations as Dataprops</A
></H2
><P
>&#13;In the statics of ATS, there is a built-in sort <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>prop</I
></SPAN
> for
static terms that represent types for proofs. A static term of the sort
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>prop</I
></SPAN
> can also be referred to as a type or more accurately, a
prop-type or just a prop. A dataprop can be declared in a manner that is
mostly similar to the declaration of a datatype. For instance, a prop
construct <FONT
COLOR="RED"
>FIB</FONT
> is introduced in the following dataprop declaration:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2872"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">FIB<span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">FIB0<span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// [of ()] can be dropped</span>
  <span class="keyword">|</span> <span class="prfexp">FIB1<span class="keyword">(</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// [of ()] can be dropped</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>r0<span class="keyword">,</span>r1<span class="keyword">:</span>int<span class="keyword">}</span></span>
    FIB2<span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">r0</span><span class="staexp">+</span><span class="staexp">r1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">FIB</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r0</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">FIB</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">r1</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [FIB]</span>
</p></PRE
><P
></P
></DIV
>


The sort assigned to <FONT
COLOR="RED"
>FIB</FONT
> is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(int, int) -&#62; prop</I
></SPAN
>,
indicating that <FONT
COLOR="RED"
>FIB</FONT
> takes two static integers to form a
prop-type. There are three data (or proof) constructors associated with
<FONT
COLOR="RED"
>FIB</FONT
>: <FONT
COLOR="RED"
>FIB0</FONT
>, <FONT
COLOR="RED"
>FIB1</FONT
> and <FONT
COLOR="RED"
>FIB2</FONT
>, which are
assigned the following function types (or more accurately, prop-types):

<P
></P
><UL
><LI
><P
><FONT
COLOR="RED"
>FIB0</FONT
>: <FONT
COLOR="RED"
>() -&#62; FIB(0, 0)</FONT
>
</P
></LI
><LI
><P
><FONT
COLOR="RED"
>FIB1</FONT
>: <FONT
COLOR="RED"
>() -&#62; FIB(1, 1)</FONT
>
</P
></LI
><LI
><P
><FONT
COLOR="RED"
>FIB2</FONT
>:
 <FONT
COLOR="RED"
>{n:nat}{r0,r1:int} (FIB(n, r0), FIB(n+1, r1)) -&#62; FIB(n+2, r0+r1)</FONT
>
</P
></LI
></UL
>

Given a natural number n and an integer r, it should be clear that
<FONT
COLOR="RED"
>FIB(n, r)</FONT
> encodes the relation fib(n) = r, where fib is defined
by the following three equations:

<P
></P
><UL
><LI
><P
>fib(0) = 0, and
</P
></LI
><LI
><P
>&#13;fib(1) = 1, and
</P
></LI
><LI
><P
>fib(n+2) = fib(n) + fib(n+1) for n &#62;= 2.
</P
></LI
></UL
>

A proof value of the prop <FONT
COLOR="RED"
>FIB(n, r)</FONT
> can be constructed if and
only if fib(n) equals r. For instance, the proof value
<FONT
COLOR="RED"
>FIB2(FIB0(), FIB1())</FONT
> is assigned the prop <FONT
COLOR="RED"
>FIB(2,
1)</FONT
>, attesting to fib(2) equaling 1.
</P
><P
>&#13;As another example of dataprop, the following declaration introduces a prop
constructor <FONT
COLOR="RED"
>MUL</FONT
> together with three associated proof constructors:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2907"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">MUL<span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> MULbas<span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
    MULind<span class="keyword">(</span><span class="staexp">m</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
    MULneg<span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="keyword">(</span><span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [MUL]</span>
</p></PRE
><P
></P
></DIV
>


Given three integers m, n and p, the prop <FONT
COLOR="RED"
>MUL(m, n, p)</FONT
>
encodes the relation m*n = p. As for <FONT
COLOR="RED"
>MULbas</FONT
>, <FONT
COLOR="RED"
>MULind</FONT
>
and <FONT
COLOR="RED"
>MULneg</FONT
>, they correspond to the following three equations,
respectively:

<P
></P
><UL
><LI
><P
>0*n = 0 for every integer n, and
</P
></LI
><LI
><P
>(m+1)*n = m*n + n for each pair of integers m and n, and
</P
></LI
><LI
><P
>(~m)*n = ~(m*n) for each pair of integers m and n.
</P
></LI
></UL
>

In other words, the dataprop declaration for <FONT
COLOR="RED"
>MUL</FONT
> encodes the
relation that represents the standard multiplication function on integers.
</P
><P
>&#13;It can be readily noticed that the process of encoding a functional
relation (i.e., a relation representing a function) as a dataprop is
analogous to implementing a function in a logic programming language such
as Prolog.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="constructing_proofs_as_total_functions"
>Constructing Proofs as Total Functions</A
></H2
><P
>Theorems are represented as types (or more accurately, props) in
ATS/LF. For instance, the following prop states that integer multiplication
is commutative:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2925"
></A
><PRE
CLASS="programlisting"
>{m,n:int}{p:int} MUL(m, n, p) -&#60;prf&#62; MUL(n, m, p)
</PRE
><P
></P
></DIV
>


Constructing a proof for a theorem in ATS/LF means implementing a total
value (which is most likely to be a total function) of the type that is the
encoding of the theorem in ATS/LF, where being total means being pure and
terminating. Please note that this style of theorem-proving may seem rather
peculiar to those who have never tried it before.
</P
><P
>As a simple introductory example, let us first construct a proof
function in ATS/LF that is given the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2928"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span> mul_istot <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>prfun</FONT
> indicates that the interface is for a proof
function (in contrast to a non-proof function).  Note that
<FONT
COLOR="RED"
>mul_istot</FONT
> is declared to be of the following type (or more
accurately, prop):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2932"
></A
><PRE
CLASS="programlisting"
>{m,n:int} () -&#60;prf&#62; [p:int] MUL(m, n, p)</PRE
><P
></P
></DIV
>


which essentially states that integer multiplication is a total function:
Given any two integers m and n, there exists an integer p such that m, n
and p are related according to the structurally inductively defined
relation <FONT
COLOR="RED"
>MUL</FONT
>. The following code gives an implementation of
<FONT
COLOR="RED"
>mul_istot</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2936"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
mul_istot<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> istot
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> MULind<span class="keyword">(</span>istot<span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> MULbas<span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [istot]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span> istot<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> MULneg<span class="keyword">(</span>istot<span class="staexp"><span class="keyword">{</span><span class="keyword">~</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_istot]  </span>
</p></PRE
><P
></P
></DIV
>


Note that the keyword <FONT
COLOR="RED"
>primplement</FONT
> (instead of
<FONT
COLOR="RED"
>implement</FONT
>) initiates the implementation of a proof.  The inner
proof function <FONT
COLOR="RED"
>istot</FONT
> encodes a proof showing that there exists
an integer p for any given natural number m and integer n such that m, n
and p are related (according to <FONT
COLOR="RED"
>MUL</FONT
>).  The keyword
<FONT
COLOR="RED"
>sif</FONT
> is used for forming a conditional (proof) expression in
which the test is a static expression.  The proof encoded by
<FONT
COLOR="RED"
>istot</FONT
> proceeds by induction on m; if m &#62; 0 holds, then there
exists an integer p1 such that m-1, n and p1 are related by induction
hypothesis (on m-1) and thus m, n and p are related for p = p1+n according
to the rule encoded by <FONT
COLOR="RED"
>MULind</FONT
>; if m = 0, then m, n and p are
related for p = 0. The proof encoded by the implementation of
<FONT
COLOR="RED"
>mul_istot</FONT
> goes like this: if m is a natural number, then the
lemma proven by <FONT
COLOR="RED"
>istot</FONT
> shows that m, n and some p are related;
if m is negative, then the same lemma shows that ~m, n and p1 are related
for some integer p1 and thus m, n and p are related for p = ~p1 according
to the rule encoded by <FONT
COLOR="RED"
>MULneg</FONT
>.
</P
><P
>&#13;As another example of theorem-proving in ATS/LF, a proof function of
the name <FONT
COLOR="RED"
>mul_isfun</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2950"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfn</span> mul_isfun
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> isfun
    <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pf1<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> pf1 <span class="keyword">of</span>
    <span class="keyword">|</span> MULind<span class="keyword">(</span>pf1prev<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="prfexp"><span class="keyword">prval</span> MULind<span class="keyword">(</span>pf2prev<span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="keyword">in</span> isfun <span class="keyword">(</span>pf1prev<span class="keyword">,</span> pf2prev<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [MULind]</span>
    <span class="keyword">|</span> MULbas<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="prfexp"><span class="keyword">prval</span> MULbas<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="keyword">in</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span></span> <span class="comment">// end of [MULbas]</span>
  <span class="comment">// end of [isfun]</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> pf1 <span class="keyword">of</span>
  <span class="keyword">|</span> MULneg<span class="keyword">(</span>pf1nat<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> MULneg<span class="keyword">(</span>pf2nat<span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="keyword">in</span> isfun <span class="keyword">(</span>pf1nat<span class="keyword">,</span> pf2nat<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [MULneg]</span>
  <span class="keyword">|</span> _ <span class="comment">(*non-MULneg*)</span> <span class="keyword">=&gt;&gt;</span> isfun <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_isfun]</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>prfn</FONT
> is used for defining a non-recursive proof
function, and the keyword <FONT
COLOR="RED"
>prval</FONT
> for introducing bindings that
relate names to proof expressions, that is, expressions of prop-types. As
far as pattern matching exhaustiveness is concerned, <FONT
COLOR="RED"
>prval</FONT
> is
equivalent to <FONT
COLOR="RED"
>val+</FONT
> (as proofs cannot contain any effects such
as failures of pattern matching).
</P
><P
>&#13;What <FONT
COLOR="RED"
>mul_isfun</FONT
> proves is that the relation <FONT
COLOR="RED"
>MUL</FONT
> is
functional on its first two arguments: If m, n and p1 are related according
to <FONT
COLOR="RED"
>MUL</FONT
> and m, n and p2 are also related according to
<FONT
COLOR="RED"
>MUL</FONT
>, then p1 and p2 are equal.  The statement is first proven
by the inner proof function <FONT
COLOR="RED"
>isfun</FONT
> under the assumption that m
is a natural number, and then the assumption is dropped.  Let us now take a
look at the first matching clause in the body of <FONT
COLOR="RED"
>isfun</FONT
>. If the
clause is chosen, then <FONT
COLOR="RED"
>pf1</FONT
> matches the pattern
<FONT
COLOR="RED"
>MULind(pf1prev)</FONT
> and thus <FONT
COLOR="RED"
>pf1prev</FONT
> is of the type
<FONT
COLOR="RED"
>MUL(m1, n1, q1)</FONT
> for some natural number m1 and integer n1 and
integer p1 such that m=m1+1, n=n1, and p1=q1+n1. This means that
<FONT
COLOR="RED"
>pf2</FONT
> must be of the form <FONT
COLOR="RED"
>MULind(pf2prev)</FONT
> for some
<FONT
COLOR="RED"
>pf2prev</FONT
> of the type <FONT
COLOR="RED"
>MUL(m2, n2, q2)</FONT
> such that
m2+1=m, n2=n and p2=q2+n2. By calling <FONT
COLOR="RED"
>isfun</FONT
> on <FONT
COLOR="RED"
>pf1prev</FONT
>
and <FONT
COLOR="RED"
>pf2prev</FONT
>, which amounts to invoking the induction hypothesis
on m-1, we establish q1=q2, which implies p1=p2. The second matching clause
in the body of <FONT
COLOR="RED"
>isfun</FONT
> can be readily understood, which
corresponds to the base case in the inductive proof encoded by
<FONT
COLOR="RED"
>isfun</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_distributivity_of_multiplication"
>Example: Distributivity of Multiplication</A
></H2
><P
>The distributivity of multiplication over addition means that the following
equation holds

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2979"
></A
><PRE
CLASS="programlisting"
>m * (n1 + n2) = m * n1 + m * n2</PRE
><P
></P
></DIV
>


for m, n1 and n2 ranging over integers. A direct encoding of the equation
is given by the following (proof) function interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2981"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_distribute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">+</span><span class="staexp">p2</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Plainly speaking, the encoding states that the product of m and (n1+n2) is
p1+p2 if the product of m and n1 is p1 and the product of m and n2 is p2.
An implementation of <FONT
COLOR="RED"
>mul_distribute</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2984"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
mul_distribute
<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n1<span class="keyword">,</span>n2<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
auxnat
<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">+</span><span class="staexp">p2</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULbas<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> MULbas<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> MULbas<span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULind pf1<span class="keyword">,</span> MULind pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULind<span class="keyword">(</span>auxnat <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [auxnat] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">sif</span>
<span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span>
<span class="keyword">then</span> <span class="keyword">(</span>
  auxnat <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
<span class="keyword">)</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> MULneg<span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf1</span>
  <span class="prfexp"><span class="keyword">prval</span> MULneg<span class="keyword">(</span>pf2<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
<span class="keyword">in</span>
  MULneg<span class="keyword">(</span>auxnat <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_distribute]</span>
</p></PRE
><P
></P
></DIV
>


The inner function <FONT
COLOR="RED"
>auxnat</FONT
> encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2987"
></A
><PRE
CLASS="programlisting"
>m * (n1 + n2) = m * n1 + m * n2
</PRE
><P
></P
></DIV
>


for m ranging over natural numbers and n1 and n2 ranging over integers. The
function <FONT
COLOR="RED"
>mul_distribute</FONT
> can then be implemented immediately
based on <FONT
COLOR="RED"
>auxnat</FONT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_commutativity_of_multiplication"
>Example: Commutativity of Multiplication</A
></H2
><P
>The commutativity of multiplication means that the following equation
holds

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2994"
></A
><PRE
CLASS="programlisting"
>m * n = n * m</PRE
><P
></P
></DIV
>


for m and n ranging over integers. A direct encoding of this equation
is given by the following (proof) function interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2996"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_commute<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


An implementation of <FONT
COLOR="RED"
>mul_commute</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN2999"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_commute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span><span class="keyword">(</span>pf0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
auxnat
<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
pf<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> MULbas<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> mul_nx0_0<span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> MULind<span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      mul_distribute<span class="keyword">(</span>auxnat<span class="keyword">(</span>pf1<span class="keyword">)</span><span class="keyword">,</span> mul_nx1_n<span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="comment">// end of [MULind]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [auxnat] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">sif</span>
<span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span>
<span class="keyword">then</span> auxnat<span class="keyword">(</span>pf0<span class="keyword">)</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> MULneg<span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf0</span> <span class="keyword">in</span> mul_neg_2<span class="keyword">(</span>auxnat<span class="keyword">(</span>pf1<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_commute]</span>
</p></PRE
><P
></P
></DIV
>


where the following proof functions are called:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3001"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_nx0_0<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span> <span class="comment">// n * 0 = 0</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_nx1_n<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// n * 1 = n</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_neg_2
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">,</span><span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">n</span><span class="keyword">,</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">p</span><span class="keyword">)</span></span> <span class="comment">// m*(~n) = ~(m*n)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The inner function <FONT
COLOR="RED"
>auxnat</FONT
> encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3004"
></A
><PRE
CLASS="programlisting"
>m * n = n * m</PRE
><P
></P
></DIV
>


for m ranging over natural numbers and n ranging over integers.
The function <FONT
COLOR="RED"
>mul_commute</FONT
> can then be implemented immediately
based on <FONT
COLOR="RED"
>auxnat</FONT
>.</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="datasorts"
>Algebraic Datasorts</A
></H2
><P
>A datasort is rather similar to a dataype. However, the former is
declared in the statics of ATS while the latter in the dynamics of ATS. To
see a typical need for datasorts, let us try to encode a theorem in ATS
stating that s is strictly less than 2<SUP
>h</SUP
> if s and
h are the size and height, respectively, of a given binary tree. To
represent binary trees in the statics, we first declare a datasort as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3012"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">datasort</span> tree <span class="keyword">=</span> E <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> B <span class="keyword">of</span> <span class="keyword">(</span>tree<span class="keyword">,</span> tree<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The name of the declared datasort is <FONT
COLOR="RED"
>tree</FONT
> and there are two
constructor associated with it: <FONT
COLOR="RED"
>E</FONT
> and <FONT
COLOR="RED"
>B</FONT
>, where E
forms the empty tree and B forms a tree by joining two given trees.  For
instance, <FONT
COLOR="RED"
>B(E(), E())</FONT
> is a static term of the sort
<FONT
COLOR="RED"
>tree</FONT
> that represents a singleton tree, that is, a tree
consisting of exactly one node.  Please note that the trees formed by E and
B are really just tree skeletons carrying no data.
</P
><P
>We now declare two dataprops as follows for capturing the notion of
size and height of trees:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3020"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">dataprop</span>
<span class="staexp">SZ <span class="keyword">(</span>tree<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">SZE <span class="keyword">(</span><span class="staexp">E</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>tl<span class="keyword">,</span>tr<span class="keyword">:</span>tree<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>sl<span class="keyword">,</span>sr<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    SZB <span class="keyword">(</span><span class="staexp">B</span> <span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">tr</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">1</span><span class="staexp">+</span><span class="staexp">sl</span><span class="staexp">+</span><span class="staexp">sr</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">sl</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">tr</span><span class="keyword">,</span> <span class="staexp">sr</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [SZ]</span>
<span class="comment">//</span>
<span class="keyword">dataprop</span>
<span class="staexp">HT <span class="keyword">(</span>tree<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">HTE <span class="keyword">(</span><span class="staexp">E</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>tl<span class="keyword">,</span>tr<span class="keyword">:</span>tree<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    HTB <span class="keyword">(</span><span class="staexp">B</span> <span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">tr</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">1</span><span class="staexp">+</span><span class="staexp">max</span><span class="keyword">(</span><span class="staexp">hl</span><span class="keyword">,</span><span class="staexp">hr</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">HT</span> <span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">hl</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">HT</span> <span class="keyword">(</span><span class="staexp">tr</span><span class="keyword">,</span> <span class="staexp">hr</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [HT]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Given a tree t and an integer s, SZ(t, s) encodes the relation that the
size of t equals s. Similiarly, given a tree t and an integer h, HZ(t, h)
encodes the relation that the height of t equals h.
</P
><P
>As the power function (of base 2) is not available in the statics of ATS,
we declare a dataprop as follows to capture it:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3023"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">POW2 <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">POW2bas <span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> POW2ind <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">+</span><span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [POW2]</span>
</p></PRE
><P
></P
></DIV
>


Given two integers h and p, POW2 (h, p) encodes the relation that
2<SUP
>h</SUP
> equals p.
</P
><P
>It should be clear by now that the following proof function
interface encodes the theorem stating that s is strictly less than
2<SUP
>h</SUP
> if s and h are the size and height of a
given binary tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3028"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
lemma_tree_size_height
  <span class="staexp"><span class="keyword">{</span>t<span class="keyword">:</span>tree<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>s<span class="keyword">,</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">s</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">HT</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">h</span><span class="keyword">)</span><span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>s <span class="keyword">&lt;</span> p<span class="keyword">]</span></span> <span class="staexp">void</span></span> <span class="comment">// end of [prfun]</span>
</p></PRE
><P
></P
></DIV
>


Let us now construct an implementation of this proof function as follows.
</P
><P
>We first establish some elementary properties on the power function
(of base 2):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3031"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
pow2_istot
  <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">h</span><span class="keyword">&gt;.</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">h</span><span class="staexp">==</span><span class="staexp">0</span>
    <span class="keyword">then</span> POW2bas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> POW2ind <span class="keyword">(</span>pow2_istot <span class="staexp"><span class="keyword">{</span>h-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [sif]</span>
<span class="comment">// end of [pow2_istot]</span>

<span class="prfexp"><span class="keyword">prfun</span>
pow2_pos
  <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">h</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p <span class="keyword">&gt;</span> 0<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> POW2bas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> POW2ind <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span> pow2_pos <span class="keyword">(</span>pf1<span class="keyword">)</span></span>
<span class="comment">// end of [pow2_pos]</span>

<span class="prfexp"><span class="keyword">prfun</span>
pow2_inc
  <span class="staexp"><span class="keyword">{</span>h1<span class="keyword">,</span>h2<span class="keyword">:</span>nat <span class="keyword">|</span> h1 &lt;= h2<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">h2</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1 &lt;= p2<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf1 <span class="keyword">of</span>
  <span class="keyword">|</span> POW2bas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> pow2_pos <span class="keyword">(</span>pf2<span class="keyword">)</span>
  <span class="keyword">|</span> POW2ind <span class="keyword">(</span>pf11<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> POW2ind <span class="keyword">(</span>pf21<span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="keyword">in</span> pow2_inc <span class="keyword">(</span>pf11<span class="keyword">,</span> pf21<span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [POW2ind]</span>
<span class="comment">// end of [pow2_inc]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, <FONT
COLOR="RED"
>pow2_istot</FONT
> shows that the relation encoded by the
dataprop <FONT
COLOR="RED"
>POW2</FONT
> is a total relation; <FONT
COLOR="RED"
>pow2_pos</FONT
> proves
that the power of each natural number is positive; <FONT
COLOR="RED"
>pow2_inc</FONT
>
establishes that the power function is increasing.
</P
><P
>&#13;The function <FONT
COLOR="RED"
>lemma_tree_size_height</FONT
> can be implemented
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3039"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
lemma_tree_size_height
  <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma<span class="staexp"><span class="keyword">{</span>t<span class="keyword">:</span>tree<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>s<span class="keyword">,</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">t</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">s</span><span class="keyword">)</span>
<span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">HT</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">h</span><span class="keyword">)</span>
<span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">POW2</span> <span class="keyword">(</span><span class="staexp">h</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p <span class="keyword">&gt;</span> s<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="dynexp"><span class="keyword">scase</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> SZE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1
      <span class="keyword">prval</span> HTE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf2
      <span class="keyword">prval</span> POW2bas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf3
   <span class="keyword">in</span>
     <span class="comment">// nothing</span>
   <span class="keyword">end</span> <span class="comment">// end of [E]</span>
  <span class="keyword">|</span> B <span class="keyword">(</span>tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> SZB <span class="keyword">(</span>pf1l<span class="keyword">,</span> pf1r<span class="keyword">)</span> <span class="keyword">=</span> pf1
      <span class="keyword">prval</span> HTB <span class="keyword">{</span>tl<span class="keyword">,</span>tr<span class="keyword">}</span><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">}</span> <span class="keyword">(</span>pf2l<span class="keyword">,</span> pf2r<span class="keyword">)</span> <span class="keyword">=</span> pf2
      <span class="keyword">prval</span> POW2ind <span class="keyword">(</span>pf31<span class="keyword">)</span> <span class="keyword">=</span> pf3
      <span class="keyword">prval</span> pf3l <span class="keyword">=</span> pow2_istot <span class="keyword">{</span>hl<span class="keyword">}</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">prval</span> pf3r <span class="keyword">=</span> pow2_istot <span class="keyword">{</span>hr<span class="keyword">}</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma <span class="keyword">(</span>pf1l<span class="keyword">,</span> pf2l<span class="keyword">,</span> pf3l<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma <span class="keyword">(</span>pf1r<span class="keyword">,</span> pf2r<span class="keyword">,</span> pf3r<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pow2_inc <span class="keyword">(</span>pf3l<span class="keyword">,</span> pf31<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pow2_inc <span class="keyword">(</span>pf3r<span class="keyword">,</span> pf31<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="comment">// nothing</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [B]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [lemma] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [lemma_tree_size_height]</span>
</p></PRE
><P
></P
></DIV
>


The inner function <FONT
COLOR="RED"
>lemma</FONT
>, which is given a termination metric
consisting of a static term of the sort <FONT
COLOR="RED"
>tree</FONT
>, corresponds to a
proof based on structural induction (where the involved structure is the
binary tree <FONT
COLOR="RED"
>t</FONT
>).  Given two terms t1 and t2 of the sort
<FONT
COLOR="RED"
>tree</FONT
>, t1 is (strictly) less than t2 if t1 is a (proper)
substructure of t2. Evidently, this is a well-founded ordering.  The
keyword <FONT
COLOR="RED"
>scase</FONT
> is used to form a dynamic expression that does
case-analysis on a static term (built by constructors associated with some
declared datasort). So the relation between <FONT
COLOR="RED"
>sif</FONT
> and
<FONT
COLOR="RED"
>scase</FONT
> is essentially parallel to that between <FONT
COLOR="RED"
>if</FONT
>
and <FONT
COLOR="RED"
>case</FONT
>.  Please find the entirety of the above code
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_THMPRVING/tree.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_establishing_properties_on_braun_trees"
>Example: Establishing Properties on Braun Trees</A
></H2
><P
>&#13;As stated previously in this book, a binary tree is a Braun tree if it is
empty or if its left and right subtrees are Braun trees and the size of the
left one minus the size of the right one is either 0 or 1.  Formally, we
can declare the following dataprop <FONT
COLOR="RED"
>isBraun</FONT
> to capture the notion
of Braun trees:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3055"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">isBraun <span class="keyword">(</span>tree<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">isBraunE <span class="keyword">(</span><span class="staexp">E</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>tl<span class="keyword">,</span>tr<span class="keyword">:</span>tree<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>sl<span class="keyword">,</span>sr<span class="keyword">:</span>nat <span class="keyword">|</span> sr &lt;= sl<span class="keyword">;</span> sl &lt;= sr + 1<span class="keyword">}</span></span>
    isBraunB <span class="keyword">(</span>
      <span class="staexp">B</span><span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">tr</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">isBraun</span> <span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">isBraun</span> <span class="staexp">tr</span><span class="keyword">,</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">tl</span><span class="keyword">,</span> <span class="staexp">sl</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">tr</span><span class="keyword">,</span> <span class="staexp">sr</span><span class="keyword">)</span>
    <span class="keyword">)</span></span></span> <span class="comment">// end of [isBraunB]</span>
<span class="comment">// end of [isBraun]</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>We first prove that there exists a Braun tree of any given size.
This property can be encoded as follows in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3058"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
lemma_existence<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>t<span class="keyword">:</span>tree<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">isBraun</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Literally, the type assigned to <FONT
COLOR="RED"
>lemma_existence</FONT
> means that there
exists a tree t for any given natural number n such that t is a Braun tree
and the size of t is n. The following code gives an implementation of
<FONT
COLOR="RED"
>lemma_existence</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3062"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
lemma_existence
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  <span class="comment">// argless</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>t<span class="keyword">:</span>tree<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">isBraun</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span>
    <span class="keyword">then</span> <span class="keyword">(</span>isBraunE <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> SZE <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="keyword">stadef</span> <span class="staexp">nl <span class="keyword">=</span> <span class="staexp">n</span> <span class="staexp">/</span> <span class="staexp">2</span></span>
      <span class="keyword">stadef</span> <span class="staexp">nr <span class="keyword">=</span> <span class="staexp">n</span> <span class="staexp">-</span> <span class="staexp">1</span> <span class="staexp">-</span> <span class="staexp">nl</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>pfl1<span class="keyword">,</span> pfl2<span class="keyword">)</span> <span class="keyword">=</span> lemma<span class="staexp"><span class="keyword">{</span>nl<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
      <span class="keyword">and</span> <span class="keyword">(</span>pfr1<span class="keyword">,</span> pfr2<span class="keyword">)</span> <span class="keyword">=</span> lemma<span class="staexp"><span class="keyword">{</span>nr<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span>isBraunB <span class="keyword">(</span>pfl1<span class="keyword">,</span> pfr1<span class="keyword">,</span> pfl2<span class="keyword">,</span> pfr2<span class="keyword">)</span><span class="keyword">,</span> SZB <span class="keyword">(</span>pfl2<span class="keyword">,</span> pfr2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
  <span class="comment">// end of [sif]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  lemma<span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [lemma_existence]</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>stadef</FONT
> is a keyword in ATS for introducting a static
binding between a name and a static term (of any sort). If one prefers,
this keyword can be chosen to replace the keyword <FONT
COLOR="RED"
>typedef</FONT
> (for
introducing a name and a static term of the sort <FONT
COLOR="RED"
>t@ype</FONT
>).

</P
><P
>Next we show that two Braun trees of the same size are identical. This
property can be encoded as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3068"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
lemma_unicity
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>t1<span class="keyword">,</span>t2<span class="keyword">:</span>tree<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t1</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t2</span><span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> pf4<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EQ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">t2</span><span class="keyword">)</span></span> <span class="comment">// end of [lemma_unicity]</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>EQ</FONT
> is a prop-constructor introduced by the following
dataprop declaration:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3071"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span> <span class="staexp">EQ <span class="keyword">(</span>tree<span class="keyword">,</span> tree<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">EQE <span class="keyword">(</span><span class="staexp">E</span><span class="keyword">,</span> <span class="staexp">E</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>t1l<span class="keyword">,</span>t1r<span class="keyword">:</span>tree<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>t2l<span class="keyword">,</span>t2r<span class="keyword">:</span>tree<span class="keyword">}</span></span>
    EQB <span class="keyword">(</span><span class="staexp">B</span> <span class="keyword">(</span><span class="staexp">t1l</span><span class="keyword">,</span> <span class="staexp">t1r</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">B</span> <span class="keyword">(</span><span class="staexp">t2l</span><span class="keyword">,</span> <span class="staexp">t2r</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">EQ</span> <span class="keyword">(</span><span class="staexp">t1l</span><span class="keyword">,</span> <span class="staexp">t2l</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">EQ</span> <span class="keyword">(</span><span class="staexp">t1r</span><span class="keyword">,</span> <span class="staexp">t2r</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [EQ]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, <FONT
COLOR="RED"
>EQ</FONT
> is the inductively defined equality on trees.
An implementation of the proof function <FONT
COLOR="RED"
>lemma_unicity</FONT
> is presented
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3075"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
lemma_unicity
  <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">,</span> pf4<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> lemma<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>t1<span class="keyword">,</span>t2<span class="keyword">:</span>tree<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pf1<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t1</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t2</span><span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> pf4<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EQ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">t2</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">sif</span> <span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span>
      <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="prfexp"><span class="keyword">prval</span> SZE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf3 <span class="keyword">and</span> SZE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf4</span>
        <span class="prfexp"><span class="keyword">prval</span> isBraunE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1 <span class="keyword">and</span> isBraunE <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
      <span class="keyword">in</span>
        EQE <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [then]</span>
      <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="prfexp"><span class="keyword">prval</span> SZB <span class="keyword">(</span>pf3l<span class="keyword">,</span> pf3r<span class="keyword">)</span> <span class="keyword">=</span> pf3</span>
        <span class="prfexp"><span class="keyword">prval</span> SZB <span class="keyword">(</span>pf4l<span class="keyword">,</span> pf4r<span class="keyword">)</span> <span class="keyword">=</span> pf4</span>
        <span class="prfexp"><span class="keyword">prval</span> isBraunB <span class="keyword">(</span>pf1l<span class="keyword">,</span> pf1r<span class="keyword">,</span> pf1lsz<span class="keyword">,</span> pf1rsz<span class="keyword">)</span> <span class="keyword">=</span> pf1</span>
        <span class="prfexp"><span class="keyword">prval</span> isBraunB <span class="keyword">(</span>pf2l<span class="keyword">,</span> pf2r<span class="keyword">,</span> pf2lsz<span class="keyword">,</span> pf2rsz<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf1lsz<span class="keyword">,</span> pf3l<span class="keyword">)</span> <span class="keyword">and</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf1rsz<span class="keyword">,</span> pf3r<span class="keyword">)</span></span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf2lsz<span class="keyword">,</span> pf4l<span class="keyword">)</span> <span class="keyword">and</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf2rsz<span class="keyword">,</span> pf4r<span class="keyword">)</span></span>
        <span class="prfexp"><span class="keyword">prval</span> pfeql <span class="keyword">=</span> lemma <span class="keyword">(</span>pf1l<span class="keyword">,</span> pf2l<span class="keyword">,</span> pf3l<span class="keyword">,</span> pf4l<span class="keyword">)</span></span>
        <span class="prfexp"><span class="keyword">prval</span> pfeqr <span class="keyword">=</span> lemma <span class="keyword">(</span>pf1r<span class="keyword">,</span> pf2r<span class="keyword">,</span> pf3r<span class="keyword">,</span> pf4r<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        EQB <span class="keyword">(</span>pfeql<span class="keyword">,</span> pfeqr<span class="keyword">)</span>
      <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
    <span class="comment">// end of [sif]</span>
<span class="keyword">in</span>
  lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">,</span> pf4<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [lemma_unicity]</span>
</p></PRE
><P
></P
></DIV
>


Note that the proof function <FONT
COLOR="RED"
>SZ_istot</FONT
> in this implementation of
<FONT
COLOR="RED"
>lemma_unicity</FONT
> is given the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3079"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
SZ_istot<span class="staexp"><span class="keyword">{</span>t<span class="keyword">:</span>tree<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n1==n2<span class="keyword">]</span></span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


which simply states that <FONT
COLOR="RED"
>SZ</FONT
> is a functional relation with
respect to its first parameter, that is, there is at most one n for every
given t such that t and n are related according to <FONT
COLOR="RED"
>SZ</FONT
>.

Clearly, the mathematical proof corresponding to this implementation is of
induction on the size n of the two given trees t1 and t2. In the base case
where n is 0, t1 and t2 are equal as they both are the empty tree. In the
inductive case where n &#62; 0, it is proven that n1l and n2l are of the same
value where n1l and n2l are the sizes of the left subtrees of t1 and t2,
respecitvely; similarly, it is also proven that n1r and n2r are of the same
value where n1r and n2r are the sizes of the right subtrees of t1 and t2,
respectively; by induction hypothesis on n1l, the left substrees of t1 and
t2 are the same; by induction hypothesis on n1r, the right substrees of t1
and t2 are the same; by the definition of tree equality (encoded by
<FONT
COLOR="RED"
>EQ</FONT
>), t1 and t2 are the same.
</P
><P
>&#13;As a comparison, the following code gives another implementation of
<FONT
COLOR="RED"
>lemma_unicity</FONT
> that is of a different (and rather unusual) style:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3086"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplement</span>
lemma_unicity
  <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">,</span> pf4<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>t1<span class="keyword">,</span>t2<span class="keyword">:</span>tree<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">t1</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t1</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">isBraun</span> <span class="staexp">t2</span><span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> pf4<span class="keyword">:</span> <span class="staexp">SZ</span> <span class="keyword">(</span><span class="staexp">t2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EQ</span> <span class="keyword">(</span><span class="staexp">t1</span><span class="keyword">,</span> <span class="staexp">t2</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
<span class="comment">//</span>
  <span class="keyword">|</span> <span class="keyword">(</span>isBraunE <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> isBraunE <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> EQE <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
  <span class="keyword">|</span> <span class="keyword">(</span>isBraunB <span class="keyword">(</span>pf11<span class="keyword">,</span> pf12<span class="keyword">,</span> pf13<span class="keyword">,</span> pf14<span class="keyword">)</span><span class="keyword">,</span>
     isBraunB <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">,</span> pf23<span class="keyword">,</span> pf24<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="prfexp"><span class="keyword">prval</span> SZB <span class="keyword">(</span>pf31<span class="keyword">,</span> pf32<span class="keyword">)</span> <span class="keyword">=</span> pf3</span>
      <span class="prfexp"><span class="keyword">prval</span> SZB <span class="keyword">(</span>pf41<span class="keyword">,</span> pf42<span class="keyword">)</span> <span class="keyword">=</span> pf4</span>
<span class="comment">//</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf13<span class="keyword">,</span> pf31<span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf23<span class="keyword">,</span> pf41<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf14<span class="keyword">,</span> pf32<span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SZ_istot <span class="keyword">(</span>pf24<span class="keyword">,</span> pf42<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="prfexp"><span class="keyword">prval</span> pfeq1 <span class="keyword">=</span> lemma <span class="keyword">(</span>pf11<span class="keyword">,</span> pf21<span class="keyword">,</span> pf31<span class="keyword">,</span> pf41<span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> pfeq2 <span class="keyword">=</span> lemma <span class="keyword">(</span>pf12<span class="keyword">,</span> pf22<span class="keyword">,</span> pf32<span class="keyword">,</span> pf42<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      EQB <span class="keyword">(</span>pfeq1<span class="keyword">,</span> pfeq2<span class="keyword">)</span>
    <span class="keyword">end</span>
<span class="comment">//</span>
  <span class="keyword">|</span> <span class="keyword">(</span>isBraunE _<span class="keyword">,</span> isBraunB _<span class="keyword">)</span> <span class="keyword">=/=&gt;</span>
    <span class="keyword">let</span> <span class="prfexp"><span class="keyword">prval</span> SZE _ <span class="keyword">=</span> pf3 <span class="keyword">and</span> SZB _ <span class="keyword">=</span> pf4</span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*none*)</span> <span class="keyword">end</span></span>
  <span class="keyword">|</span> <span class="keyword">(</span>isBraunB _<span class="keyword">,</span> isBraunE _<span class="keyword">)</span> <span class="keyword">=/=&gt;</span>
    <span class="keyword">let</span> <span class="prfexp"><span class="keyword">prval</span> SZB _ <span class="keyword">=</span> pf3 <span class="keyword">and</span> SZE _ <span class="keyword">=</span> pf4</span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*none*)</span> <span class="keyword">end</span></span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">,</span> pf3<span class="keyword">,</span> pf4<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [lemma_unicity]</span>
</p></PRE
><P
></P
></DIV
>


This implementation corresponds to a proof by induction on the structure of
the given tree t1. Note that the use of the special symbol <FONT
COLOR="RED"
>=/=&#62;</FONT
>,
which is a keyword in ATS, is to indicate to the typechecker of ATS that
the involved clause of pattern matching is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unreachable</I
></SPAN
>: It is the
responsibility of the programmer to establish the falsehood on the
right-hand side of the clause. Please find the entirety of the above code
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_THMPRVING/brauntree.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="programmer_centric_theorem_proving"
>Programmer-Centric Theorem-Proving</A
></H2
><P
>&#13;I have so far presented several formal proofs in ATS.  However,
constructing such formal proofs is at most a secondary issue in ATS. If I
compare ATS with theorem-proving systems such as Isabelle and Coq, I would
like to state emphatically that the design for theorem-proving in ATS takes
a fundamentally different view of theorem-proving. In particular,
theorem-proving in ATS does not take a foundational approach that
establishes the validity of a theorem by reducing it to the validity of a
minimal set of axioms and rules. Instead, theorem-proving in ATS is mostly
done in a semi-formal manner and its primary purpose is to greatly diminish
the chance of a programmer making use of incorrect assumptions or
claims. In this regard, theorem-proving in ATS is rather similar to
contructing informal paper-and-pencil proofs (in mathematics and
elsewhere). I refer to this style of theorem-proving in ATS as being
programmer-centric.  In order to allow the reader to obtain a more concrete
feel as to what this style of theorem-proving is like, I present in the
rest of this section a simple but telling example of programmer-centric
theorem-proving.
</P
><P
>&#13;Suppose we are to prove that the square of any rational number cannot equal
2. Note that this statement is a bit weaker than the one stating that the
square root of 2 is irrational as the latter assumes the very existence of the
square root of 2. Let us first sketch an informal proof as follows.
</P
><P
>&#13;Suppose (m/n)<SUP
>2</SUP
>=2 for some positive numbers m and n. Clearly,
this means (m)<SUP
>2</SUP
>=2(n)<SUP
>2</SUP
>, implying m being an even number.
Let m=2m<SUB
>2</SUB
>. We have (2m<SUB
>2</SUB
>)<SUP
>2</SUP
>=2(n)<SUP
>2</SUP
>, implying
(n/m<SUB
>2</SUB
>)<SUP
>2</SUP
>=2. Clearly, m &#62; n &#62; m<SUB
>2</SUB
> holds. If we
assume that m is the least positive number satisfying (m/n)<SUP
>2</SUP
>=2 for
some n, then a contradiction is reached as n satisfies the same property.
Therefore, there is no rational number whose square equals 2. Clearly,
this proof still holds if the number 2 is replaced with another prime number.

</P
><P
>&#13;The primary argument in the above informal proof can be encoded in
ATS as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3108"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">prfun</span>
mylemma_main
<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int <span class="keyword">|</span> m*m==p*n*n<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">PRIME</span><span class="keyword">(</span><span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m2<span class="keyword">:</span>nat <span class="keyword">|</span> n*n==p*m2*m2<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">primplmnt</span>
mylemma_main
<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">}</span></span><span class="keyword">(</span>pfprm<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> pfeq_mm_pnn <span class="keyword">=</span>
    eqint_make<span class="staexp"><span class="keyword">{</span>m*m<span class="keyword">,</span>p*n*n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> square_is_nat<span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> square_is_nat<span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_PRIME_param<span class="keyword">(</span>pfprm<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span>
  pfmod1 <span class="keyword">=</span>
    lemma_MOD0_intr<span class="staexp"><span class="keyword">{</span>m*m<span class="keyword">,</span>p<span class="keyword">,</span>n*n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span>
  pfmod2 <span class="keyword">=</span> mylemma1<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>p<span class="keyword">}</span></span><span class="keyword">(</span>pfmod1<span class="keyword">,</span> pfprm<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span>
  <span class="keyword">[</span><span class="staexp">m2<span class="keyword">:</span>int</span><span class="keyword">]</span>
  EQINT<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
    lemma_MOD0_elim<span class="keyword">(</span>pfmod2<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> EQINT<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pfeq_mm_pnn</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  __assert<span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p*m2*m2<span class="keyword">,</span>n*n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="keyword">extern</span> <span class="prfexp"><span class="keyword">prfun</span> __assert<span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span> p*x==p*y<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>x==y<span class="keyword">]</span></span> <span class="staexp">void</span></span>
  <span class="keyword">}</span></span> <span class="comment">(* end of [where] *)</span> <span class="comment">// end of [prval]</span>
<span class="keyword">in</span>
  <span class="dynexp"><span class="keyword">#[</span>m2 <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">]</span></span>
<span class="keyword">end</span></span> <span class="comment">// end of [mylemma_main]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The interface for <FONT
COLOR="RED"
>mylemma_main</FONT
> states that
(m)<SUP
>2</SUP
>=p(n)<SUP
>2</SUP
> implies (n)<SUP
>2</SUP
>=p(m<SUB
>2</SUB
>)<SUP
>2</SUP
> for
some natural number m<SUB
>2</SUB
>.

</P
><P
>&#13;Given two integers m and p, <FONT
COLOR="RED"
>MOD0(m,p)</FONT
> means that m equals the
product of p and q for some natural number q. This meaning is encoded into
the following two proof functions:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3119"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma_MOD0_intr<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>p<span class="keyword">,</span>q<span class="keyword">:</span>nat <span class="keyword">|</span> m==p*q<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MOD0</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma_MOD0_elim<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">MOD0</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>q<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">EQINT</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">*</span><span class="staexp">q</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>EQINT</FONT
> is a dataprop declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3122"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span> <span class="staexp">EQINT<span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>int<span class="keyword">}</span></span> EQINT<span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">x</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


Given two integers x and y, <FONT
COLOR="RED"
>EQINT(x, y)</FONT
> simply means that
x equals y.  Also, the function <FONT
COLOR="RED"
>eqint_make</FONT
> is assgined the
interface below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3126"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span> eqint_make<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span> x == y<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">EQINT</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Given an integer p, <FONT
COLOR="RED"
>PRIME(p)</FONT
> means that p is a prime number.
The following two proof functions are called in the above implementation
of <FONT
COLOR="RED"
>mylemma_main</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3130"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma_PRIME_param<span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">PRIME</span><span class="keyword">(</span><span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p &gt;= 2<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> mylemma1<span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">MOD0</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">PRIME</span><span class="keyword">(</span><span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MOD0</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The proof function <FONT
COLOR="RED"
>mylemma1</FONT
> encodes a proposition stating that
p divides n if p divides the square of n and p is also a prime number.
I give no implementation of <FONT
COLOR="RED"
>mylemma1</FONT
> as I see the encoded
proposition to be obviously true. Certainly, this is a kind of programmer-centric
judgment. 
</P
><P
>&#13;One may find that
the following declaration in the implementation of <FONT
COLOR="RED"
>mylemma_main</FONT
>
looks mysterious:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3136"
></A
><PRE
CLASS="programlisting"
>  prval EQINT() = pfeq_mm_pnn
</PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>pfeq_mm_pnn</FONT
>
is of the prop <FONT
COLOR="RED"
>EQINT(m*m, p*(n*n))</FONT
>.
Also, m equaling p*m<SUB
>2</SUB
> for some natural number m<SUB
>2</SUB
> is
available when the above declaration is typechecked.
This means that the equality between
(p*m<SUB
>2</SUB
>)<SUP
>2</SUP
> and p*(n)<SUP
>2</SUP
> is added into the current store
of (static) assumptions after the above declaration is typechecked.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_THMPRVING/sqrt2_irrat.dats"
TARGET="_top"
>on-line</A
> the
entirety of an encoded proof showing that there exists no rational number whose
square equals 2.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="programming_with_theorem-proving"
></A
>Chapter 12. Programming with Theorem-Proving</H1
><P
>&#13;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>Programming with Theorem-Proving</I
></SPAN
> (PwTP) is a rich and broad
programming paradigm that allows cohesive construction of programs and
proofs in a syntactically intwined manner. The support for PwTP in ATS is a
signatory feature of ATS, and the novelty of ATS largely stems from it. For
people who are familiar with the so-called Curry-Howard isomorphism, I
emphasize that PwTP as is supported in ATS makes little, if any, essential
use of this isomorphism (between proofs and programs): The dynamics of ATS
in which programs are written is certainly not pure and the proofs encoded
in ATS/LF are not required to be constructive, either. However, that proof
construction in ATS can be done in a style of (functional) programming is
fundamentally important in terms of syntax design for ATS, for the need to
combine programs with proofs would otherwise be greatly more challenging.

</P
><P
>In this chapter, I will present some simple but convincing examples to
illustrate the power and flexibility of PwTP as is supported in
ATS. However, the real showcase for PwTP will not arrive until after the
introduction of linear types in ATS, when linear proofs can be combined
with programs to track and safely manipulate resources such as memory and
objects (e.g, file handles). In particular, PwTP is to form the cornersone
of the support for imperative programming in ATS.
</P
><P
>Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/"
TARGET="_top"
>on-line</A
>
the code employed for illustration in this chapter plus some additional
code for testing.</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="circumventing_nonlinear_constraints"
>Circumventing Nonlinear Constraints</A
></H2
><P
>&#13;The constraint-solver of ATS is of rather diminished power. In particular,
constraints containing nonlinear integer terms (e.g., those involving the
use of multiplication (of variables)) are immediately rejected. This
weakness must be properly addressed for otherwise it would become a
crippling limitation on practicality of the type system of ATS. I now use
a simple example to demonstrate how theorem-proving can be employed to
circumvent the need for handling nonlinear constraints directly.
</P
><P
>&#13;A function template <FONT
COLOR="RED"
>list_concat</FONT
> is implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3159"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="comment">// [list_concat] does typecheck in ATS2</span>
<span class="comment">// [list_concat] does not typecheck in ATS1</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_concat<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xss<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span> <span class="staexp">*</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xss <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>xs<span class="keyword">,</span> xss<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> list_concat xss<span class="keyword">)</span></span>
<span class="comment">// end of [list_concat]</span>
</p></PRE
><P
></P
></DIV
>


where the interface for <FONT
COLOR="RED"
>list_append</FONT
> is given below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3162"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_append <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Given a list <FONT
COLOR="RED"
>xss</FONT
> of length <FONT
COLOR="RED"
>m</FONT
> in which each element is of
the type <FONT
COLOR="RED"
>list(T,n)</FONT
> for some type T,
<FONT
COLOR="RED"
>list_concat&#60;T&#62;(xss)</FONT
> constructs a list of the type
<FONT
COLOR="RED"
>list(T,m*n)</FONT
>. When the first matching clause in the code for
<FONT
COLOR="RED"
>list_concat</FONT
> is typechecked, a constraint is generated that is
essentially like the following one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3170"
></A
><PRE
CLASS="programlisting"
>m = m1 + 1 implying n + (m1 * n) = m * n holds for all natural numbers m, m1 and n.
</PRE
><P
></P
></DIV
>


This contraint may look simple, but it was once rejected by the ATS
constraint solver as it contains nonlinear integer terms (e.g.,
<FONT
COLOR="RED"
>m1*n</FONT
> and <FONT
COLOR="RED"
>m*n</FONT
>). In order to overcome (or rather
circumvent) the limitation, we can make use of theorem-proving. Another
implementation of <FONT
COLOR="RED"
>list_concat</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3175"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_concat<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xss<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xss <span class="keyword">of</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span><span class="prfexp">MULbas<span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons <span class="keyword">(</span>xs<span class="keyword">,</span> xss<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> res<span class="keyword">)</span> <span class="keyword">=</span> list_concat <span class="keyword">(</span>xss<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">(</span><span class="prfexp">MULind pf</span> <span class="keyword">|</span> list_append&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list_cons]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_concat] *)</span>
</p></PRE
><P
></P
></DIV
>


Given a list <FONT
COLOR="RED"
>xss</FONT
> of the type <FONT
COLOR="RED"
>list(list(T,n),m)</FONT
>,
<FONT
COLOR="RED"
>list_concat(xss)</FONT
> now returns a pair <FONT
COLOR="RED"
>(pf | res)</FONT
> such
that <FONT
COLOR="RED"
>pf</FONT
> is a proof of the prop-type <FONT
COLOR="RED"
>MUL(m,n,p)</FONT
> for
some natural number <FONT
COLOR="RED"
>p</FONT
> and <FONT
COLOR="RED"
>res</FONT
> is a list of the type
<FONT
COLOR="RED"
>list(T,p)</FONT
>, where the symbol bar (|) is used to separate proofs
from values. In other words, <FONT
COLOR="RED"
>pf</FONT
> acts as a witness to the
equality <FONT
COLOR="RED"
>p=m*n</FONT
>. After proof erasure is performed, this
implementation of <FONT
COLOR="RED"
>list_concat</FONT
> is essentially translated into
the previous one (as far as dynamic semantics is concerned). In particular,
there is no need for proof construction at run-time.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_safe_matrix_subscripting"
>Example: Safe Matrix Subscripting</A
></H2
><P
>&#13;Internally, a matrix of the dimension m by n is represented as an array
of the size m*n. For matrix subscripting, we need to implement a function
template of the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3192"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> matrix_get
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> m<span class="keyword">;</span> j <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> col<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [matrix_get]</span>
</p></PRE
><P
></P
></DIV
>


Assume that the matrix is represented in the row-major style. Then the
element indexed by i and j in the matrix is the element indexed by i*n + j
in the array that represents the matrix, where i and j are natural numbers
less than m and n, respectively. However, the following implementation
fails to pass typechecking:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3194"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
matrix_get <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">,</span> j<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">A[i*n+j<span class="keyword">]</span></span></span> <span class="comment">// it fails to typecheck!!!</span>
</p></PRE
><P
></P
></DIV
>


The simple reason for this failure is due to the ATS constraint solver not
being able to automatically verify that i*n+j is a natural number strictly
less than m*n. An implementation of <FONT
COLOR="RED"
>matrix_get</FONT
> that typechecks
can be given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3197"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
matrix_get
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">,</span> j<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> _in_<span class="keyword">)</span> <span class="keyword">=</span> imul2 <span class="keyword">(</span>i<span class="keyword">,</span> n<span class="keyword">)</span></span>
<span class="comment">//</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> mul_elim<span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat<span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> mul_gte_gte_gte<span class="staexp"><span class="keyword">{</span>m-1-i<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">A[_in_+j<span class="keyword">]</span></span>
<span class="keyword">end</span></span> <span class="comment">// end of [matrix_get]</span>
</p></PRE
><P
></P
></DIV
>


where the functions called in the body of <FONT
COLOR="RED"
>matrix_get</FONT
>
are assigned the following interfaces:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3200"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
imul2<span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>ij<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">,</span> <span class="staexp">ij</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">ij</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_elim
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>ij<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">,</span> <span class="staexp">ij</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>i*j==ij<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_nat_nat_nat
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>ij<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">,</span> <span class="staexp">ij</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>ij &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
mul_gte_gte_gte
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m &gt;= 0<span class="keyword">;</span> n &gt;= 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m*n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Assume that m and n are natural numbers and i and j are natural numbers
less than m and n, respectively.  The proof code employed in the
implementation of <FONT
COLOR="RED"
>matrix_get</FONT
> to show i*n+j &#60; m*n proves
(m-1-i)*n &#62;= 0, which clearly implies m*n &#62;= i*n+n &#62; i*n+j.

</P
><P
>&#13;
Note that there are a variety of proof functions declared in
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/arith_prf.sats"
TARGET="_top"
>arith_prf.sats</A
> for helping prove
theorems involving arithmetic operations. For examples of proof
construction in ATS, please find the implementation of some of these proof
functions in <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/DATS/arith_prf.dats"
TARGET="_top"
>arith_prf.dats</A
>.
</P
><P
>&#13;The entirety of the above presented code is available
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/matget.dats"
TARGET="_top"
>on-line</A
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="specifying_with_precision"
>Specifying with Enhanced Precision</A
></H2
><P
>&#13;The integer addition function can be assigned the following
(dependent) type in ATS to indicate that it returns the sum of
its two integer arguments:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3211"
></A
><PRE
CLASS="programlisting"
>{i,j:int} (int(i), int(j)) -&#62; int(i+j)
</PRE
><P
></P
></DIV
>


This type gives a full specification of integer addition as the only
(terminating) function that can be given the type is the integer addition
function. However, the factorial function, which yields the product of the
first n positive integers when applied to a natural number n, cannot be
given the following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3213"
></A
><PRE
CLASS="programlisting"
>{n:int | n &#62;= 0} int(n) -&#62; int(fact(n))</PRE
><P
></P
></DIV
>


as <FONT
COLOR="RED"
>fact</FONT
>, which refers to the factorial function, does not exist in
the statics of ATS. Evidently, a highly interesting and relevant question is
whether a type can be formed in ATS that fully captures the functional
relation specified by <FONT
COLOR="RED"
>fact</FONT
>? The answer is affirmative. We can not
only construct such a type but also assign it to a (terminating) function
implemented in ATS.
</P
><P
>Let us recall that the factorial function can be defined by the following
two equations:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3218"
></A
><PRE
CLASS="programlisting"
>fact(0) = 1
fact(n) = n * fact(n-1) (for all n &#62; 0)
</PRE
><P
></P
></DIV
>


Naturally, these equations can be encoded by the constructors associated
with the dataprop <FONT
COLOR="RED"
>FACT</FONT
> declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3221"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">FACT<span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">FACTbas<span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>r1<span class="keyword">,</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span>
    FACTind<span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">FACT</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">r1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r1</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [FACT]</span>
</p></PRE
><P
></P
></DIV
>


Note that for any given natural number n and integer r, <FONT
COLOR="RED"
>FACT(n,
r)</FONT
> can be assigned to a proof if and only if <FONT
COLOR="RED"
>fact(n)</FONT
> equals
r. Therefore, the following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3225"
></A
><PRE
CLASS="programlisting"
>{n:nat} int(n) -&#62; [r:int] (FACT(n, r) | int(r))
</PRE
><P
></P
></DIV
>


can only be assigned to a function that, if applied to a natural number n,
returns a proof and an integer such that the proof attests to the integer
being equal to <FONT
COLOR="RED"
>fact(n)</FONT
>. For instance, the following defined
function <FONT
COLOR="RED"
>ifact</FONT
> is assigned this type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3229"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ifact
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">FACT</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
n <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="keyword">then</span> <span class="keyword">(</span><span class="prfexp">FACTbas<span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> r1<span class="keyword">)</span> <span class="keyword">=</span> ifact <span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span></span> <span class="comment">// pf1: FACT(n-1, r1)</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfmul</span> <span class="keyword">|</span> r<span class="keyword">)</span> <span class="keyword">=</span> imul2 <span class="keyword">(</span>n<span class="keyword">,</span> r1<span class="keyword">)</span></span> <span class="comment">// pfmul: FACT(n, r1, r)</span>
<span class="keyword">in</span>
  <span class="keyword">(</span><span class="prfexp">FACTind<span class="keyword">(</span>pf1<span class="keyword">,</span> pfmul<span class="keyword">)</span></span> <span class="keyword">|</span> r<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [ifact] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


After proof erasure, <FONT
COLOR="RED"
>ifact</FONT
> precisely implements the factorial
function.

</P
><P
>&#13;Please find the entirety of the above presented code plus some testing code
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/ifact.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_another_verified_factorial"
>Example: Another Verified Factorial</A
></H2
><P
>&#13;The function <FONT
COLOR="RED"
>ifact</FONT
> presented in the section on <A
HREF="#specifying_with_precision"
>specifying with enhanced precision</A
> is a verified implementation of
the factorial function as its type guarantees that <FONT
COLOR="RED"
>ifact</FONT
>
implements the specification of factorial encoded by the dataprop
<FONT
COLOR="RED"
>FACT</FONT
>. Clearly, the implementation of <FONT
COLOR="RED"
>ifact</FONT
> closely
follows the declaration of <FONT
COLOR="RED"
>FACT</FONT
>. If we think of the latter as a
logic program, then the former is essentially a functional version
extracted from the logic program. However, the implementation of a
specification in practice can often digress far from the specification
algorithmically. For instance, we may want to have a verified
implementation of factorial that is also tail-recursive. This can be done
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3243"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
ifact2
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span>
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">FACT</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">|</span>i &lt;= n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">FACT</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">r</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">FACT</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> n - i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfmul</span> <span class="keyword">|</span> r1<span class="keyword">)</span> <span class="keyword">=</span> imul2 <span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">in</span> loop <span class="keyword">(</span><span class="prfexp">FACTind<span class="keyword">(</span>pf<span class="keyword">,</span> pfmul<span class="keyword">)</span></span> <span class="keyword">|</span> n<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> r1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> r<span class="keyword">)</span></span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">FACTbas<span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> n<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [ifact2]</span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>ifact2</FONT
> is assigned a type indicating that
<FONT
COLOR="RED"
>ifact2</FONT
> is a verified implementation of factorial, and it is
defined as a call to the inner function <FONT
COLOR="RED"
>loop</FONT
> that is clearly
tail-recursive.  If we erase types and proofs, the function <FONT
COLOR="RED"
>ifact2</FONT
>
is essentially defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3249"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> ifact2 <span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>n<span class="keyword">,</span> i<span class="keyword">,</span> r<span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> n - i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> r1 <span class="keyword">=</span> <span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">)</span> * r</span> <span class="keyword">in</span> loop <span class="keyword">(</span>n<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> r1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> r</span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>n<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [ifact2]</span>
</p></PRE
><P
></P
></DIV
>


When the inner function <FONT
COLOR="RED"
>loop</FONT
> is called on three arguments n, i
and r, the precondition for this call is that i is natural number less than
or equal to n and r equals fact(i), that is, the value of the factorial
function on i. This precondition is captured by the type assigned to
<FONT
COLOR="RED"
>loop</FONT
> and thus enforced at each call site of <FONT
COLOR="RED"
>loop</FONT
> in
the implementation of <FONT
COLOR="RED"
>ifact2</FONT
>.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/ifact23.dats"
TARGET="_top"
>on-line</A
>
the entirety of the above presented code plus some testing code.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_verified_fast_exponentiation"
>Example: Verified Fast Exponentiation</A
></H2
><P
>Given an integer x, pow(x, n), the nth power of x, can be defined
inductively as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3260"
></A
><PRE
CLASS="programlisting"
>pow (x, 0) = 1
pow (x, n) = x * pow (x, n-1) (for all n &#62; 0)
</PRE
><P
></P
></DIV
>


A direct implementation of this definition is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3262"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> ipow <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> x * ipow <span class="keyword">(</span>x<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
<span class="comment">// end of [ipow]</span>
</p></PRE
><P
></P
></DIV
>


which is of time-complexity O(n) (assuming multiplication is O(1)). A
more efficient implmentation can be given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3264"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
ifastpow
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half<span class="keyword">(</span>n<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> i2 <span class="keyword">=</span> n-<span class="keyword">(</span><span class="dynexp">2</span>*n2<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> i2 <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> ifastpow <span class="keyword">(</span>x*x<span class="keyword">,</span> n2<span class="keyword">)</span> <span class="keyword">else</span> x * ifastpow <span class="keyword">(</span>x*x<span class="keyword">,</span> n2<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="dynexp">1</span></span> <span class="comment">// end of [if]</span>
<span class="comment">// end of [ifastpow]</span>
</p></PRE
><P
></P
></DIV
>


which makes use of the property that pow(x, n) equals pow(x*x, n/2) if n is
even or x * pow(x*x, n/2) if n is odd. This is referred to as fast
exponentiation. Note that <FONT
COLOR="RED"
>ifastpow</FONT
> is of time-complexity O(log(n)).

</P
><P
>&#13;Clearly, what is done above is not restricted to exponentiation on
integers. As long as the underlying multiplication is associative, fast
exponentiation can be employed to compute powers of any given element. In
particular, powers of square matrices can be computed in this way.  I now
present as follows a verified generic implementation of fast exponentiation.

</P
><P
>Handling generic data properly in a verified implementation often requires some
finesse with the type system of ATS. Let us first introduce an abstract type
constructor <FONT
COLOR="RED"
>ELT</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3270"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">sortdef</span> elt <span class="keyword">=</span> int</span> <span class="comment">// [elt] is just an alias for [int]</span>
<span class="staexp"><span class="keyword">abst@ype</span> ELT<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">,</span> x<span class="keyword">:</span>elt<span class="keyword">)</span> <span class="keyword">=</span> a</span> <span class="comment">// [x] is an imaginary stamp</span>
</p></PRE
><P
></P
></DIV
>


This is often referred to as <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>stamping</I
></SPAN
>. For each type T and stamp
x, <FONT
COLOR="RED"
>ELT(T, x)</FONT
> is just T as far as data representation is concerned.
The stamps are imaginary and they are solely used for the purpose of
specification. Let us next introduce an abstract prop-type <FONT
COLOR="RED"
>MUL</FONT
> and
a function template <FONT
COLOR="RED"
>mul_elt_elt</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3276"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absprop</span> MUL<span class="keyword">(</span>elt<span class="keyword">,</span> elt<span class="keyword">,</span> elt<span class="keyword">)</span></span> <span class="comment">// abstract mul relation</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
mul_elt_elt<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>elt<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>xy<span class="keyword">:</span>elt<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [mul_elt_elt]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Please do not confuse <FONT
COLOR="RED"
>MUL</FONT
> with the one of the same name that is
declared in <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/ATS-Postiats/prelude/SATS/arith_prf.sats"
TARGET="_top"
>arith_prf.sats</A
>. To
state that the encoded multiplication is associative, we can introduce the
following proof function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3280"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">praxi</span>
mul_assoc
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">,</span>z<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>xy<span class="keyword">,</span>yz<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>xy_z<span class="keyword">,</span>x_yz<span class="keyword">:</span>elt<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">xy</span><span class="keyword">,</span> <span class="staexp">z</span><span class="keyword">,</span> <span class="staexp">xy_z</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">z</span><span class="keyword">,</span> <span class="staexp">yz</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">yz</span><span class="keyword">,</span> <span class="staexp">x_yz</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>xy_z==x_yz<span class="keyword">]</span></span> <span class="staexp">void</span></span> <span class="comment">// end of [mul_assoc]</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>praxi</FONT
> indicates that <FONT
COLOR="RED"
>mul_assoc</FONT
> is treated as
a form of axiom, which is not expected to be implemented.

</P
><P
>&#13;The abstract power function can be readily specified in terms of the
abstract prop-type <FONT
COLOR="RED"
>MUL</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3286"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">POW <span class="keyword">(</span>
  elt<span class="comment">(*base*)</span><span class="keyword">,</span> int<span class="comment">(*exp*)</span><span class="keyword">,</span> elt<span class="comment">(*res*)</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// res = base^exp</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>elt<span class="keyword">}</span></span>
    POWbas<span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">1</span><span class="comment">(*unit*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">,</span>p1<span class="keyword">:</span>elt<span class="keyword">}</span></span>
    POWind<span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">POW</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [POW]</span>
</p></PRE
><P
></P
></DIV
>


As can be expected, generic fast exponentiation is given the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3288"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
fastpow_elt_int<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>elt<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">POW</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [fastpow_elt_int]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;With the preparation done above, a straightforward implementation of
<FONT
COLOR="RED"
>fastpow_elt_int</FONT
> can now be presented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3292"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fastpow_elt_int
  <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="comment">(*
lemma: (x*x)^n = x^(2n)
*)</span>
<span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>xx<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>elt<span class="keyword">}</span></span>
  <span class="keyword">(</span>pfxx<span class="keyword">:</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">xx</span><span class="keyword">)</span><span class="keyword">,</span> pfpow<span class="keyword">:</span> <span class="staexp">POW</span><span class="keyword">(</span><span class="staexp">xx</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">POW</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">2</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> * <span class="keyword">with</span> mul_elt_elt</span> <span class="comment">// [*] loaded with mul_elt_elt</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
n <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> mulunit&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">(</span><span class="prfexp">POWbas <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">|</span> res<span class="keyword">)</span> <span class="comment">// res = 1</span>
<span class="keyword">end</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half n</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfxx</span> <span class="keyword">|</span> xx<span class="keyword">)</span> <span class="keyword">=</span> x * x</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfpow2</span> <span class="keyword">|</span> res<span class="keyword">)</span> <span class="keyword">=</span> fastpow_elt_int&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xx<span class="keyword">,</span> n2<span class="keyword">)</span></span> <span class="comment">// xx^n2 = res</span>
  <span class="prfexp"><span class="keyword">prval</span> pfpow <span class="keyword">=</span> lemma <span class="keyword">(</span>pfxx<span class="keyword">,</span> pfpow2<span class="keyword">)</span></span> <span class="comment">// pfpow: x^(2*n2) = res</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> n<span class="keyword">=</span><span class="dynexp">2</span>*n2
    <span class="keyword">then</span> <span class="keyword">(</span><span class="prfexp">pfpow</span> <span class="keyword">|</span> res<span class="keyword">)</span>
    <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfmul</span> <span class="keyword">|</span> xres<span class="keyword">)</span> <span class="keyword">=</span> x * res</span> <span class="keyword">in</span> <span class="keyword">(</span><span class="prfexp">POWind<span class="keyword">(</span>pfpow<span class="keyword">,</span> pfmul<span class="keyword">)</span></span> <span class="keyword">|</span> xres<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fastpow_elt_int]</span>
</p></PRE
><P
></P
></DIV
>


Note that this implementation of <FONT
COLOR="RED"
>fastpow_elt_int</FONT
> is not
tail-recursive.  The function template <FONT
COLOR="RED"
>mulunit</FONT
>, which is called to
produce a unit for the underlying multiplication, is assigned the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3296"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> mulunit <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ELT</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">1</span><span class="comment">(*stamp*)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The proof function <FONT
COLOR="RED"
>lemma</FONT
> simply establishes that pow(x, 2*n)=
pow(x*x, n) for each natural number n.  I have made an implementation of
<FONT
COLOR="RED"
>lemma</FONT
> available on-line but I suggest that the interested
reader give it a try first to implement <FONT
COLOR="RED"
>lemma</FONT
> before taking a
look at the given implementation. Note that the following axioms are needed
to implement <FONT
COLOR="RED"
>lemma</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3302"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
mul_istot <span class="comment">// MUL is total</span>
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>elt<span class="keyword">}</span></span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>xy<span class="keyword">:</span>elt<span class="keyword">]</span></span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
mul_isfun <span class="comment">// MUL is functional</span>
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>z1<span class="keyword">,</span>z2<span class="keyword">:</span>elt<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">z1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">MUL</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">z2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>z1==z2<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Another interesting (and possibly a bit challenging) exercise is to
implement <FONT
COLOR="RED"
>fastpow_elt_int</FONT
> in a tail-recursive fashion.

</P
><P
>&#13;Please find on-line the two files
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/fastexp.sats"
TARGET="_top"
>fastexp.sats</A
> and
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/fastexp.dats"
TARGET="_top"
>fastexp.dats</A
> that contain the
entirety of the above presented code.

</P
><P
>&#13;Now we have implemented <FONT
COLOR="RED"
>fastpow_elt_int</FONT
>. How can it be used?
Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/test_fastexp.dats"
TARGET="_top"
>on-line</A
> an
example in which <FONT
COLOR="RED"
>fastpow_elt_int</FONT
> is called to implement fast
exponentiation on a 2-by-2 matrix so that the Fibonacci numbers can be computed
in a highly efficient manner.

</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="programming-with-linear-views-and-types"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
>IV. Programming with Views and Viewtypes</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>13. <A
HREF="#introduction-to-views-and-viewtypes"
>Introduction to Views and Viewtypes</A
></DT
><DT
>14. <A
HREF="#dataviews"
>Dataviews as Linear Dataprops</A
></DT
><DT
>15. <A
HREF="#dataviewtypes"
>Dataviewtypes as Linear Datatypes</A
></DT
><DT
>16. <A
HREF="#abstract_views_viewtypes"
>Abstract Views and Viewtypes</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="introduction-to-views-and-viewtypes"
></A
>Chapter 13. Introduction to Views and Viewtypes</H1
><P
>&#13;Probably the single greatest motivation behind the development of ATS is
the desire to make ATS a programming language that can be employed
effectively to construct safe and reliable programs running in the kernels
of operating systems. Instead of following seemingly natural approaches
that often focus on carving out a "safe" subset of C and/or put wrappers
around "unsafe" programming features in C, ATS relies on the paradigm of
programming with theorem-proving to prevent resources such as memory from
being misused or mismanaged, advocating an approach to safety that is both
general and flexible. For example, a well-typed program constructed in ATS
cannot cause buffer overrun at run-time even though pointer arithmetic is
fully supported in ATS. More specifically, if a pointer is to be
dereferenced, ATS requires that a proof be given attesting to the safety of
the dereferencing operation. Proofs of this kind are constructed to
demonstrate the validity of linear propositions, which are referred to as
views in ATS, for classifying resources as well as capabilities.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_VVTINTRO/"
TARGET="_top"
>on-line</A
> the code presented
for illustration in this chapter.

</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="views_for_pointers"
>Views for Memory Access through Pointers</A
></H2
><P
>&#13;A view is a linear version of prop, where the word <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>linear</I
></SPAN
>
comes from linear logic, a resource-aware logic invented by Jean-Yves
Girard. There is a built-in sort <FONT
COLOR="RED"
>view</FONT
> for static terms
representing views.  Given a type T and a memory location L, a view of the
form <FONT
COLOR="RED"
>T@L</FONT
> can be formed to indicate a value of the type T being stored in
the memory at the location L, where <FONT
COLOR="RED"
>@</FONT
> is a special infix
operator.  Views of this form are extremely common in practice, and they
are often referred to as at-views.  As an example, the following function
templates <FONT
COLOR="RED"
>ptr_get0</FONT
> and <FONT
COLOR="RED"
>ptr_set0</FONT
>, which reads and
writes through a given pointer, are assigned types containing at-views:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3328"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ptr_get0 <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="keyword">|</span> <span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ptr_set0 <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">a</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="keyword">|</span> <span class="staexp">void</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Note that <FONT
COLOR="RED"
>ptr</FONT
> is a type constructor that forms a type
<FONT
COLOR="RED"
>ptr(L)</FONT
> when applied to a static term L of the sort
<FONT
COLOR="RED"
>addr</FONT
>, and the only value of the type <FONT
COLOR="RED"
>ptr(L)</FONT
> is the
pointer that points to the location denoted by L.

</P
><P
>&#13;Given a type T, the function <FONT
COLOR="RED"
>ptr_get0&#60;T&#62;</FONT
> is assigned the
following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3337"
></A
><PRE
CLASS="programlisting"
>{l:addr} (T @ l | ptr (l)) -&#62; (T @ l | T)
</PRE
><P
></P
></DIV
>


which indicates that the function <FONT
COLOR="RED"
>ptr_get0&#60;T&#62;</FONT
> returns a
proof of the view <FONT
COLOR="RED"
>T@L</FONT
> and a value of the type T when applied to
a proof of the view <FONT
COLOR="RED"
>T@L</FONT
> and a pointer of the type
<FONT
COLOR="RED"
>ptr(L)</FONT
> for some L. Intuitively speaking, a proof of the view
<FONT
COLOR="RED"
>T@L</FONT
>, which is a form of resource as <FONT
COLOR="RED"
>T@L</FONT
> is linear, is
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>consumed</I
></SPAN
> when it is passed to <FONT
COLOR="RED"
>ptr_get0&#60;T&#62;</FONT
>,
and another proof of the same view <FONT
COLOR="RED"
>T@L</FONT
> is generated when
<FONT
COLOR="RED"
>ptr_get0&#60;T&#62;</FONT
> returns. Notice that a proof of the view
<FONT
COLOR="RED"
>T@L</FONT
> must be returned for otherwise subsequent accesses to the
memory location L would have been precluded.

</P
><P
>&#13;Similarly, the function <FONT
COLOR="RED"
>ptr_set0&#60;T&#62;</FONT
> is assigned the
following type:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3352"
></A
><PRE
CLASS="programlisting"
>{l:addr} (T? @ l | ptr (l), T) -&#62; (T @ l | void)
</PRE
><P
></P
></DIV
><P
>&#13;Note that T? is a type for values of size <FONT
COLOR="RED"
>sizeof(T)</FONT
> that are
assumed to be uninitialized.  The function <FONT
COLOR="RED"
>ptr_set0&#60;T&#62;</FONT
>
returns a proof of the view <FONT
COLOR="RED"
>T@L</FONT
> when applied to a proof of the
view <FONT
COLOR="RED"
>T?@L</FONT
>, a pointer of the type <FONT
COLOR="RED"
>ptr(L)</FONT
> and a value
of the type T. The use of the view <FONT
COLOR="RED"
>T?@L</FONT
> indicates that the
memory location at L is assumed to be uninitialized when
<FONT
COLOR="RED"
>ptr_set0&#60;T&#62;</FONT
> is called.

</P
><P
>&#13;As an example, a function template <FONT
COLOR="RED"
>swap0</FONT
> is implemented as follows
for swapping memory contents at two given locations:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3364"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
swap0<span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l1</span></span><span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l2</span></span>
<span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l2</span> <span class="keyword">|</span> <span class="staexp">void</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> x1<span class="keyword">)</span> <span class="keyword">=</span> ptr_get0&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> p1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> x2<span class="keyword">)</span> <span class="keyword">=</span> ptr_get0&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> p2<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set0&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> p1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set0&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> p2<span class="keyword">,</span> x1<span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">(</span><span class="prfexp">pf1</span><span class="keyword">,</span> <span class="prfexp">pf2</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [swap0]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Compared to a corresponding implementation in C, the verbosity of this one
in ATS is evident. In particular, the need for <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>threading</I
></SPAN
>
linear proofs through calls to functions that make use of resources can
often result in a lot of <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>administrative</I
></SPAN
> code to be written. I
now present some special syntax to significantly alleviate the need for
such administrative code.

</P
><P
>&#13;The function templates <FONT
COLOR="RED"
>ptr_get1</FONT
> and <FONT
COLOR="RED"
>ptr_set1</FONT
> are
given the following interfaces:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3372"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ptr_get1 <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ptr_set1 <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Clearly, for each type T, the function
<FONT
COLOR="RED"
>ptr_get1&#60;T&#62;</FONT
> is assigned the following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3375"
></A
><PRE
CLASS="programlisting"
>{l:addr} (!T @ l &#62;&#62; T @ l | ptr(l)) -&#62; T
</PRE
><P
></P
></DIV
>


Given a linear proof pf of the view <FONT
COLOR="RED"
>T@L</FONT
> for some L and a
pointer p of the type <FONT
COLOR="RED"
>ptr(L)</FONT
>, the function call
<FONT
COLOR="RED"
>ptr_get1&#60;T&#62;</FONT
>(pf, p) is expected to return a value of the
type T. However, the proof pf is not consumed. Instead, it is still a proof
of the view <FONT
COLOR="RED"
>T@L</FONT
> after the function call returns. Similarly, the
function <FONT
COLOR="RED"
>ptr_set1&#60;T&#62;</FONT
> is assigned the following type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3382"
></A
><PRE
CLASS="programlisting"
>{l:addr} (!T? @ l &#62;&#62; T @ l | ptr(l), T) -&#62; void
</PRE
><P
></P
></DIV
>


Given a linear proof pf of the view <FONT
COLOR="RED"
>T?@L</FONT
> for some L, a pointer
p of the type <FONT
COLOR="RED"
>ptr(L)</FONT
> and a value v of the type T, the function
call <FONT
COLOR="RED"
>ptr_set1&#60;T&#62;</FONT
>(pf, p, v) is expected to return the void
value while changing the view of pf from <FONT
COLOR="RED"
>T?@L</FONT
> to
<FONT
COLOR="RED"
>T@L</FONT
>.  In general, assume that f is given a type of the
following form for some views V1 and V2:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3389"
></A
><PRE
CLASS="programlisting"
>(...,!V1 &#62;&#62; V2, ...) -&#62; ...
</PRE
><P
></P
></DIV
>


Then a function call f(..., pf, ...) on some proof variable pf of the view
V1 is to change the view of pf into V2 upon its return.  In the case where
V1 and V2 are the same, !V1 &#62;&#62; V2 can simply be written as !V1.  As an
example, a function template <FONT
COLOR="RED"
>swap1</FONT
> for swapping the contents at
two given memory locations is implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3392"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
swap1<span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l1</span></span><span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l2</span></span> <span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l1</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l2</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> ptr_get1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> p1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> p1<span class="keyword">,</span> ptr_get1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> p2<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> p2<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [swap1]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation is considerably cleaner when compared to the
above implementation of <FONT
COLOR="RED"
>swap0</FONT
>.

</P
><P
>&#13;A further simplied implementation of <FONT
COLOR="RED"
>swap1</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3397"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
swap1<span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l1</span></span><span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l2</span></span>
<span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> tmp <span class="keyword">=</span> <span class="keyword">!</span>p1</span> <span class="keyword">in</span> <span class="keyword">!</span>p1 := <span class="keyword">!</span>p2<span class="keyword">;</span> <span class="keyword">!</span>p2 := tmp
<span class="keyword">end</span></span> <span class="comment">// end of [swap1]</span>
</p></PRE
><P
></P
></DIV
>


Given a pointer p of the type <FONT
COLOR="RED"
>ptr(L)</FONT
> for some L, <FONT
COLOR="RED"
>!p</FONT
>
yields the value stored at the memory location L.  The typechecker first
searches for a proof of the view <FONT
COLOR="RED"
>T@L</FONT
> for some T among all the
currently available proofs when typechecking <FONT
COLOR="RED"
>!p</FONT
>; if such a
proof pf is found, then <FONT
COLOR="RED"
>!p</FONT
> is essentially elaborated into
<FONT
COLOR="RED"
>ptr_get1(pf | p)</FONT
> and then typechecked. As <FONT
COLOR="RED"
>!p</FONT
> is a
left-value (which is to be explained later in detail), it can also be used
to form an assignment like <FONT
COLOR="RED"
>!p := v</FONT
> for some value v. The
typechecker elaborates <FONT
COLOR="RED"
>!p := v</FONT
> into <FONT
COLOR="RED"
>ptr_set1(pf | p,
v)</FONT
> for the sake of typechecking if a proof of the at-view <FONT
COLOR="RED"
>T@L</FONT
>
can be found for some type T among all the currently available proofs. Note
that this implementation of <FONT
COLOR="RED"
>swap1</FONT
> makes no use of
administrative code for handling linear proofs explicitly.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="viewtypes_as_combination"
>Viewtypes as a Combination of Views and Types</A
></H2
><P
>&#13;A linear type in ATS is given the name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>viewtype</I
></SPAN
>, which is
chosen to indicate that a linear type consists of two parts: one part for
views and the other for types. For instance, given a view V and a type T,
then the tuple (V | T) is a viewtype, where the bar symbol (|) is a
separator (just like a comma) to separate views from types. What seems a
bit surprising is the opposite: For each viewtype VT, we may assume the
existence of a view V and a type T such that VT is equivalent to (V |
T). Formally, this T can be referred as VT?! in ATS.  This somewhat
unexpected interpretation of linear types is a striking novelty of ATS,
which stresses that the linearity of a viewtype comes <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>entirely</I
></SPAN
>
from the view part residing within it.

</P
><P
>&#13;The built-in sorts <FONT
COLOR="RED"
>viewtype</FONT
> and <FONT
COLOR="RED"
>viewt@ype</FONT
> are for static
terms representing viewtypes whose type parts are of the sorts
<FONT
COLOR="RED"
>type</FONT
> and <FONT
COLOR="RED"
>t@ype</FONT
>, respectively. In other words, the former
is assigned to viewtypes for linear values of the size equal to that of a
pointer and the latter to viewtypes for linear values of unspecified size.
For example, <FONT
COLOR="RED"
>tptr</FONT
> is defined as follows that takes a type and an
address to form a viewtype (of the sort <FONT
COLOR="RED"
>viewtype</FONT
>):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3423"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">vtypedef</span> <span class="staexp">tptr <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Given a type T and an address L, the viewtype <FONT
COLOR="RED"
>tptr(T, L)</FONT
> is for
a pointer to L paired with a linear proof stating that a value of the type
T is stored at L. If we think of a counter as a pointer paired with a proof
stating that the pointer points to an integer (representing the count),
then the following defined function <FONT
COLOR="RED"
>getinc</FONT
> returns the current
count of a given counter after increasing it by 1:
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3427"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> getinc
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  cnt<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">tptr</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">tptr</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> n <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> n <span class="keyword">=</span> ptr_get1&lt;<span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">cnt<span class="dynexp"><span class="keyword">.0</span></span></span> <span class="keyword">|</span> cnt<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set1&lt;<span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">cnt<span class="dynexp"><span class="keyword">.0</span></span></span> <span class="keyword">|</span> cnt<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> n+<span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">(* end of [getinc] *)</span>
</p></PRE
><P
></P
></DIV
>

</P
><P
>&#13;A particularly interesting example of a viewtype is the following one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3430"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">vtypedef</span> <span class="staexp">cloptr
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">b<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="staexp"><span class="keyword">[</span>env<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">]</span></span> <span class="keyword">(</span><span class="keyword">(</span><span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">env</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">// end of [cloptr_app]</span>
</p></PRE
><P
></P
></DIV
>


Given two types A and B, a pointer to some address L where a closure
function is stored that takes a value of the type A to return a value of
the type B can be given the viewtype <FONT
COLOR="RED"
>cloptr(A, B, L)</FONT
>. Note that
a closure function is just an envless function paired with an environment
containing bindings for variables in the body of the closure function that
are introduced from outside. In the function type <FONT
COLOR="RED"
>(&#38;env, a)
-&#62; b</FONT
>, the symbol <FONT
COLOR="RED"
>&#38;</FONT
> indicates that the corresponding
function argument is passed by reference, that is, the argument is required
to be a left-value and what is actually passed at run-time is the address
of the left-value.  I will cover the issue of call-by-reference elsewhere
in more details.  The following piece of code demonstrates a pointer to a
closure function being called on a given argument:
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3435"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> cloptr_app <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pclo<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cloptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">b</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p <span class="keyword">=</span> pclo<span class="dynexp"><span class="keyword">.1</span></span></span>
<span class="comment">(*
//
// taking out pf: ((&amp;env, a) -&gt; b, env) @ l
//
  prval pf = pclo.0
//
*)</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> <span class="keyword">!</span>p<span class="dynexp"><span class="keyword">.0</span></span> <span class="keyword">(</span><span class="keyword">!</span>p<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="comment">(*
  prval () = pclo.0 := pf // putting the proof pf back
*)</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [cloptr]</span>
</p></PRE
><P
></P
></DIV
>


Note that the linear proof in <FONT
COLOR="RED"
>pclo</FONT
> is first taken out so that
the code for dereferencing p (denoted by the syntax <FONT
COLOR="RED"
>!p</FONT
>) can
pass typechecking, and it is then returned so that the type of
<FONT
COLOR="RED"
>pclo</FONT
> is restored to its original one. This process of taking
out a linear proof from a record and then putting it back into the record
can be automatically performed by the typechecker of ATS.

</P
><P
>&#13;The very ability to explain within ATS programming features such as closure
function is a convincing indication of the expressiveness of the type
system of ATS.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="lval_and_cbr"
>Left-Values and Call-by-Reference</A
></H2
><P
>&#13;In its simplest form, a left-value is just a pointer paired with a linear
proof attesting to a value (of some type) being stored at the location to
which the pointer points. The name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>left-value</I
></SPAN
> stems from such a
value being allowed to appear on the left-hand side of an assignment
statement (in languages like C). Often, a left-value is intuitively
explained as a value with an address attached to it. Note that whatever
representation chosen for a left-value must make it possible to identify
both the pointer and the linear proof (of some at-view) that are associated
with the left-value.

</P
><P
>&#13;In ATS, the simplest expression representing a left-value is
<FONT
COLOR="RED"
>!p</FONT
>, where <FONT
COLOR="RED"
>!</FONT
> is a special symbol and p a value of
the type <FONT
COLOR="RED"
>ptr(L)</FONT
> for some address L. When this expression is
typechecked, a proof of <FONT
COLOR="RED"
>T@L</FONT
> for some type T is required to be
found among the currently available proofs. I will introduce additional
forms of left values gradually.

</P
><P
>&#13;The default strategy for passing a function argument in ATS is
call-by-value. However, it is also allowed in ATS to specify that
call-by-reference is chosen for passing a particular function argument. By
call-by-reference, it is meant that the argument to be passed must be a
left-value and what is actually passed is the address of the left-value
(instead of the value stored at the address). For example, the following
defined function <FONT
COLOR="RED"
>swap2</FONT
> makes essential use of
call-by-reference:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3452"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> swap2 <span class="keyword">(</span>
  x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> tmp <span class="keyword">=</span> x1</span> <span class="keyword">in</span> x1 := x2<span class="keyword">;</span> x2 := tmp
<span class="keyword">end</span></span> <span class="comment">// end of [swap2]</span>
</p></PRE
><P
></P
></DIV
>


Note that the special symbol <FONT
COLOR="RED"
>&#38;</FONT
> in front of the type of a
function argument indicates that the argument needs to be passed according
to the call-by-reference strategy. The following code implements
<FONT
COLOR="RED"
>swap1</FONT
> based on <FONT
COLOR="RED"
>swap2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3457"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> swap1<span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l1</span></span><span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l2</span></span> <span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l1</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l2</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> swap2 <span class="keyword">(</span><span class="keyword">!</span>p1<span class="keyword">,</span> <span class="keyword">!</span>p2<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


When the call <FONT
COLOR="RED"
>swap2(!p1, !p2)</FONT
> is evaluated at run-time, the
parameters actually being passed are the two pointers <FONT
COLOR="RED"
>p1</FONT
> and
<FONT
COLOR="RED"
>p2</FONT
> (rather than the values stored at the locations to which
these two pointers point).
</P
><P
>&#13;Given a type T and an integer N, the syntax <FONT
COLOR="RED"
>@[T][N]</FONT
> stands for
a flat array consisting N elements of the type T. Please note that a value
of the type <FONT
COLOR="RED"
>@[T][N]</FONT
> is of the size N*sizeof(T). If a function
has a parameter representing an array, then this parameter is most liklely
call-by-reference. For instance, the following code implements a function
that takes two arrays of doubles to compute their dot product (also knowns
as inner product):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3465"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> dotprod 
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">double</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span>
<span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">double</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">double</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="dynexp">A[0<span class="keyword">]</span></span> * <span class="dynexp">B[0<span class="keyword">]</span></span> + <span class="dynexp">A[1<span class="keyword">]</span></span> * <span class="dynexp">B[1<span class="keyword">]</span></span> + <span class="dynexp">A[2<span class="keyword">]</span></span> * <span class="dynexp">B[2<span class="keyword">]</span></span>
<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Note that both array arguments of <FONT
COLOR="RED"
>dotprod</FONT
> are call-by-reference.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="stack-allocated_variables"
>Stack-Allocated Variables</A
></H2
><P
>&#13;Given a type T and an address L, how can a proof of the view
<FONT
COLOR="RED"
>T@L</FONT
> be obtained in the first place? There are actually a
variety of methods for obtaining such proofs in practice, and I present one
as follows that is based on stack-allocation of local variables.

</P
><P
>&#13;In the body of the following function <FONT
COLOR="RED"
>foo</FONT
>, some stack-allocated
local variables are declared:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3474"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> foo <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x0<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// view@(x0): int? @ x0</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x0 := <span class="dynexp">0</span></span> <span class="comment">// view@(x0): int(0) @ x0</span>
  <span class="keyword">var</span> x1<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">1</span> <span class="comment">// view@(x1): int(1) @ x1</span>
<span class="comment">//</span>
<span class="comment">// [with] is a keyword in ATS</span>
<span class="comment">//</span>
  <span class="keyword">var</span> y<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">with</span> <span class="prfexp">pfy</span> <span class="comment">// pfy is an alias of view@(y): int? @ y</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> y := <span class="dynexp">2</span></span> <span class="comment">// pfy = view@(y): int(2) @ y</span>
  <span class="keyword">var</span> z<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">with</span> <span class="prfexp">pfz</span> <span class="keyword">=</span> <span class="dynexp">3</span> <span class="comment">// pfz is an alias of view@(z): int(3) @ z</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [foo]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The keyword <FONT
COLOR="RED"
>var</FONT
> is for declaring a local variable. When a
variable is declared, either its type or its initial value needs to be
given. If a variable is declared without a type, then the type of its
initial value is assumed to be its type. Assume that a variable x is
declared of type T. Then the pointer to the location of the variable is
denoted by <FONT
COLOR="RED"
>addr@(x)</FONT
>, where <FONT
COLOR="RED"
>addr@</FONT
> is a keyword, and
its associated linear proof (of some at-view) can be referred to as
<FONT
COLOR="RED"
>view@(x)</FONT
>, where <FONT
COLOR="RED"
>view@</FONT
> is a keyword. A variable is
another form of left-value in ATS. In the body of <FONT
COLOR="RED"
>foo</FONT
>,
<FONT
COLOR="RED"
>x0</FONT
> is declared to be a variable of the type <FONT
COLOR="RED"
>int</FONT
> and
then it is initialized with the integer 0; <FONT
COLOR="RED"
>x1</FONT
> is declared to be
a variable of the type <FONT
COLOR="RED"
>int</FONT
> that is given the initial value 1;
<FONT
COLOR="RED"
>y</FONT
> is declared to be a variable of the type <FONT
COLOR="RED"
>int</FONT
>
while <FONT
COLOR="RED"
>pfy</FONT
> is introduced as an alias for <FONT
COLOR="RED"
>view@(y)</FONT
>,
and then <FONT
COLOR="RED"
>y</FONT
> is initialized with the integer 2; <FONT
COLOR="RED"
>z</FONT
> is
declared to be a variable of the type <FONT
COLOR="RED"
>int</FONT
> that is given the
initial value 3 while <FONT
COLOR="RED"
>pfz</FONT
> is introduced as an alias for
<FONT
COLOR="RED"
>view@(z)</FONT
>.

</P
><P
>&#13;The following code gives an implementation of the factorial function:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3497"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span> fact<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">int</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>res := n * <span class="keyword">!</span>res</span> <span class="keyword">in</span> loop <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> n-<span class="dynexp">1</span><span class="keyword">,</span> res<span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [loop]</span>
  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">with</span> <span class="prfexp">pf</span> <span class="keyword">=</span> <span class="dynexp">1</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> n<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>res<span class="keyword">)</span></span> <span class="comment">// addr@res: the pointer to res</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [fact]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that the variable <FONT
COLOR="RED"
>res</FONT
> holds the intermediate result during
the execution of the loop. As <FONT
COLOR="RED"
>res</FONT
> is stack-allocated, there is
no garbage generated after a call to <FONT
COLOR="RED"
>fact</FONT
> is evaluated. When
this style of programming is done in C, there is often a concern about the
pointer to <FONT
COLOR="RED"
>res</FONT
> being derefenced after a call to
<FONT
COLOR="RED"
>fact</FONT
> returns, which is commonly referred to as derefencing a
dangling pointer.  This concern is completely eliminated in ATS as it is
required by the type system of ATS that a linear proof of the at-view
associated with the variable <FONT
COLOR="RED"
>res</FONT
> be present at the end of legal
scope for <FONT
COLOR="RED"
>res</FONT
>. More specifically, if x is a declared variable
of the type T, then a linear proof of the view <FONT
COLOR="RED"
>T?@L</FONT
>, where L is
the address of x, must be available when typechecking reaches the end of
the scope for x.  This requirement ensures that a variable can no longer be
accessed after the portion of the stack in which it is allocated is
reclaimed as no linear proof of the at-view associated with the variable is
ever available from that point on.

</P
><P
>&#13;Arrays in ATS can also be stack-allocated. For instance, the following code
allocates two arrays of doubles in the frame of the function
<FONT
COLOR="RED"
>main0</FONT
> and then passes them to <FONT
COLOR="RED"
>dotprod</FONT
> to compute
their dot product:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3511"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">var</span> A <span class="keyword">=</span> <span class="dynexp"><span class="keyword">@[</span>double<span class="keyword">]</span><span class="keyword">[</span>3<span class="keyword">]</span><span class="keyword">(</span>1.0<span class="keyword">)</span></span> <span class="comment">// initialized with 1.0, 1.0, 1.0</span>
<span class="keyword">var</span> B <span class="keyword">=</span> <span class="dynexp"><span class="keyword">@[</span>double<span class="keyword">]</span><span class="keyword">(</span>1.0<span class="keyword">,</span> 2.0<span class="keyword">,</span> 3.0<span class="keyword">)</span></span> <span class="comment">// initialized with 1.0, 2.0, 3.0</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"A * B = "</span><span class="keyword">,</span> dotprod <span class="keyword">(</span>A<span class="keyword">,</span> B<span class="keyword">)</span><span class="keyword">)</span></span> <span class="comment">// A * B = 6.0</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</p></PRE
><P
></P
></DIV
>


The at-view associated with the variable A is <FONT
COLOR="RED"
>(@[double][3])@A</FONT
>,
where A also refers to the address of the variable A. Similarly, the
at-view associated with the variable B is <FONT
COLOR="RED"
>(@[double][3])@B</FONT
>.

For the sake of completeness, I mention the syntax for uninitialized arrays
as follows: Given a type T and an integer N, the syntax
<FONT
COLOR="RED"
>@[T][N]()</FONT
> is for an array consisting of N uninitialized values
of type T.

</P
><P
>&#13;Note that allocating large arrays in the call frame of a function may not
be a good practice as doing so can greatly increase the likelihood of
stack-overflow at run-time.

</P
><P
>&#13;It is also allowed in ATS to allocate a closure in the call frame of a
function. For instance, the following code implements a function named
<FONT
COLOR="RED"
>foo</FONT
> that stores a flat closure-function in a stack-allocated
variable named <FONT
COLOR="RED"
>bar</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3520"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> foo
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span> bar <span class="keyword">=</span> <span class="keyword">lam@</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&gt;</span> x * y
<span class="comment">//</span>
<span class="keyword">in</span>
  bar <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [foo]</span>
</p></PRE
><P
></P
></DIV
>


Note that the special keyword <FONT
COLOR="RED"
>lam@</FONT
> should be used to form a
flat closure-function. For the sake of completeness, I present another example
as follows to show that a recursive closure-function can also be stored in
a stack-allocated variable:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3523"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> foo2
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span> bar2 <span class="keyword">=</span> <span class="keyword">fix@</span> f <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&gt;</span> <span class="keyword">if</span> x <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> y + f<span class="keyword">(</span>x-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">0</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  bar2 <span class="keyword">(</span>x<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [foo]</span>
</p></PRE
><P
></P
></DIV
>


Note that the special keyword <FONT
COLOR="RED"
>fix@</FONT
> should be used to form
a flat recursive closure-function.

</P
><P
>&#13;In a setting where dynamic memory allocation is not
allowed, stack-allocated closures can play a pivotal role in supporting
programming with higher-order functions.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="heap-allocated-linear-closure-functions"
>Heap-Allocated Linear Closure-Functions</A
></H2
><P
>&#13;In ATS, a closure-function can be assiged a linear type, allowing
it to be properly tracked within the type system and also explicitly
freed by the programmer.
</P
><P
>&#13;The following code implements a higher-order function
<FONT
COLOR="RED"
>list_map_cloptr</FONT
> which takes a linear closure-function
as its second argument:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3532"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">vt@ype</span>
<span class="keyword">}</span></span> list_map_cloptr<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">b</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_cons <span class="keyword">(</span>f <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> list_map_cloptr&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Note that the keyword <FONT
COLOR="RED"
>-&#60;cloptr1&#62;</FONT
> indicates that the
function type it forms is for a linear closure-function. If a type for a
pure linear closure-function is needed, the keyword
<FONT
COLOR="RED"
>-&#60;cloptr0&#62;</FONT
> can be used.  The symbol <FONT
COLOR="RED"
>!</FONT
> in
front of the function type means that the second (linear) argument of
<FONT
COLOR="RED"
>list_map_cloptr</FONT
> is call-by-value and it is still available
after <FONT
COLOR="RED"
>list_map_cloptr</FONT
> returns.
</P
><P
>&#13;Let us now see some concrete code in which a linear closure-function is
created, called, and finally freed:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3540"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
<span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> len <span class="keyword">=</span> list_vt_length <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> f <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> x * len</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span>
list_map_cloptr&lt;<span class="staexp">int</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>$UNSAFE<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cloptr_free<span class="keyword">(</span>$UNSAFE<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>cloptr<span class="keyword">(</span>void<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>f<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"xs = "</span><span class="keyword">,</span> xs<span class="keyword">)</span></span> <span class="comment">// xs = 0, 1, 2, 3, 4</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"ys = "</span><span class="keyword">,</span> ys<span class="keyword">)</span></span> <span class="comment">// ys = 0, 5, 10, 15, 20</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*freed*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*freed*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>ys<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>cloptr_free</FONT
> is given the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3543"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> cloptr_free<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="keyword">(</span>pclo<span class="keyword">:</span> <span class="staexp">cloptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Also, the cast involved in
<FONT
COLOR="RED"
>$UNSAFE.castvwtp0{cloptr(void)}(f)</FONT
> is a safe cast.

</P
><P
>&#13;The support for linear closure-functions in ATS1 is crucial in a setting
where higher-order functions are needed but run-time garbage collection
(GC) is not allowed or supported. In ATS2, linear closure-functions become
much less important as programming with higher-order functions in a setting
without GC can be more conveniently achieved through the use of templates.
However, if one wants to store closure-functions in a data structure
without causing memory leaks, it is necessary to use linear closure-functions
unless GC can be relied upon to reclaim memory.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="dataviews"
></A
>Chapter 14. Dataviews as Linear Dataprops</H1
><P
>&#13;The at-views of the form <FONT
COLOR="RED"
>T@L</FONT
> for types T and addresses L are
building blocks for constructing other forms of views. One mechanism for
putting together such building blocks is by declaring dataviews, which is
mostly identical to declaring dataprops. I now present in this chapter some
commonly encountered dataviews and their uses.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVIEW/"
TARGET="_top"
>on-line</A
> the code presented
for illustration in this chapter.

</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="optional_views"
>Optional Views</A
></H2
><P
>&#13;The dataview <FONT
COLOR="RED"
>option_v</FONT
> is declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3557"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataview</span> <span class="staexp">option_v <span class="keyword">(</span>v<span class="keyword">:</span><span class="keyword">view+</span><span class="keyword">,</span> bool<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">Some_v <span class="keyword">(</span><span class="staexp">v</span><span class="keyword">,</span> <span class="staexp">true</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">v</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="prfexp">None_v <span class="keyword">(</span><span class="staexp">v</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


This declaration indicates that the dataview <FONT
COLOR="RED"
>option_v</FONT
> is
covariant in its first argument and there are two proof constructors
associated with it: <FONT
COLOR="RED"
>Some_v</FONT
> and <FONT
COLOR="RED"
>None_v</FONT
>.  Given a
view V, <FONT
COLOR="RED"
>option_v(V, b)</FONT
> is often called an optional view, where
b is a boolean. Clearly, a proof of the view <FONT
COLOR="RED"
>option_v(V, true)</FONT
>
contains a proof of the view V while a proof the view <FONT
COLOR="RED"
>option_v(V,
false)</FONT
> contains nothing.

</P
><P
>&#13;As an example, the following function interface involves a typical use of
optional view:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3566"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
ptr_alloc_opt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">option_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">null</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Given a type T, the function <FONT
COLOR="RED"
>ptr_alloc_opt&#60;T&#62;</FONT
> returns a
pointer paired with a proof of an optional view; if the returned pointer is
not null, then the proof can be turned into a proof of the view
<FONT
COLOR="RED"
>T?@L</FONT
>, where L is the location to which the pointer points;
otherwise, there is no at-view associated with the returned pointer.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="disjunctive_views"
>Disjunctive Views</A
></H2
><P
>&#13;The dataview <FONT
COLOR="RED"
>VOR</FONT
> is declared as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3574"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataview</span> <span class="staexp">VOR <span class="keyword">(</span>v0<span class="keyword">:</span><span class="keyword">view+</span><span class="keyword">,</span> v1<span class="keyword">:</span><span class="keyword">view+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">VORleft <span class="keyword">(</span><span class="staexp">v0</span><span class="keyword">,</span> <span class="staexp">v1</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">v0</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="prfexp">VORright <span class="keyword">(</span><span class="staexp">v0</span><span class="keyword">,</span> <span class="staexp">v1</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">v1</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


This declaration indicates that the dataview <FONT
COLOR="RED"
>VOR</FONT
> is covariant
in its first and second arguments and there are two proof constructors
associated with it: <FONT
COLOR="RED"
>VORleft</FONT
> and <FONT
COLOR="RED"
>VORright</FONT
>. Given
views V<SUB
>0</SUB
> and V<SUB
>1</SUB
>, a proof of <FONT
COLOR="RED"
>VOR(V<SUB
>0</SUB
>,
V<SUB
>1</SUB
>, 0)</FONT
> can be turned into a proof of V<SUB
>0</SUB
> and a proof of
<FONT
COLOR="RED"
>VOR(V<SUB
>0</SUB
>, V<SUB
>1</SUB
>, 1)</FONT
> can be turned into a proof of
V<SUB
>1</SUB
>.

</P
><P
>&#13;Let T be some type. The following function interface states that
<FONT
COLOR="RED"
>getopt</FONT
> takes an unintialized pointer and returns an integers
indicating whether the pointer is initialized:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3591"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> getopt<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">T</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">VOR</span> <span class="keyword">(</span><span class="staexp">T</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">T</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The following code shows a typical use of <FONT
COLOR="RED"
>getopt</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3594"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> foo <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">T</span><span class="staexp">?</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfor</span> <span class="keyword">|</span> i<span class="keyword">)</span> <span class="keyword">=</span> getopt <span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="keyword">|</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> i <span class="keyword">=</span> <span class="dynexp">0</span>
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> VORleft <span class="keyword">(</span>pf0<span class="keyword">)</span> <span class="keyword">=</span> pfor</span> <span class="keyword">in</span> <span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>x<span class="keyword">)</span> := pf0 <span class="comment">// uninitialized</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> VORright <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pfor</span> <span class="keyword">in</span> <span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>x<span class="keyword">)</span> := pf1 <span class="comment">// initialized</span>
  <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [foo]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;In ATS, there is a type constructor <FONT
COLOR="RED"
>opt</FONT
> that takes a type T and
a boolean B to form an opt-type <FONT
COLOR="RED"
>opt(T, B)</FONT
> such that
<FONT
COLOR="RED"
>opt(T, B)</FONT
> equals T if B is true and it equals T? if B is false.
The function <FONT
COLOR="RED"
>getopt</FONT
> can be given the following interface
that makes use of an opt-type:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3601"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> getopt <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">T</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span> <span class="keyword">(</span><span class="staexp">T</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The code that calls <FONT
COLOR="RED"
>getopt</FONT
> can now be implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3604"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> foo <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">T</span><span class="staexp">?</span>
  <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> getopt <span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> <span class="keyword">(</span>ans<span class="keyword">)</span>
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> opt_unsome<span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*initialized*)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> opt_unnone<span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*uninitialized*)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [foo]</span>
</p></PRE
><P
></P
></DIV
>


where the proof functions <FONT
COLOR="RED"
>opt_unsome</FONT
> and <FONT
COLOR="RED"
>opt_unnone</FONT
>
are assgined the following types:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3608"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span> opt_unsome<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">opt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">true</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="prfexp"><span class="keyword">prfun</span> opt_unnone<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">opt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Compared to the version that uses <FONT
COLOR="RED"
>VOR</FONT
>, this version based on
opt-type is considerably less verbose.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear_arrays"
>Dataview for Linear Arrays</A
></H2
><P
>&#13;Unlike in most programming languages, arrays are not a primitive data
structure in ATS. More specifically, persistent arrays can be implemented
based on linear arrays, which allow for being freed safely by the
programmer, and linear arrays can be implemented based on
at-views. Intuitively, the view for an array storing N elements of type
T consists of N at-views: T@L<SUB
>0</SUB
>, T@L<SUB
>1</SUB
>, ..., and
T@L<SUB
>N-1</SUB
>, where L<SUB
>0</SUB
> is the starting address of the array and
each subsequent L equals the previous one plus the size of T, that is, the
number of bytes needed to store a value of the type T. The following
declared dataview <FONT
COLOR="RED"
>array_v</FONT
> precisely captures this intuituion:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3619"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataview</span>
<span class="staexp">array_v <span class="keyword">(</span>
  a<span class="keyword">:</span><span class="keyword">t@ype+</span> <span class="comment">// covariant argument</span>
<span class="keyword">,</span> addr<span class="comment">(*beg*)</span>
<span class="keyword">,</span> int<span class="comment">(*size*)</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// array_v</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
    array_v_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    array_v_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [array_v]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Given a type T, an address L and an integer N, <FONT
COLOR="RED"
>array_v(T, L, N)</FONT
>
is a view for the array starting at L that stores N elements of the type T.
As can be readily expected, the function templates for array-accessing and
array-updating are given the following interfaces:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3623"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> arrget<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span>
<span class="comment">// end of [arrget] // end of [fun]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> arrset<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [arrset] // end of [fun]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Before implementing <FONT
COLOR="RED"
>arrget</FONT
> and <FONT
COLOR="RED"
>arrset</FONT
>, I present as
follows some code that implements a function template to access the first
element of a nonempty array:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3628"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> arrgetfst<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span> x <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> pf</span>
  <span class="comment">// pf1: a @ l; pf2: array_v (a, l+sizeof(a), n-1)</span>
  <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> <span class="keyword">!</span>p</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf := array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [arrgetfst]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Obviously, the function template <FONT
COLOR="RED"
>arrget</FONT
> can be implemented
based on <FONT
COLOR="RED"
>arrgetfst</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3633"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
arrget <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> pf</span>
    <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> arrget <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> ptr_succ&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">)</span><span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span></span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf := array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    x
  <span class="keyword">end</span> <span class="keyword">else</span>
    arrgetfst <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">)</span></span>
  <span class="comment">// end of [if]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;This is a tail-recursive implementation of time-complexity O(n). However,
the very point of having arrays is to support O(1)-time accessing and
updating operations. My initial effort spent on implementing such
operations immediately dawned on me the need to construct proof functions
for supporting view-changes (of no run-time cost).

</P
><P
>&#13;Clearly, an array starting at L that stores N elements of type T can also
be thought of as two arrays: one starting at L that stores I elements while
the other starting at L+I*sizeof(T) that stores N-I elements, where I is
an natural number less that or equal to N. Formally, this statement can be
encoded in the type of the proof function <FONT
COLOR="RED"
>array_v_split</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3638"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
array_v_split
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pfarr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
><P
>&#13;The other direction of the above statement can be encoded in the type of
the proof function <FONT
COLOR="RED"
>array_v_unsplit</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3642"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">prfun</span>
array_v_unsplit
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> pf2arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">n1</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
><P
>&#13;With <FONT
COLOR="RED"
>array_v_split</FONT
> and <FONT
COLOR="RED"
>array_v_unsplit</FONT
>, we can
readily give implementations of <FONT
COLOR="RED"
>arrget</FONT
> and <FONT
COLOR="RED"
>arrset</FONT
>
that are O(1)-time:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3649"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
arrget<span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> x <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> array_v_split<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span><span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
  <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> ptr_get1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf21</span> <span class="keyword">|</span> ptr_add&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> pf2 <span class="keyword">=</span> array_v_cons <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf := array_v_unsplit<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>n-i<span class="keyword">}</span></span><span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">(* end of [arrget] *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
arrset<span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">,</span> i<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> array_v_split<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span><span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptr_set1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf21</span> <span class="keyword">|</span> ptr_add&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> pf2 <span class="keyword">=</span> array_v_cons <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf := array_v_unsplit<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>n-i<span class="keyword">}</span></span><span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">(* end of [arrset] *)</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Of course, the proof functions <FONT
COLOR="RED"
>array_v_split</FONT
> and
<FONT
COLOR="RED"
>array_v_split</FONT
> are still to be implemented, which I will do when
covering the topic of view-change.

</P
><P
>&#13;Given a type T, an address L and a natural number N, a proof of the view
<FONT
COLOR="RED"
>array_v(T?, L, N)</FONT
> can be obtained and released by calling the
functions <FONT
COLOR="RED"
>malloc</FONT
> and <FONT
COLOR="RED"
>free</FONT
>, respectively, which are
to be explained in details elsewhere. I now give as follows an implemention
of a function template for array intialization:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3658"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">natLt <span class="keyword">(</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
array_ptr_tabulate
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span><span class="staexp">l</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">l</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span><span class="staexp">l</span><span class="keyword">,</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">l</span><span class="keyword">,</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> pf</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p := f <span class="keyword">(</span>i<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> ptr_succ&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">,</span> f<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">)</span></span>
    <span class="keyword">in</span>
      pf := array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> array_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> pf := array_v_nil <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">,</span> n<span class="keyword">,</span> f<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_ptr_tabulate]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Given a natural number n, the type <FONT
COLOR="RED"
>natLt(n)</FONT
> is for all natural
numbers less than n. Given a type T, the function
<FONT
COLOR="RED"
>array_ptr_tabulate&#60;T&#62;</FONT
> takes a pointer to an uninitialized
array, the size of the array and a function f that maps each natural number
less than n to a value of the type T, and it initializes the array with the
sequence of values of f(0), f(1), ..., and f(n-1). In other words, the
array stores a tabulation of the given function f after the initialization
is over.

</P
><P
>&#13;Given a type T and an integer N, @[T][N] is a built-in type in ATS for N
consecutive values of the type T. Therefore, the at-view @[T][N]@L for any
given address L is equivalent to the array-view <FONT
COLOR="RED"
>array_v(T, L,
N)</FONT
>.  By making use of the feature of call-by-reference, we can also
assign the following interfaces to the previously presented functions
<FONT
COLOR="RED"
>arrget</FONT
> and <FONT
COLOR="RED"
>arrset</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3667"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> arrget <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> arrset <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


These interfaces are more concise as they obviate the need to mention
explicitly where the array argument is located.

</P
><P
>&#13;Please find the entirety of the above presented code
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVIEW/array.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear_strings"
>Dataview for Linear Strings</A
></H2
><P
>&#13;The following dataview <FONT
COLOR="RED"
>strbuf_v</FONT
> captures the notion of a
string in C, which consisits a sequence of non-null characters followed by the
null character:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3675"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataview</span>
<span class="staexp">strbuf_v<span class="keyword">(</span>addr<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
    strbuf_v_nil<span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    strbuf_v_cons<span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">charNZ</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="staexp">+</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


Let us define a linear type <FONT
COLOR="RED"
>strptr</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3678"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">vtypedef</span> <span class="staexp">strptr<span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


Then a C-string of length N that is stored at location L can be assigned
the type <FONT
COLOR="RED"
>strptr(L, N)</FONT
>.

</P
><P
>&#13;Given a C-string, one can always access its first character; if the
character is null, then the C-string is empty; if it is not, then the
C-string is non-empty. The following implementation of
<FONT
COLOR="RED"
>strptr_is_nil</FONT
> precisely follows this simple way of testing
whether a C-string is empty or not:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3683"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
strptr_is_nil
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
  <span class="prfexp"><span class="keyword">prval</span>
  <span class="keyword">(</span>pf_at<span class="keyword">,</span> fpf<span class="keyword">)</span> <span class="keyword">=</span>
    strbuf_v_getfst<span class="keyword">(</span>str<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">)</span></span>
  <span class="comment">// prval</span>
  <span class="dynexp"><span class="keyword">val</span> c0 <span class="keyword">=</span> <span class="keyword">!</span><span class="keyword">(</span>str<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> str<span class="dynexp"><span class="keyword">.0</span></span> := fpf<span class="keyword">(</span>pf_at<span class="keyword">)</span></span>
<span class="keyword">in</span>
  iseqz<span class="keyword">(</span>c0<span class="keyword">)</span> <span class="comment">// testing whether [c0] is null</span>
<span class="keyword">end</span></span> <span class="comment">// end of [strptr_is_nil]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


where the proof function <FONT
COLOR="RED"
>strbuf_v_getfst</FONT
>
is declared and implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3686"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">prfun</span>
strbuf_v_getfst
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf<span class="keyword">:</span> <span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>
  c<span class="keyword">:</span>int <span class="keyword">|</span> <span class="keyword">(</span>c==0 &amp;&amp; n==0<span class="keyword">)</span> || <span class="keyword">(</span>c != 0 &amp;&amp; n <span class="keyword">&gt;</span> 0<span class="keyword">)</span>
<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">char</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="keyword">-&lt;</span><span class="staexp">lin</span><span class="keyword">,</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">primplmnt</span>
strbuf_v_getfst
  <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> pf <span class="keyword">of</span>
<span class="keyword">|</span> strbuf_v_nil<span class="keyword">(</span>pf_at<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp"><span class="keyword">#[</span><span class="keyword">..</span> <span class="keyword">|</span> <span class="keyword">(</span>pf_at<span class="keyword">,</span> <span class="keyword">llam</span><span class="keyword">(</span>pf_at<span class="keyword">)</span> <span class="keyword">=&gt;</span> strbuf_v_nil<span class="keyword">(</span>pf_at<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">]</span></span>
<span class="keyword">|</span> strbuf_v_cons<span class="keyword">(</span>pf_at<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp"><span class="keyword">#[</span><span class="keyword">..</span> <span class="keyword">|</span> <span class="keyword">(</span>pf_at<span class="keyword">,</span> <span class="keyword">llam</span><span class="keyword">(</span>pf_at<span class="keyword">)</span> <span class="keyword">=&gt;</span> strbuf_v_cons<span class="keyword">(</span>pf_at<span class="keyword">,</span> pf2<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">]</span></span>
<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The following implementation gives another example of handling the dataview
<FONT
COLOR="RED"
>strbuf_v</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3690"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
strptr_length
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop
<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span></span>
<span class="keyword">|</span> p0<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">j</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
<span class="keyword">[</span><span class="staexp">c<span class="keyword">:</span>int</span><span class="keyword">]</span>
<span class="keyword">(</span>pf_at<span class="keyword">,</span> fpf<span class="keyword">)</span> <span class="keyword">=</span> strbuf_v_getfst<span class="keyword">(</span>pf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> c0 <span class="keyword">=</span> <span class="keyword">!</span>p0</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*return*)</span><span class="keyword">)</span> <span class="keyword">=</span> pf := fpf<span class="keyword">(</span>pf_at<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iseqz<span class="keyword">(</span>c0<span class="keyword">)</span>
<span class="keyword">then</span> j
<span class="keyword">else</span> res <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="prfexp"><span class="keyword">prval</span>
  strbuf_v_cons<span class="keyword">(</span>pf_at<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> pf</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> loop<span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> ptr_succ&lt;<span class="staexp">char</span><span class="keyword">&gt;</span><span class="keyword">(</span>p0<span class="keyword">)</span><span class="keyword">,</span> succ<span class="keyword">(</span>j<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> pf := strbuf_v_cons<span class="keyword">(</span>pf_at<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="keyword">}</span> <span class="comment">(* end of [else] *)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span><span class="prfexp">str<span class="dynexp"><span class="keyword">.0</span></span></span> <span class="keyword">|</span> str<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> i2sz<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [strptr_length]  </span>
</p></PRE
><P
></P
></DIV
>


Clearly,
the implemented function <FONT
COLOR="RED"
>strptr_length</FONT
>
computes the length of a given C-string.

</P
><P
>&#13;Please find the entirety of the above presented code
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVIEW/strbuf.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="singly-linked_lists"
>Dataview for Singly-Linked Lists</A
></H2
><P
>&#13;The following dataview <FONT
COLOR="RED"
>slseg_v</FONT
> captures the notion of a
singly-linked list segment:
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3699"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">dataview</span>
<span class="staexp">slseg_v <span class="keyword">(</span>
  a<span class="keyword">:</span><span class="keyword">t@ype+</span> <span class="comment">// covariant argument</span>
<span class="keyword">,</span> addr<span class="comment">(*beg*)</span>
<span class="keyword">,</span> addr<span class="comment">(*end*)</span>
<span class="keyword">,</span> int<span class="comment">(*length*)</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// slseg_v</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
    slseg_v_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l_fst<span class="keyword">:</span>agz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l_nxt<span class="keyword">,</span>l_end<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    slseg_v_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l_fst</span><span class="keyword">,</span> <span class="staexp">l_end</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span>
      <span class="keyword">(</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">ptr</span> <span class="staexp">l_nxt</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_fst</span><span class="keyword">,</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l_nxt</span><span class="keyword">,</span> <span class="staexp">l_end</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [slseg]_v</span>
</p></PRE
><P
></P
></DIV
>


There are two proof constructors <FONT
COLOR="RED"
>slseg_v_nil</FONT
> and
<FONT
COLOR="RED"
>slseg_v_cons</FONT
> associated with <FONT
COLOR="RED"
>slseg_v</FONT
>, which are
assigned the following types:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3704"
></A
><PRE
CLASS="programlisting"
>//
slseg_v_nil :
  {a:t@ype}{l:addr} () -&#62; slseg_v (a, l, l, 0)
//
slseg_v_cons :
  {a:t@ype}{l_fst:agz}{l_nxt,l_end:addr}{n:nat}
  ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end, n)) -&#62; slseg_v (a, l_fst, l_end, n+1)
//
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;Note that <FONT
COLOR="RED"
>agz</FONT
> is a subset sort for addresses that are not null.
Given a type T, two addresses L1 and L2, and a natural number N, the view
<FONT
COLOR="RED"
>slseg_v(T, L1, L2, N)</FONT
> is for a singly-linked list segment
containing N elements of the type T that starts at L1 and finishes at L2.
In the case where L2 is the null pointer, then the list segment is considered
a list as is formally defined below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3709"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">viewdef</span> <span class="staexp">slist_v
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [slist_v]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Given a type T, a pointer pointing to L plus a proof of the view
<FONT
COLOR="RED"
>slist_v(T, L, N)</FONT
> for some natural number N is essentially the
same as a pointer to a struct of the following declared type
<FONT
COLOR="RED"
>slist_struct</FONT
> in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3714"
></A
><PRE
CLASS="programlisting"
>typedef
struct slist {
  T data ; /* [T] matches the corresponding type in ATS */
  struct slist *next ; /* pointing to the tail of the list */
} slist_struct ;
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;Let us now see a simple example involving singly-linked lists:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3717"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
slist_ptr_length
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pflst<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    <span class="prfexp">pflst<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">j</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> p <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_cons <span class="keyword">(</span>pfat<span class="keyword">,</span> pf1lst<span class="keyword">)</span> <span class="keyword">=</span> pflst</span>
      <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> loop <span class="keyword">(</span><span class="prfexp">pf1lst</span> <span class="keyword">|</span> <span class="keyword">!</span>p<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">)</span></span> <span class="comment">// !p.1 points to the tail</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pflst := slseg_v_cons <span class="keyword">(</span>pfat<span class="keyword">,</span> pf1lst<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      res
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// the length of a null list is 0</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pflst</span> <span class="keyword">in</span> pflst := slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> j
    <span class="keyword">end</span></span> <span class="comment">(* end of [if] *)</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">pflst</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [slist_ptr_length]</span>
</p></PRE
><P
></P
></DIV
>


The function template <FONT
COLOR="RED"
>slist_ptr_length</FONT
> computes the length of a
given singly-linked list. Note that the inner function <FONT
COLOR="RED"
>loop</FONT
> is
tail-recursive. The above implementation of <FONT
COLOR="RED"
>slist_ptr_length</FONT
>
essentially corresponds to the following implementation in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3722"
></A
><PRE
CLASS="programlisting"
>int
slist_ptr_length
(
  slist_struct *p
) {
  int res = 0 ;
  while (p != NULL) { res = res + 1 ; p = p-&#62;next ; }
  return res ;
} // end of [slist_ptr_length]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;As another example, the following function template
<FONT
COLOR="RED"
>slist_ptr_reverse</FONT
> turns a given linked list into its reverse:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3726"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
slist_ptr_reverse
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pflst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
    <span class="prfexp">pf1lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span></span>
  <span class="keyword">,</span> <span class="prfexp">pf2lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l1</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l2</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> p1 <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf1lst<span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span>
      <span class="dynexp"><span class="keyword">val</span> p1_nxt <span class="keyword">=</span> <span class="keyword">!</span>p1<span class="dynexp"><span class="keyword">.1</span></span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p1<span class="dynexp"><span class="keyword">.1</span></span> := p2</span>
    <span class="keyword">in</span>
      loop <span class="keyword">(</span><span class="prfexp">pf1lst</span><span class="keyword">,</span> <span class="prfexp">slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf2lst<span class="keyword">)</span></span> <span class="keyword">|</span> p1_nxt<span class="keyword">,</span> p1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span> <span class="keyword">in</span> <span class="keyword">(</span><span class="prfexp">pf2lst</span> <span class="keyword">|</span> p2<span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">pflst</span><span class="keyword">,</span> <span class="prfexp">slseg_v_nil</span> <span class="keyword">|</span> p<span class="keyword">,</span> the_null_ptr<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [slist_ptr_reverse]</span>
</p></PRE
><P
></P
></DIV
>


By translating the tail-recursive function <FONT
COLOR="RED"
>loop</FONT
> into a
while-loop, we can readily turn the implementation of
<FONT
COLOR="RED"
>slist_ptr_reverse</FONT
> in ATS into the following implementation in
C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3730"
></A
><PRE
CLASS="programlisting"
>slist_struct*
slist_ptr_reverse
(
  slist_struct *p
) {
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p-&#62;next ; p-&#62;next = res ; res = p ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;Let us see yet another example.
List concatenation is a common operation on lists. This time, we first give
an implementation of list concatenation in C:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3733"
></A
><PRE
CLASS="programlisting"
>slist_struct*
slist_ptr_append
  (slist_struct *p, slist_struct *q) {
  slist_struct *p1 = p ;
  if (p1 == NULL) return q ;
  while (p1-&#62;next != NULL) p1 = p1-&#62;next ; p1-&#62;next = q ;
  return p ;
} // end of [slist_ptr_append]
</PRE
><P
></P
></DIV
>


The algorithm is straightforward. If <FONT
COLOR="RED"
>p</FONT
> is null, then
<FONT
COLOR="RED"
>q</FONT
> is returned. Otherwise, the last node in the list pointed to
by <FONT
COLOR="RED"
>p</FONT
> is first found and its field of the name <FONT
COLOR="RED"
>next</FONT
>
then replaced with <FONT
COLOR="RED"
>q</FONT
>.  This implementation of
<FONT
COLOR="RED"
>slist_ptr_append</FONT
> in C can be translated directly into to
the following one in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3741"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
slist_ptr_append
  <span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span></span>
<span class="keyword">,</span> <span class="prfexp">pf2lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span></span>
<span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l1</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l2</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr <span class="keyword">|</span> l1 <span class="keyword">&gt;</span> null<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
    <span class="prfexp">pf1lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span></span>
  <span class="keyword">,</span> <span class="prfexp">pf2lst<span class="keyword">:</span> <span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l1</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l2</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">slist_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">void</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf1lst<span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span>
    <span class="dynexp"><span class="keyword">val</span> p1_nxt <span class="keyword">=</span> <span class="keyword">!</span>p1<span class="dynexp"><span class="keyword">.1</span></span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> p1_nxt <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pflst</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="prfexp">pf1lst</span><span class="keyword">,</span> <span class="prfexp">pf2lst</span> <span class="keyword">|</span> p1_nxt<span class="keyword">,</span> p2<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span><span class="prfexp">slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pflst<span class="keyword">)</span></span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p1<span class="dynexp"><span class="keyword">.1</span></span> := p2</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span>
    <span class="keyword">in</span>
      <span class="keyword">(</span><span class="prfexp">slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf2lst<span class="keyword">)</span></span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> p1 <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pflst</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="prfexp">pf1lst</span><span class="keyword">,</span> <span class="prfexp">pf2lst</span> <span class="keyword">|</span> p1<span class="keyword">,</span> p2<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">(</span><span class="prfexp">pflst</span> <span class="keyword">|</span> p1<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span> <span class="keyword">in</span> <span class="keyword">(</span><span class="prfexp">pf2lst</span> <span class="keyword">|</span> p2<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [slist_ptr_append]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;In the above examples, it is evident that the code in ATS is a lot more
verbose than its counterpart in C. However, the former is also a lot more
robust than the latter in the following sense: If a minor change is made to
the code in ATS (e.g., renaming identifiers, reordering function
arguments), it is most likely that a type-error is to be reported when the
changed code is typechecked. On the other hand, the same thing cannot be
said about the code written in C. For instance, the following erroneous
implementation of <FONT
COLOR="RED"
>slist_ptr_reverse</FONT
> in C is certainly
type-correct:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3745"
></A
><PRE
CLASS="programlisting"
>/*
** This implementation is *incorrect* but type-correct:
*/
slist_struct*
slist_ptr_reverse
  (slist_struct *p)
{
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p-&#62;next ; res = p ; p-&#62;next = res ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;I now point out that the dataview <FONT
COLOR="RED"
>slseg_v</FONT
> is declared here in a
manner that does not address the issue of allocating and freeing list
nodes, and it is done so for the sake of a less involved presentation. A
dataview for singly-linked lists that does handle allocation and
deallocation of list nodes can also be declared in ATS, but there is really
little need for it as we can declare a dataviewtype for such lists that is
far more convenient to use.  However, dataviews are fundamentally more
general and flexible than dataviewtypes, and there are many common data
structures (e.g. doubly-linked lists) that can only be properly handled
with dataviews in ATS.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="view-changes"
>Proof Functions for View-Changes</A
></H2
><P
>&#13;By the phrase <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>view-change</I
></SPAN
>, I mean applying a function to
proofs of a set of views to turn them into proofs of another set of views.
As this function itself is a proof function, there is no run-time cost
associated with each view-change. For instance, a proof of the at-view
int32@L for any address L can be turned into a proof of a tuple of 4
at-views: int8@L, int8@L+1, int8@L+2 and int8@L+3, where int32 and int8 are
types for 32-bit and 8-bit integers, respectively. Often more interesting
view-changes involve recursively defined proof functions, and I present
several of such cases in the rest of this section.

</P
><P
>&#13;When implementing an array subscripting operation of O(1)-time, we need a
proof function to change the view of one array into the views of two
adjacently located arrays and another proof function to do precisely the
opposite. Formally speaking, we need to construct the following two proof
functions <FONT
COLOR="RED"
>array_v_split</FONT
> and <FONT
COLOR="RED"
>array_v_unsplit</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3756"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
array_v_split
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pfarr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
array_v_unsplit
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> pf2arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">n1</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;An implementation of <FONT
COLOR="RED"
>array_v_split</FONT
> is given as follows:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3760"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplmnt</span>
array_v_split
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span><span class="keyword">(</span>pfarr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> split
    <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pfarr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span>
    <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span>
  <span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">sif</span> <span class="staexp">i</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2arr<span class="keyword">)</span> <span class="keyword">=</span> pfarr</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>pf1res1<span class="keyword">,</span> pf1res2<span class="keyword">)</span> <span class="keyword">=</span> split<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n-1<span class="keyword">,</span>i-1<span class="keyword">}</span></span> <span class="keyword">(</span>pf2arr<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span>array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf1res1<span class="keyword">)</span><span class="keyword">,</span> pf1res2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> EQINT <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eqint_make<span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>0<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span>array_v_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> pfarr<span class="keyword">)</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [sif]</span>
<span class="keyword">in</span>
  split <span class="keyword">(</span>pfarr<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_v_split]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that the keyword <FONT
COLOR="RED"
>primplmnt</FONT
> (instead of
<FONT
COLOR="RED"
>implement</FONT
>) should be used for implementing proof functions.
One can also choose to use the keyword <FONT
COLOR="RED"
>primplement</FONT
> in place of
<FONT
COLOR="RED"
>primplmnt</FONT
>. Clearly, the proof function <FONT
COLOR="RED"
>split</FONT
>
directly encodes a proof based on mathematical induction. Following is an
implementation of <FONT
COLOR="RED"
>array_v_unsplit</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3769"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplmnt</span>
array_v_unsplit
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1arr<span class="keyword">,</span> pf2arr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> unsplit
    <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n1</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pf1arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span>
  <span class="keyword">,</span> pf2arr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">n1</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">sif</span> <span class="staexp">n1</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span>
      array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pf1arr<span class="keyword">)</span> <span class="keyword">=</span> pf1arr</span>
      <span class="prfexp"><span class="keyword">prval</span> pfres <span class="keyword">=</span> unsplit <span class="keyword">(</span>pf1arr<span class="keyword">,</span> pf2arr<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      array_v_cons <span class="keyword">(</span>pf1<span class="keyword">,</span> pfres<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> array_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1arr</span> <span class="keyword">in</span> pf2arr
    <span class="keyword">end</span></span> <span class="comment">// end of [sif]</span>
<span class="keyword">in</span>
  unsplit <span class="keyword">(</span>pf1arr<span class="keyword">,</span> pf2arr<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_v_unsplit]</span>
</p></PRE
><P
></P
></DIV
>


The proof function <FONT
COLOR="RED"
>unsplit</FONT
> also directly encodes a proof based on
mathematical induction.

</P
><P
>&#13;Let us now see an even more interesting proof function for performing
view-change.  The interface of the proof function <FONT
COLOR="RED"
>array_v_takeout</FONT
>
is given as follows:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3774"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
array_v_takeout
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pfarr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">lin</span><span class="keyword">,</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that the following type is for a linear proof function that takes a
proof of an at-view to return a proof of an array-view:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3777"
></A
><PRE
CLASS="programlisting"
>a @ l+i*sizeof(a) -&#60;lin,prf&#62; array_v (a, l, n)
</PRE
><P
></P
></DIV
>


As such a function essentially represents an array with one missing cell,
we may simply say that <FONT
COLOR="RED"
>array_v_takeout</FONT
> turns the view of an
array into an at-view (for one cell) and a view for the rest of the array.
By making use of <FONT
COLOR="RED"
>array_v_takeout</FONT
>, we can give another
implementation of <FONT
COLOR="RED"
>arrget</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3782"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
arrget<span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> x <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> fpf2<span class="keyword">)</span> <span class="keyword">=</span>
  array_v_takeout<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> x <span class="keyword">=</span> ptr_get1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> ptr_add&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf := fpf2 <span class="keyword">(</span>pf1<span class="keyword">)</span></span> <span class="comment">// putting the cell and the rest together</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [arrget] *)</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The proof function <FONT
COLOR="RED"
>array_v_takeout</FONT
> can be implemented as follows:
</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3786"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplmnt</span>
array_v_takeout
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span><span class="keyword">(</span>pfarr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> takeout
    <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pfarr<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span>
    <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
  <span class="keyword">,</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">lin</span><span class="keyword">,</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> array_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf1arr<span class="keyword">)</span> <span class="keyword">=</span> pfarr</span>
  <span class="keyword">in</span>
    <span class="keyword">sif</span> <span class="staexp">i</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>pfres<span class="keyword">,</span> fpfres<span class="keyword">)</span> <span class="keyword">=</span> takeout<span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n-1<span class="keyword">,</span>i-1<span class="keyword">}</span></span><span class="keyword">(</span>pf1arr<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span>pfres<span class="keyword">,</span> <span class="keyword">llam</span> <span class="keyword">(</span>pfres<span class="keyword">)</span> <span class="keyword">=&gt;</span> array_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> fpfres <span class="keyword">(</span>pfres<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> EQINT <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eqint_make<span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>0<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">(</span>pf1at<span class="keyword">,</span> <span class="keyword">llam</span> <span class="keyword">(</span>pf1at<span class="keyword">)</span> <span class="keyword">=&gt;</span> array_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf1arr<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [sif]</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [takeout]</span>
<span class="keyword">in</span>
  takeout<span class="staexp"><span class="keyword">{</span>l<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span><span class="keyword">(</span>pfarr<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_v_takeout]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Note that <FONT
COLOR="RED"
>llam</FONT
> is a keyword for forming linear functons.  Once
a linear function is applied, it is consumed and the resource in it, if not
reclaimed, moves into the result it returns.

</P
><P
>&#13;The proof functions presented so far for view-changes are all manipulating
array-views. The following one is different in this regard as it combines
two views for singly-linked list segments into one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3791"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
slseg_v_unsplit
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">,</span>l3<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf1lst<span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> pf2lst<span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">l3</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">l3</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The type of <FONT
COLOR="RED"
>slseg_v_unsplit</FONT
> essentially states that a list
segment from L1 to L2 that is of length N1 and another list segment from L2
to L3 that is of length N2 can be thought of as a list segment from L1 to
L3 that is of length N1+N2. The following implementation of
<FONT
COLOR="RED"
>slseg_v_unsplit</FONT
> is largely parallel to that of
<FONT
COLOR="RED"
>array_v_unsplit</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3796"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="prfexp"><span class="keyword">primplmnt</span>
slseg_v_unsplit
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>pf1lst<span class="keyword">,</span> pf2lst<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prfun</span> unsplit
    <span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">,</span>l3<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n1</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    pf1lst<span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> pf2lst<span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">l3</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">slseg_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">l3</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">sif</span> <span class="staexp">n1</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> pf1lst<span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span>
    <span class="keyword">in</span>
      slseg_v_cons <span class="keyword">(</span>pf1at<span class="keyword">,</span> unsplit <span class="keyword">(</span>pf1lst<span class="keyword">,</span> pf2lst<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> slseg_v_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1lst</span> <span class="keyword">in</span> pf2lst
    <span class="keyword">end</span></span> <span class="comment">// end of [sif]</span>
<span class="keyword">in</span>
  unsplit <span class="keyword">(</span>pf1lst<span class="keyword">,</span> pf2lst<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [slseg_v_unsplit]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The reader may find it interesting to give an implementation of
<FONT
COLOR="RED"
>slist_ptr_append</FONT
> by making use of <FONT
COLOR="RED"
>slseg_v_unsplit</FONT
>.

</P
><P
>&#13;Please find on-line the files <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVIEW/array.dats"
TARGET="_top"
>array.dats</A
> and <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVIEW/slist.dats"
TARGET="_top"
>slist.dats</A
>,
which contains the code employed for illustration in this section.

</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="dataviewtypes"
></A
>Chapter 15. Dataviewtypes as Linear Datatypes</H1
><P
>&#13;A dataviewtype can be thought of as a linear version of datatype. To a
large extent, it is a combination of a datatype and a dataview. This
programming feature is primarily introduced into ATS for the purpose of
providing in the setting of manual memory management the kind of
convenience brought by pattern matching. In a situation where GC must be
reduced or even completely eliminated, dataviewtypes can often be chosen as
a replacement for datatypes.  I now present in this chapter some commonly
encountered dataviewtypes and their uses.

</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear_optional_values"
>Linear Optional Values</A
></H2
><P
>&#13;When an optional value is created, the value is most likely to be used
immediately and then discarded. If such a value is assigned a linear type,
then the memory allocated for storing it can be efficiently reclaimed.  The
dataviewtype <FONT
COLOR="RED"
>option_vt</FONT
> for linear optional values is declared as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3811"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datavtype</span>
<span class="staexp">option_vt <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> bool<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">Some_vt <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">true</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">a</span></span> <span class="keyword">|</span> <span class="dynexp">None_vt <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [option_vt]</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span> <span class="staexp">Option_vt <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="staexp">option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>datavtype</FONT
> is just the short version of
<FONT
COLOR="RED"
>dataviewtype</FONT
>.  The introduced dataviewtype
<FONT
COLOR="RED"
>option_vt</FONT
> is covariant in its first argument and there are two
data constructors <FONT
COLOR="RED"
>Some_vt</FONT
> and <FONT
COLOR="RED"
>None_vt</FONT
> associated
with it. In the following example, <FONT
COLOR="RED"
>find_rightmost</FONT
> tries to find
the rightmost element in a list that satisfies a given predicate:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3819"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
find_rightmost
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> P<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> opt <span class="keyword">=</span> find_rightmost <span class="keyword">(</span>xs<span class="keyword">,</span> P<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">case</span> opt <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">if</span> P <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">then</span> Some_vt <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">else</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">|</span> _ <span class="comment">(*Some_vt*)</span> <span class="keyword">=&gt;</span> opt
    <span class="keyword">end</span> <span class="comment">// end of [list_cons]</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [find_rightmost] *)</span>
</p></PRE
><P
></P
></DIV
>


Note that the tilde symbol (<FONT
COLOR="RED"
>~</FONT
>) in front of the pattern
<FONT
COLOR="RED"
>None_vt()</FONT
> indicates that the memory for the node that matches
the pattern is freed before the body of the matched clause is evaluated.
In this case, no memory is actually freed as <FONT
COLOR="RED"
>None_vt</FONT
> is mapped
to the null pointer.  I will soon give more detailed explanation about
freeing memory allocated for constructors associated with dataviewtypes.

</P
><P
>&#13;As another example, the following function template
<FONT
COLOR="RED"
>list_optcons</FONT
> tries to construct a new list with its head
element extracted from a given optional value:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3826"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_optcons
  <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>bool<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  opt<span class="keyword">:</span> <span class="staexp">option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">bool2int</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> opt <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>Some_vt <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs</span>
<span class="comment">// end of [list_optcons]</span>
</p></PRE
><P
></P
></DIV
>


The symbol <FONT
COLOR="RED"
>bool2int</FONT
> stands for a built-in static function in
ATS that maps <FONT
COLOR="RED"
>true</FONT
> and <FONT
COLOR="RED"
>false</FONT
> to 1 and 0,
respectively. What is special here is that the first argument of
<FONT
COLOR="RED"
>list_optcons</FONT
>, which is linear, is consumed after a call to
<FONT
COLOR="RED"
>list_optcons</FONT
> returns and the memory it occupies is reclaimed.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear_lists"
>Linear Lists</A
></H2
><P
>&#13;A linear list is essentially the same as a singly-linked list depicted by
the dataview <FONT
COLOR="RED"
>slist_v</FONT
>. However, memory allocation and
deallocation of list-nodes not handled previously are handled this time.
The following declaration introduces a linear datatype <FONT
COLOR="RED"
>list_vt</FONT
>,
which forms a boxed type (of the sort <FONT
COLOR="RED"
>viewtype</FONT
>) when applied to
a type and an integer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3839"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datavtype</span>
<span class="staexp">list_vt <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">list_vt_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    list_vt_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [list_vt]</span>
</p></PRE
><P
></P
></DIV
>


Given a type T and an integer I, <FONT
COLOR="RED"
>list_vt(T, I)</FONT
> is
for linear lists of length I in which each element is of the type T.

</P
><P
>&#13;Assume that a data constructor named <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo</I
></SPAN
> is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the name
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo_unfold</I
></SPAN
> that takes n+1 addresses to form a viewtype, where
n is the arity of <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo</I
></SPAN
>. For instance, there is a viewtype
constructor <FONT
COLOR="RED"
>list_vt_cons_unfold</FONT
> that takes 3 address L0, L1 and
L2 to form a viewtype <FONT
COLOR="RED"
>list_vt_cons_unfold(L0, L1, L2)</FONT
>. This
viewtype is for a list-node created by a call to <FONT
COLOR="RED"
>list_vt_cons</FONT
>
such that the node is located at L0 and the two arguments of
<FONT
COLOR="RED"
>list_vt_cons</FONT
> are located at L1 and L2 while the proofs for the
at-views associated with L1 and L2 are put in the store for currently
available proofs.

</P
><P
>&#13;The following function template <FONT
COLOR="RED"
>length</FONT
> computes the length of a
given linear list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3852"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> length<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop
    <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> i+j==n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
    <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> list_vt_cons <span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs1<span class="keyword">,</span> j+<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> j</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [length]</span>
</p></PRE
><P
></P
></DIV
>


The interface of <FONT
COLOR="RED"
>length</FONT
> indicates that
<FONT
COLOR="RED"
>length&#60;T&#62;</FONT
> returns an integer equal to I when applied to a
list of the type <FONT
COLOR="RED"
>list_vt(T, I)</FONT
>, where T and I are a type and an
integer, respectively. Note that the symbol <FONT
COLOR="RED"
>!</FONT
> in front of the
type of a function argument indicates that the argument is call-by-value
and it is preserved after a call to the function. The function
<FONT
COLOR="RED"
>loop</FONT
> inside the body of <FONT
COLOR="RED"
>length</FONT
> is tail-recursive.
Given a linear list and an integer, <FONT
COLOR="RED"
>loop</FONT
> returns the sum of the
length of the list and the integer. In the body of <FONT
COLOR="RED"
>loop</FONT
>, if
<FONT
COLOR="RED"
>xs</FONT
> matches the pattern <FONT
COLOR="RED"
>list_vt_cons(_, xs1)</FONT
>, then
the name <FONT
COLOR="RED"
>xs1</FONT
> is bound to the tail of <FONT
COLOR="RED"
>xs</FONT
>. Note that
<FONT
COLOR="RED"
>xs1</FONT
> is a value (instead of a variable), and it is not allowed
that <FONT
COLOR="RED"
>xs1</FONT
> be modified into another value (of a different type).

</P
><P
>&#13;Suppose that we do want to modify the content stored in a list-node.
For instance, we may want to double the value of each integer stores in a
linear integer list. The following code implements a function named
<FONT
COLOR="RED"
>list_vt_2x</FONT
> that does precisely this:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3870"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
list_vt_2x<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x := <span class="dynexp">2</span> * x</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_2x <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">in</span>
      <span class="comment">// nothing</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [list_vt_cons]</span>
  <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_vt_2x] *)</span>
</p></PRE
><P
></P
></DIV
>


Given a type T, the notation (<FONT
COLOR="RED"
>!T &#62;&#62; _</FONT
>) is a shorthand for
(<FONT
COLOR="RED"
>!T &#62;&#62; T</FONT
>).  Note that the special symbol <FONT
COLOR="RED"
>@</FONT
> in
front of the pattern <FONT
COLOR="RED"
>list_vt_cons(x, xs1)</FONT
> means
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unfolding</I
></SPAN
>. If <FONT
COLOR="RED"
>xs</FONT
> matches this pattern, then
<FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>xs1</FONT
> are bound to the pointers pointing to
some memory locations L1 and L2 where the head and tail of <FONT
COLOR="RED"
>xs</FONT
>
are stored, respectively, and the type of <FONT
COLOR="RED"
>xs</FONT
> changes into
<FONT
COLOR="RED"
>list_vt_cons_unfold(L0, L1, L2)</FONT
> for L0 being the location of
the list-node referred to by <FONT
COLOR="RED"
>xs</FONT
>.  In the body of the clause
guarded by the pattern <FONT
COLOR="RED"
>list_vt_cons(x, xs1)</FONT
>, <FONT
COLOR="RED"
>x</FONT
> and
<FONT
COLOR="RED"
>xs1</FONT
> are treated as variables (which are a form of
left-value). The special proof function <FONT
COLOR="RED"
>fold@</FONT
> is called on
<FONT
COLOR="RED"
>xs</FONT
> to fold it plus the proofs of at-views attached to L1 and L2
into a linear list.

</P
><P
>&#13;Let us now see an example where linear list-nodes are explicitly freed:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3890"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_vt_free
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_free <span class="keyword">(</span>xs1<span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [list_vt_free] *)</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;Given a linear list, the function <FONT
COLOR="RED"
>list_vt_free</FONT
> frees all the
nodes in the list. Let us go over the body of <FONT
COLOR="RED"
>list_vt_free</FONT
>
carefully.  If <FONT
COLOR="RED"
>xs</FONT
> matches the pattern <FONT
COLOR="RED"
>list_vt_cons(x,
xs1)</FONT
>, then the names <FONT
COLOR="RED"
>x</FONT
> and <FONT
COLOR="RED"
>xs1</FONT
> are bound to the
head and tail of <FONT
COLOR="RED"
>xs</FONT
>, respectively; the special symbol
<FONT
COLOR="RED"
>~</FONT
> in front of the pattern indicates that the list-node referred
to by <FONT
COLOR="RED"
>xs</FONT
> is freed immediately after <FONT
COLOR="RED"
>xs</FONT
> matches the
pattern.  If <FONT
COLOR="RED"
>xs</FONT
> matches the pattern <FONT
COLOR="RED"
>list_vt_nil()</FONT
>,
no bindings are generated; the special symbol <FONT
COLOR="RED"
>~</FONT
> in front of the
pattern indicates that the list-node referred to by <FONT
COLOR="RED"
>xs</FONT
> is
freed; nothing in this case is actually freed at run-time as
<FONT
COLOR="RED"
>list_vt_nil</FONT
> is mapped to the null pointer.

</P
><P
>&#13;It is also possible to use the special function <FONT
COLOR="RED"
>free@</FONT
> to
explicitly free a node (also called a skeleton) left in a linear variable
after the variable matches a pattern formed with a constructor associated
with some dataviewtype. For instance, the following code gives another
implementation of <FONT
COLOR="RED"
>list_vt_free</FONT
>:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3911"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list_vt_free
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> xs1_ <span class="keyword">=</span> xs1</span> <span class="comment">// [xs1_] is the value stored in [xs1]</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">free@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> list_vt_free <span class="keyword">(</span>xs1_<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">free@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">// end of [list_vt_free]</span>
</p></PRE
><P
></P
></DIV
><P
>&#13;As it can be a bit tricky to use <FONT
COLOR="RED"
>free@</FONT
> in practice, I present
more details as follows. First, let us note that the constructors
<FONT
COLOR="RED"
>list_vt_nil</FONT
> and <FONT
COLOR="RED"
>list_vt_cons</FONT
> associated with
<FONT
COLOR="RED"
>list_vt</FONT
> are assigned the following types:

</P
><DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3918"
></A
><PRE
CLASS="programlisting"
>list_vt_nil : // one quantifier
  {a:t@ype} () -&#62; list_vt (a, 0)
list_vt_cons : // two quantifiers
  {a:t@ype}{n:nat} (a, list_vt (a, n)) -&#62; list_vt (a, n+1)
</PRE
><P
></P
></DIV
><P
>&#13;If <FONT
COLOR="RED"
>free@</FONT
> is applied to a node of the type
<FONT
COLOR="RED"
>list_vt_nil()</FONT
>, it needs one static argument, which is a type,
to instantiate the quantifier in the type of the constructor
<FONT
COLOR="RED"
>list_vt_nil</FONT
>. If <FONT
COLOR="RED"
>free@</FONT
> is applied to a node of the
type <FONT
COLOR="RED"
>list_vt_cons_unfold(L0, L1, L2)</FONT
>, then it needs two static
arguments, which are a type and an integer, to instantiate the two
quantifiers in the type of the constructor <FONT
COLOR="RED"
>list_vt_cons</FONT
>. In the
case where the type of <FONT
COLOR="RED"
>xs</FONT
> is <FONT
COLOR="RED"
>list_vt_cons_unfold(L0,
L1, L2)</FONT
>, typechecking the call <FONT
COLOR="RED"
>free@{a}{0}(xs)</FONT
> implicitly
consumes a proof of the at-view <FONT
COLOR="RED"
>a?@L1</FONT
> and another proof of the
at-view <FONT
COLOR="RED"
>list_vt(a, 0)?@L2</FONT
>.  As there is no difference between
<FONT
COLOR="RED"
>list_vt(T, 0)?</FONT
> and <FONT
COLOR="RED"
>list_vt(T, I)?</FONT
> for any T and I,
the static argument 0 is chosen in the code. As a matter of fact, any
natural number can be used in place of 0 as the second static argument of
<FONT
COLOR="RED"
>free@</FONT
>.

</P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="linear-list-reversing"
>Linear List-Reversing</A
></H3
><P
>&#13;The following code implements a function <FONT
COLOR="RED"
>reverse</FONT
> that turns a
given linear list into its reverse:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3939"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> reverse<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> revapp
    <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> i+j==n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
        <span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> xs1_ <span class="keyword">=</span> xs1</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs1 := ys</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        revapp <span class="keyword">(</span>xs1_<span class="keyword">,</span> xs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys</span>
  <span class="comment">// end of [revapp]</span>
<span class="keyword">in</span>
  revapp <span class="keyword">(</span>xs<span class="keyword">,</span> list_vt_nil<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [reverse]</span>
</p></PRE
><P
></P
></DIV
>


The type assigned to <FONT
COLOR="RED"
>reverse</FONT
> indicates that the function
returns a linear list of the same length as the one it consumes.  Note that
the inner function <FONT
COLOR="RED"
>revapp</FONT
> is tail-recursive.  This
implementation of linear list-reversing directly corresponds to the one
presented previously that is based the dataview <FONT
COLOR="RED"
>slseg_v</FONT
> (for
singly-linked list segments). Comparing the two implementations, we can see
that the one based on dataviewtype is significantly simplified at the level
of types. For instance, there is no explicit mentioning of pointers in the
types assigned to functions <FONT
COLOR="RED"
>reverse</FONT
> and <FONT
COLOR="RED"
>revapp</FONT
>.

</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="linear-list-appending"
>Linear List-Appending</A
></H3
><P
>&#13;The following code implements a function <FONT
COLOR="RED"
>append</FONT
> that
concatenates two given linear lists into one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3950"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> append<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="comment">// [loop] is tail-recursive</span>
  <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
        <span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs1<span class="keyword">,</span> ys<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs := ys</span>
  <span class="comment">// end of [loop]</span>
  <span class="keyword">var</span> xs<span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> xs <span class="comment">// creating a left-value for [xs]</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span></span>
<span class="keyword">in</span>
  xs
<span class="keyword">end</span></span> <span class="comment">// end of [append]</span>
</p></PRE
><P
></P
></DIV
>


As the call <FONT
COLOR="RED"
>fold@(xs)</FONT
> in the body of the function
<FONT
COLOR="RED"
>loop</FONT
> is erased after typechecking, <FONT
COLOR="RED"
>loop</FONT
> is a
tail-recursive function.  Therefore, <FONT
COLOR="RED"
>append</FONT
> can be called on
lists of any length without the concern of possible stack overflow. The
type for the first argument of <FONT
COLOR="RED"
>loop</FONT
> begins with the symbol
<FONT
COLOR="RED"
>&#38;</FONT
>, which indicates that this argument is
call-by-reference. The type of <FONT
COLOR="RED"
>loop</FONT
> simply means that its first
argument is changed from a list of length <FONT
COLOR="RED"
>m</FONT
> into a list of
length <FONT
COLOR="RED"
>m+n</FONT
> while its second argument is consumed.

</P
><P
>&#13;This implementation of list append essentially corresponds to the
one presented previously that is based on the dataview <FONT
COLOR="RED"
>slseg_v</FONT
>.
Comparing these two, we can easily see that the above one is much simpler
and cleaner, demonstrating concretely some advantage of dataviewtypes over
dataviews.

</P
><P
>&#13;This is also a good place for me to mention a closely related issue
involving (functional) list construction and tail-recursion. Following is a
typical implementation of functioal list concatenation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3964"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> append1<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> append1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [append1]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, <FONT
COLOR="RED"
>append1</FONT
> is not tail-recursive, which means that it may
cause stack overflow at run-time if its first argument is very long (e.g.,
containing 1 million elements). There is, however, a direct and type-safe
way in ATS to implement functional list concatenation in a tail-recursive
manner, thus eliminating the concern of potential stack overflow. For
instance, the following implementation of <FONT
COLOR="RED"
>append2</FONT
> returns the
concatenation of two given functional lists while being tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3968"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> append2<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">List</span> <span class="staexp">a</span><span class="keyword">)</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      <span class="keyword">(</span>res := ys<span class="keyword">)</span>
    <span class="comment">// end of [list_nil]</span>
  <span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> 
      res := list_cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> res1<span class="keyword">)</span> <span class="keyword">=</span> res</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> res1<span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>res<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">in</span>
      <span class="comment">// nothing</span>
    <span class="keyword">end</span></span> <span class="comment">// end of [list_cons]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> res<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [append2]</span>
</p></PRE
><P
></P
></DIV
>


During typechecking, the expression <FONT
COLOR="RED"
>list_cons{a}{0}(x, _)</FONT
>
is assigned the (linear) type <FONT
COLOR="RED"
>list_cons_unfold(L0, L1, L2)</FONT
>
for some addresses L0, L1 and L2 while a proof of the at-view
<FONT
COLOR="RED"
>a@L1</FONT
> and another proof of the at-view <FONT
COLOR="RED"
>list(a,
0)?@L2</FONT
> are put into the store for currently available proofs. Note
that the special symbol <FONT
COLOR="RED"
>_</FONT
> simply indicates that the tail
of the newly constructed list is uninitialized. A partially
initialized list of the type <FONT
COLOR="RED"
>list_cons_unfold(L0, L1, L2)</FONT
>
is guaranteed to match the pattern <FONT
COLOR="RED"
>list_cons(_, res1)</FONT
>,
yielding a binding between <FONT
COLOR="RED"
>res1</FONT
> and the pointer pointing
to L2 where the (possibly uninitialized) tail of the list is
stored. When <FONT
COLOR="RED"
>fold@</FONT
> is called on a variable of the type
<FONT
COLOR="RED"
>list_cons_unfold(L0, L1, L2)</FONT
>, it changes the type of the
variable to <FONT
COLOR="RED"
>list(T, N+1)</FONT
> by consuming a proof of the
at-view <FONT
COLOR="RED"
>T@L1</FONT
> and another proof of the at-view
<FONT
COLOR="RED"
>list(T, N)@L2</FONT
>, where T and N are a type and an integer,
respectively.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="linear-list-summary"
>Summary</A
></H3
><P
>&#13;With dataviewtypes, we can largely retain the convenience of pattern
matching associated with datatypes while supporting explicit memory
management.  Compared to dataviews, dataviewtypes are less
general. However, if a dataviewtype can be employed to solve a problem,
then the solution is often significantly simpler and cleaner than an
alternative dataview-based one.

</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_mergeSort_lin"
>Example: Merge-Sort on Linear Lists</A
></H2
><P
>&#13;When merge-sort is employed to sort an array of elements, it requires
additional memory proportionate to the size of the array in order to move
the elements around, which is considered a significant weakness of
merge-sort. However, merge-sort does not have this requirement when it
operates on a linear list.  I present as follows an implementation of
merge-sort on linear lists that can readily rival its counterpart in C in
terms of both time-efficiency and memory-efficiency. The invariants
captured in this implementation and the easiness to capture them should
provide strong evidence that attests to ATS being a programming language
capable of enforcing great precision in practical programming.

</P
><P
>&#13;Let us first introduce a type definition and an interface for a function
template that compares elements in lists to be sorted:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3990"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">cmp <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
compare <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The interface for merge-sort is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3992"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> mergeSort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [mergeSort]</span>
</p></PRE
><P
></P
></DIV
>


The first argument of <FONT
COLOR="RED"
>mergeSort</FONT
> is a linear list (to be sorted)
and the second one a function for comparing the elements in the linear
list.  Clearly, the interface of <FONT
COLOR="RED"
>mergeSort</FONT
> indicates that
<FONT
COLOR="RED"
>mergeSort</FONT
> consumes its first argument and then returns a linear
list that is of the same length as its first argument. As is to become clear,
the returned linear list is constructed with the nodes of the consumed
one. In particular, the implementation of <FONT
COLOR="RED"
>mergeSort</FONT
> given as
follows does not involve any memory allocation or deallocation.

</P
><P
>&#13;The function template for merging two sorted lists into one is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3999"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> merge<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> ys <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons <span class="keyword">(</span>y<span class="keyword">,</span> ys1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// stable sorting</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := xs</span>
          <span class="dynexp"><span class="keyword">val</span> xs1_ <span class="keyword">=</span> xs1</span>
          <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>ys<span class="keyword">)</span></span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs1_<span class="keyword">,</span> ys<span class="keyword">,</span> xs1<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
        <span class="keyword">in</span>
          <span class="keyword">fold@</span> <span class="keyword">(</span>res<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := ys</span>
          <span class="dynexp"><span class="keyword">val</span> ys1_ <span class="keyword">=</span> ys1</span>
          <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys1_<span class="keyword">,</span> ys1<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
        <span class="keyword">in</span>
          <span class="keyword">fold@</span> <span class="keyword">(</span>res<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="comment">(* end of [list_vt_cons] *)</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">;</span> res := xs<span class="keyword">)</span>
    <span class="keyword">)</span> <span class="comment">// end of [list_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := ys<span class="keyword">)</span></span>
<span class="comment">// end of [merge]</span>
</p></PRE
><P
></P
></DIV
>


Unlike the one given in a previous functional implementation, this
implementation of <FONT
COLOR="RED"
>merge</FONT
> is tail-recursive and thus is guaranteed
to be translated into a loop in C by the ATS compiler. This means that the
concern of <FONT
COLOR="RED"
>merge</FONT
> being unable to handle very long lists (e.g.,
containing 1 million elements) due to potential stack overflow is
eliminated.

</P
><P
>&#13;The next function template is for splitting a given linear lists into two:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4004"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> split<span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">k</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">k</span><span class="keyword">)</span><span class="keyword">,</span> nk<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">k</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> nk <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons<span class="keyword">(</span>_<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
    <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> split&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> nk-<span class="dynexp">1</span><span class="keyword">)</span></span><span class="keyword">;</span> <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    res
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> xs</span><span class="keyword">;</span> <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs := list_vt_nil <span class="keyword">(</span><span class="keyword">)</span></span> <span class="keyword">in</span> res
  <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
<span class="comment">// end of [split]</span>
</p></PRE
><P
></P
></DIV
>


Note that the implementation of <FONT
COLOR="RED"
>split</FONT
> is also tail-recursive.

</P
><P
>&#13;The following function template <FONT
COLOR="RED"
>msort</FONT
> takes a linear list, its
length and a comparsion function, and it returns a sorted version of the
given linear list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4009"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> msort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">2</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half<span class="keyword">(</span>n<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> n3 <span class="keyword">=</span> n - n2</span>
    <span class="keyword">var</span> xs <span class="keyword">=</span> xs <span class="comment">// lvalue for [xs]</span>
    <span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> split&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="comment">(*cbr*)</span><span class="keyword">,</span> n3<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> msort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> n3<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> msort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys<span class="keyword">,</span> n2<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="comment">// uninitialized</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> res<span class="comment">(*cbr*)</span><span class="keyword">,</span> cmp<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    res
  <span class="keyword">end</span> <span class="keyword">else</span> xs</span>
<span class="comment">// end of [msort]</span>
</p></PRE
><P
></P
></DIV
>


The second argument of <FONT
COLOR="RED"
>msort</FONT
> is passed so that the length of
the list being sorted does not have to be computed directly by traversing
the list when each recursive call to <FONT
COLOR="RED"
>msort</FONT
> is made.

</P
><P
>&#13;Finally, <FONT
COLOR="RED"
>mergeSort</FONT
> can be implemented with a call to
<FONT
COLOR="RED"
>msort</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4016"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
mergeSort <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> msort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> length <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


By inspecting the implementation of <FONT
COLOR="RED"
>split</FONT
> and
<FONT
COLOR="RED"
>merge</FONT
>, we can readiy see that <FONT
COLOR="RED"
>mergeSort</FONT
> performs
stable sorting, that is, it preserves the order of equal elements during
sorting.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/mergeSort.dats"
TARGET="_top"
>on-line</A
> the
entirety of the code presented in this section plus some additional code
for testing.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_insertionSort_lin"
>Example: Insertion Sort on Linear Lists</A
></H2
><P
>&#13;I present a standard implementation of insertion sort on linear lists in
this section.  The interface for insertion sort is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4026"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insertionSort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [insertionSort]</span>
</p></PRE
><P
></P
></DIV
>


Like <FONT
COLOR="RED"
>mergeSort</FONT
>, <FONT
COLOR="RED"
>insertionSort</FONT
> is implemented in a
manner that makes no use of memory allocation or deallocation.  Given a
linear list, <FONT
COLOR="RED"
>insertionSort</FONT
> essentially shuffles the nodes in
the list to form a sorted list.

</P
><P
>&#13;The following code implements a function <FONT
COLOR="RED"
>insord</FONT
> that inserts a
given list-node into a sorted linear list to form another sorted linear list:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4033"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insord
  <span class="staexp"><span class="keyword">{</span>l0<span class="keyword">,</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l1</span></span>
<span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l2</span></span>
<span class="keyword">|</span> xs0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">,</span> nx0<span class="keyword">:</span> <span class="staexp">list_vt_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l0</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">)</span><span class="keyword">,</span> p1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">,</span> p2<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l2</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs0 <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
      <span class="keyword">(</span>x0<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> <span class="keyword">!</span>p1<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="comment">// HX: for stableness: [&lt;=] instead of [&lt;]</span>
        <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> insord&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf1</span><span class="keyword">,</span> <span class="prfexp">pf2</span> <span class="keyword">|</span> xs1<span class="keyword">,</span> nx0<span class="keyword">,</span> p1<span class="keyword">,</span> p2<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
          <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">in</span>
          <span class="comment">// nothing</span>
        <span class="keyword">end</span></span> <span class="comment">// end of [then]</span>
        <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs0<span class="keyword">)</span></span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>p2 := xs0<span class="keyword">;</span> xs0 := nx0<span class="keyword">)</span></span>
          <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">in</span>
          <span class="comment">// nothing</span>
        <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
      <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">{</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs0 := nx0</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p2 := list_vt_nil <span class="keyword">(</span><span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs0<span class="keyword">)</span></span>
    <span class="keyword">}</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [insord] *)</span>
</p></PRE
><P
></P
></DIV
>


The implementation of <FONT
COLOR="RED"
>insord</FONT
> is tail-recursive.  The type
assigned to <FONT
COLOR="RED"
>insord</FONT
> indicates that the argument xs0 of
<FONT
COLOR="RED"
>insord</FONT
> is call-by-reference. If xs0 stores a list of length n
when <FONT
COLOR="RED"
>insord</FONT
> is called, then it stores a list of length n+1 when
<FONT
COLOR="RED"
>insord</FONT
> returns. The arguments nx0, p1 and p2 are call-by-value,
and they should be bound to a list-node and the first and second fields in
the list-node, respectively, when a call to <FONT
COLOR="RED"
>insord</FONT
>
initiates. The proof arguments pf1 and pf2 are needed so that the pointers
bound to p1 and p2 can be accessed and updated.

</P
><P
>&#13;The function template <FONT
COLOR="RED"
>insertionSort</FONT
> can now be readily
implemented based <FONT
COLOR="RED"
>insord</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4044"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
insertionSort
  <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> xs1_ <span class="keyword">=</span> xs1</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span>
        insord&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>x</span><span class="keyword">,</span> <span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>xs1</span> <span class="keyword">|</span> ys<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>x<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>xs1<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="comment">// end of [va]</span>
    <span class="keyword">in</span>
      loop <span class="keyword">(</span>xs1_<span class="keyword">,</span> ys<span class="keyword">,</span> cmp<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">var</span> ys <span class="keyword">=</span> list_vt_nil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  ys
<span class="keyword">end</span></span> <span class="comment">// end of [insertionSort]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>insertionSort</FONT
> is
tail-recursive.  While insertion sort is of O(n^2)-time complexity, it is
often more efficient than merge-sort or quick-sort when sorting very short
lists.  For instance, we may implement <FONT
COLOR="RED"
>msort</FONT
> (which is called
by <FONT
COLOR="RED"
>mergeSort</FONT
>) as follows by taking advantage of the efficiency
of <FONT
COLOR="RED"
>insertionSort</FONT
> on short lists:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4050"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> msort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="comment">// cutoff is selected to be 10</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">10</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half<span class="keyword">(</span>n<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> n3 <span class="keyword">=</span> n - n2</span>
    <span class="keyword">var</span> xs <span class="keyword">=</span> xs <span class="comment">// lvalue for [xs]</span>
    <span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> split&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> n3<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> msort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> n3<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> msort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys<span class="keyword">,</span> n2<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="comment">// uninitialized</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> res<span class="comment">(*cbr*)</span><span class="keyword">,</span> cmp<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    res
  <span class="keyword">end</span> <span class="keyword">else</span> insertionSort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [msort]</span>
</p></PRE
><P
></P
></DIV
>


Note that the stableness of <FONT
COLOR="RED"
>mergeSort</FONT
> is maintained as
<FONT
COLOR="RED"
>insertionSort</FONT
> also performs stable sorting.

</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/insertionSort.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="example_quickSort_lin"
>Example: Quick-Sort on Linear Lists</A
></H2
><P
>&#13;In this section, I give an implementation of quick-sort on linear
lists. While list-based quick-sort may not be a preferred sorting method in
practice, its implementation is nonetheless interesting.
The interface for quick-sort is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4059"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
quickSort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Like the implementation of <FONT
COLOR="RED"
>mergeSort</FONT
> and
<FONT
COLOR="RED"
>insertionSort</FONT
>, the implementation of <FONT
COLOR="RED"
>quickSort</FONT
>
given as follows makes no use of memory allocation and deallocation.

</P
><P
>&#13;The following code implements a function <FONT
COLOR="RED"
>takeout_node_at</FONT
> that
takes out a node from a linear list at a given position:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4066"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
takeout_node_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">k</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt_cons_pstruct</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">ptr</span><span class="staexp">?</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span> k <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> takeout_node_at&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> k-<span class="dynexp">1</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> xs</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs := xs1</span>
<span class="keyword">in</span>
  $UNSAFE<span class="keyword">.</span>castvwtp0 <span class="keyword">(</span><span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>x</span><span class="keyword">,</span> <span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span>xs1</span> <span class="keyword">|</span> nx<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// HX: this is a safe cast</span>
<span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [takeout_node_at] *)</span>
</p></PRE
><P
></P
></DIV
>


Assume that a data constructor named <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo</I
></SPAN
> is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the
name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo_pstruct</I
></SPAN
> that takes n types to form a viewtype, where
n is the arity of <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>foo</I
></SPAN
>. For instance, there is a viewtype
constructor <FONT
COLOR="RED"
>list_vt_cons_pstruct</FONT
> that takes 2 types T1 and T2
to form a viewtype <FONT
COLOR="RED"
>list_vt_cons_pstruct(T1, T2)</FONT
>. This viewtype
is for a list-node created by a call to <FONT
COLOR="RED"
>list_vt_cons</FONT
> such that
the two arguments of <FONT
COLOR="RED"
>list_vt_cons</FONT
> are of types T1 and T2.
Essentially, <FONT
COLOR="RED"
>list_vt_cons_pstruct(T1, T2)</FONT
> stands for
<FONT
COLOR="RED"
>list_vt_cons_unfold(L0, L1, L2)</FONT
> for some addresses L0, L1 and
L2 plus two views <FONT
COLOR="RED"
>T1@L1</FONT
> and <FONT
COLOR="RED"
>T2@L2</FONT
>.

</P
><P
>&#13;A key step in quick-sort lies in partitioning a linear list based on a
given pivot. This step is fulfilled by the following code that implements a
function template named <FONT
COLOR="RED"
>partition</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4081"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> partition<span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>r1<span class="keyword">,</span>r2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> pvt<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span>
<span class="keyword">,</span> r1<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">r1</span><span class="keyword">)</span><span class="keyword">,</span> res1<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">r1</span><span class="keyword">)</span><span class="keyword">,</span> res2<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">r2</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat <span class="keyword">|</span> n1+n2==n+r1+r2<span class="keyword">]</span></span>
  <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs_tail<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> xs_tail_ <span class="keyword">=</span> xs_tail</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> pvt<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> r1 <span class="keyword">=</span> r1 + <span class="dynexp">1</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs_tail := res1</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        partition&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs_tail_<span class="keyword">,</span> pvt<span class="keyword">,</span> r1<span class="keyword">,</span> xs<span class="keyword">,</span> res2<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs_tail := res2</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        partition&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs_tail_<span class="keyword">,</span> pvt<span class="keyword">,</span> r1<span class="keyword">,</span> res1<span class="keyword">,</span> xs<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]</span>
    <span class="keyword">end</span> <span class="comment">(* end of [list_vt_cons] *)</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>r1<span class="keyword">,</span> res1<span class="keyword">,</span> res2<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [partition] *)</span>
</p></PRE
><P
></P
></DIV
>


The implementation of <FONT
COLOR="RED"
>partition</FONT
> is tail-recursive.  Given a
linear list and a pivot, <FONT
COLOR="RED"
>partition</FONT
> returns a tuple (r1, res1,
res2) such that res1 contains every element in the list that is less than
or equal to the pivot, res2 contains the rest, and r1 is the length of
res1. The way in which the nodes of the given linear list are moved into
res1 and res2 is quite an interesting aspect of this implementation.

</P
><P
>&#13;By making use of <FONT
COLOR="RED"
>takeout_node_at</FONT
> and <FONT
COLOR="RED"
>partition</FONT
>,
we can readily implement <FONT
COLOR="RED"
>quickSort</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4089"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
quickSort
  <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> sort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">10</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> n2 <span class="keyword">=</span> half <span class="keyword">(</span>n<span class="keyword">)</span></span>
    <span class="keyword">var</span> xs <span class="keyword">=</span> xs
    <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> takeout_node_at&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> n2<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val+</span>list_vt_cons <span class="keyword">(</span>pvt<span class="keyword">,</span> nx_next<span class="keyword">)</span> <span class="keyword">=</span> nx</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>n1<span class="keyword">,</span> xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span>
    partition&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> pvt<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">,</span> list_vt_nil<span class="keyword">,</span> list_vt_nil<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> sort <span class="keyword">(</span>xs1<span class="keyword">,</span> n1<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> sort <span class="keyword">(</span>xs2<span class="keyword">,</span> n - <span class="dynexp">1</span> - n1<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> nx_next := xs2</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    list_vt_append <span class="keyword">(</span>xs1<span class="keyword">,</span> nx<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> insertionSort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [sort] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  sort <span class="keyword">(</span>xs<span class="keyword">,</span> list_vt_length <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [quickSort]</span>
</p></PRE
><P
></P
></DIV
>


Note that the pivot for each round is taken from the middle of the list
being sorted, which can be time-consuming as taking out a node from the
middle of a list is O(n)-time. This issue can be addressed by always
choosing the first element to be the pivot. However, doing so can
often lead to degenerated O(n^2)-time performance of quick-sort in practice.

</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/quickSort.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear_binary_search_trees"
>Linear Binary Search Trees</A
></H2
><P
>&#13;A binary search tree with respect to a given ordering is a binary tree such
that the value stored in each node inside the tree is greater than or equal
to those stored in the left child of the node and less than or equal to
those stored in the right child of the node.  Binary search trees are a
common data structure for implementing finite maps.

</P
><P
>&#13;A family of binary
trees are said to be balanced if there is a fixed constant C (for the
entire family) such that the ratio between the length of a longest path and
the length of a shortest path is bounded by C for every tree in the
family. For instance, common examples of balanced binary trees include AVL
trees and red-black trees. Finite maps based on balanced binary search
trees support guaranteed log-time insertion and deletion operations, that
is, the time to complete such an operation is O(log(n)) in the worst case,
where n is the size of the map.

</P
><P
>&#13;In this section, I am to implement several basic operations on linear
binary search trees, further illustrating some use of dataviewtypes. Let us
first declare as follows a dataviewtype <FONT
COLOR="RED"
>bstree_vt</FONT
> for linear
binary (search) trees:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4099"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datavtype</span>
<span class="staexp">bstree_vt
<span class="keyword">(</span>
  a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// bstree_vt</span>
  <span class="keyword">|</span> <span class="dynexp">bstree_vt_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    bstree_vt_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">bstree_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bstree_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [bstree_vt]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Note that the integer index of <FONT
COLOR="RED"
>bstree_vt</FONT
> captures the size
information of a binary (search) tree.  There are two constructors
<FONT
COLOR="RED"
>bstree_vt_cons</FONT
> and <FONT
COLOR="RED"
>bstree_vt_nil</FONT
> associated with
<FONT
COLOR="RED"
>bstree_vt</FONT
>. It should be pointed out that the tree created by
<FONT
COLOR="RED"
>bstree_vt_nil</FONT
> is empty and thus not a leaf, which on the other
hand is a node whose left and right children are both empty.  As a simple
example, the following function template <FONT
COLOR="RED"
>size</FONT
> computes the size
of a given tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4108"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> size<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> bstree_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
  <span class="keyword">|</span> bstree_vt_cons
     <span class="keyword">(</span>tl<span class="keyword">,</span> _<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">1</span> + size <span class="keyword">(</span>tl<span class="keyword">)</span> + size <span class="keyword">(</span>tr<span class="keyword">)</span></span>
<span class="comment">// end of [size]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Assume that we have a binary search tree with repect to some ordering.  If
a predicate P on the elements stored in the tree possesses the property
that P(x1) implies P(x2) whenever x1 is less than x2 (according to the
ordering), then we can locate the least element in the tree that satisfies
the predicate P by employing so-called binary search as is demonstrated in
the following implementation of <FONT
COLOR="RED"
>search</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4112"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> search
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> P<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>bstree_vt_cons
      <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      <span class="keyword">if</span> P <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> search <span class="keyword">(</span>tl<span class="keyword">,</span> P<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> <span class="keyword">(</span>
          <span class="keyword">case+</span> res <span class="keyword">of</span>
          <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> res
        <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> res
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> search <span class="keyword">(</span>tr<span class="keyword">,</span> P<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> res
      <span class="keyword">end</span> <span class="comment">// end of [if]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>bstree_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [search]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, if the argument <FONT
COLOR="RED"
>t</FONT
> of <FONT
COLOR="RED"
>search</FONT
> ranges over a
family of balanced trees, then the time-complexity of <FONT
COLOR="RED"
>search</FONT
> is
O(log(n)) (assuming that <FONT
COLOR="RED"
>P</FONT
> is O(1)).

</P
><P
>&#13;Let us next see some code implementing an operation that inserts a given
element into a binary search tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4119"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insert<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>bstree_vt_cons
      <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tl := insert <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tr := insert <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
      <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
    <span class="keyword">end</span> <span class="comment">// end of [bstree_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>bstree_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      bstree_vt_cons <span class="keyword">(</span>bstree_vt_nil<span class="keyword">,</span> x0<span class="keyword">,</span> bstree_vt_nil<span class="keyword">)</span></span>
    <span class="comment">// end of [bstree_vt_nil]</span>
<span class="comment">// end of [insert]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;When inserting an element, the function template <FONT
COLOR="RED"
>insert</FONT
> extends
the given tree with a new leaf node containing the element, and this form
of insertion is often referred to as leaf-insertion.  There is another form
of insertion often referred to as root-insertion, which always puts at the
root position the new node containing the inserted element. The following
function template <FONT
COLOR="RED"
>insertRT</FONT
> is implemented to perform a standard
root-insertion operation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4124"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insertRT<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>bstree_vt_cons
      <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> tl_ <span class="keyword">=</span> insertRT <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>bstree_vt_cons <span class="keyword">(</span>_<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl_</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tl := tlr</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := t</span>
      <span class="keyword">in</span>
        <span class="keyword">fold@</span> <span class="keyword">(</span>tl_<span class="keyword">)</span><span class="keyword">;</span> tl_
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> tr_ <span class="keyword">=</span> insertRT <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>bstree_vt_cons <span class="keyword">(</span>trl<span class="keyword">,</span> _<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr_</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tr := trl</span>
        <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := t</span>
      <span class="keyword">in</span>
        <span class="keyword">fold@</span> <span class="keyword">(</span>tr_<span class="keyword">)</span><span class="keyword">;</span> tr_
      <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">// end of [bstree_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>bstree_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      bstree_vt_cons <span class="keyword">(</span>bstree_vt_nil<span class="keyword">,</span> x0<span class="keyword">,</span> bstree_vt_nil<span class="keyword">)</span></span>
    <span class="comment">// end of [bstree_vt_nil]</span>
<span class="comment">// end of [insertRT]</span>
</p></PRE
><P
></P
></DIV
>


The code immediately following the first recursive call to
<FONT
COLOR="RED"
>insertRT</FONT
> performs a right tree rotation. Let us use T(tl, x,
tr) for a tree such that its root node contains the element x and its left
and right children are tl and tr, respectively. Then a right rotation turns
T(T(tll, xl, tlr), x, tr) into T(tll, xl, T(tlr, x, tr)).  The code
immediately following the second recursive call to <FONT
COLOR="RED"
>insertRT</FONT
>
performs a left tree rotation, which turns T(tl, x, T(trl, xr, trr)) into
T(T(tl, x, tlr), xr, trr).

</P
><P
>&#13;To further illustrate tree rotations, I present as follows
two function templates <FONT
COLOR="RED"
>lrotate</FONT
> and <FONT
COLOR="RED"
>rrotate</FONT
>, which
implement the left and right tree rotations, respectively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4131"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> lrotate
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span> 
  <span class="staexp"><span class="keyword">{</span>nl<span class="keyword">,</span>nr<span class="keyword">:</span>int <span class="keyword">|</span> nl &gt;= 0<span class="keyword">;</span> nr <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">nl</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">nr</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">bstree_vt_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tl<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l_tl</span>
<span class="keyword">,</span> p_tr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l_tr</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">1</span><span class="staexp">+</span><span class="staexp">nl</span><span class="staexp">+</span><span class="staexp">nr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> tr <span class="keyword">=</span> <span class="keyword">!</span>p_tr</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>bstree_vt_cons <span class="keyword">(</span>trl<span class="keyword">,</span> _<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tr := trl</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span><span class="keyword">;</span> <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := t</span>
<span class="keyword">in</span>
  <span class="keyword">fold@</span> <span class="keyword">(</span>tr<span class="keyword">)</span><span class="keyword">;</span> tr
<span class="keyword">end</span></span> <span class="comment">// end of [lrotate]</span>

<span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> rrotate
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nl<span class="keyword">,</span>nr<span class="keyword">:</span>int <span class="keyword">|</span> nl <span class="keyword">&gt;</span> 0<span class="keyword">;</span> nr &gt;= 0<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">nl</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">nr</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">bstree_vt_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tl<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l_tl</span>
<span class="keyword">,</span> p_tr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l_tr</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">1</span><span class="staexp">+</span><span class="staexp">nl</span><span class="staexp">+</span><span class="staexp">nr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> tl <span class="keyword">=</span> <span class="keyword">!</span>p_tl</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>bstree_vt_cons <span class="keyword">(</span>tll<span class="keyword">,</span> x<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tl := tlr</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span><span class="keyword">;</span> <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := t</span>
<span class="keyword">in</span>
  <span class="keyword">fold@</span> <span class="keyword">(</span>tl<span class="keyword">)</span><span class="keyword">;</span> tl
<span class="keyword">end</span></span> <span class="comment">// end of [rrotate]</span>
</p></PRE
><P
></P
></DIV
>


Given 4 addresses L0, L1, L2 and L3, the type
<FONT
COLOR="RED"
>bstree_vt_cons_unfold(L0, L1, L2, l3)</FONT
> is for a tree node
created by a call to <FONT
COLOR="RED"
>bstree_vt_cons</FONT
> such that the node is
located at L0 and the three arguments of <FONT
COLOR="RED"
>bstree_vt_cons</FONT
> are
located at L1, L2 and L3, and the proofs for the at-views associated with
L1, L2 and L3 are put in the store for currently available proofs.

</P
><P
>&#13;The function template <FONT
COLOR="RED"
>insertRT</FONT
> for root-insertion can now be
implemented as follows by making direct use of <FONT
COLOR="RED"
>lrotate</FONT
> and
<FONT
COLOR="RED"
>rrotate</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4140"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insertRT <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bstree_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>bstree_vt_cons
      <span class="keyword">(</span>tl<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_x <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>x</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tl <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tl</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tr <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tr</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tl := insertRT&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        rrotate&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tl<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tr := insertRT&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        lrotate&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tl<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
    <span class="keyword">end</span> <span class="comment">// end of [bstree_vt_cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>bstree_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      bstree_vt_cons <span class="keyword">(</span>bstree_vt_nil<span class="keyword">,</span> x0<span class="keyword">,</span> bstree_vt_nil<span class="keyword">)</span></span>
    <span class="comment">// end of [bstree_vt_nil]</span>
<span class="comment">// end of [insertRT]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;I would like to point out that neither <FONT
COLOR="RED"
>insert</FONT
> nor
<FONT
COLOR="RED"
>insertRT</FONT
> is tail-recursive. While it is straightforward to give
the former a tail-recursive implementation, there is no direct way to do
the same to the latter. In order to implement root-insertion in a
tail-recursive manner, we are in need of binary search trees with parental
pointers (so as to allow each node to gain direct access to its parent),
which can be done with dataviews but not with dataviewtypes.

</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/bstree_vt.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="transition_from_datatypes_to_dataviewtypes"
>Transition from Datatypes to Dataviewtypes</A
></H2
><P
>&#13;Many programmers are likely to find it a rather involved task to write code
manipulating values of dataviewtypes. When handling a complex data
structure, I myself often try to first use a datatype to model the data
structure and implement some functionalities of the data structure based
the datatype. I then change the datatype into a corresponding dataviewtype
and modify the implementation accordingly to make it work with the
dataviewtype. I now present as follows an implementation of linear
red-black trees that is directly based on a previous
<A
HREF="#example_fun_red-black_trees"
>implementation of functional red-black trees</A
>,
illustrating concretely a kind of gradual transition from datatypes to
dataviewtypes that can greatly reduce the level of difficulty one may
otherwise encounter in an attempt to program with dataviewtypes directly.

</P
><P
>&#13;The following declaration of dataviewtype <FONT
COLOR="RED"
>rbtree</FONT
> is identical
to the previous declaration of datatype <FONT
COLOR="RED"
>rbtree</FONT
> except the
keyword <FONT
COLOR="RED"
>datavtype</FONT
> being now used instead of the keyword
<FONT
COLOR="RED"
>datatype</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4156"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="neuexp"><span class="keyword">#define</span> BLK 0</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> RED 1</span>
<span class="staexp"><span class="keyword">sortdef</span> clr <span class="keyword">=</span> <span class="keyword">{</span>c<span class="keyword">:</span>int <span class="keyword">|</span> 0 &lt;= c<span class="keyword">;</span> c &lt;= 1<span class="keyword">}</span></span>

<span class="keyword">datavtype</span> <span class="staexp">rbtree
<span class="keyword">(</span>
  a<span class="keyword">:</span> <span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="comment">(*c*)</span><span class="keyword">,</span> int<span class="comment">(*bh*)</span><span class="keyword">,</span> int<span class="comment">(*v*)</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// element type, color, black height, violations</span>
  <span class="keyword">|</span> <span class="dynexp">rbtree_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>c<span class="keyword">,</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>int<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>c==BLK &amp;&amp; v==0 || c == RED &amp;&amp; v==cl+cr<span class="keyword">}</span></span>
    rbtree_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="staexp">-</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [rbtree]</span>

<span class="keyword">where</span> <span class="staexp">rbtree0 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">c<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">bh<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;At the first sight, the following function template <FONT
COLOR="RED"
>insfix_l</FONT
> is
greatly more involved that a previous version of the same name (for
manipulating functional red-black trees):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4160"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_l <span class="comment">// right rotation</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_c<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">BLK</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_c</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">rbtree_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_c</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tl<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l_tl</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span>
  <span class="neuexp"><span class="keyword">#define</span> R RED</span>
  <span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
  <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">!</span>p_tl <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cl</span> <span class="keyword">as</span> R<span class="keyword">,</span> <span class="staexp">tll</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cll</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cll := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tll<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tl <span class="keyword">=</span> <span class="keyword">!</span>p_tl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tl := tlr</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := t</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tl<span class="keyword">)</span><span class="keyword">;</span> tl
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, cons (R, ...), ...)]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cl</span> <span class="keyword">as</span> R<span class="keyword">,</span> tll<span class="keyword">,</span> _<span class="keyword">,</span> <span class="staexp">tlr</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">clr</span> <span class="keyword">as</span> R<span class="keyword">,</span> tlrl<span class="keyword">,</span> _<span class="keyword">,</span> tlrr<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tl <span class="keyword">=</span> <span class="keyword">!</span>p_tl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tl := tlrr</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlrr := t</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tlr_ <span class="keyword">=</span> tlr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := tlrl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cl := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tl<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlrl := tl</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tlr_<span class="keyword">)</span><span class="keyword">;</span> tlr_
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, ..., cons (R, ...))]</span>
  <span class="keyword">|</span> _ <span class="comment">(*rest-of-cases*)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_l]</span>
</p></PRE
><P
></P
></DIV
>


However, I would like to point out that the interface for the above
<FONT
COLOR="RED"
>insfix_l</FONT
> is a <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>direct</I
></SPAN
> translation of the interface for
the previous <FONT
COLOR="RED"
>insfix_l</FONT
>. In other words, the previously captured
relation between a tree being rotated and the one obtained from applying
<FONT
COLOR="RED"
>insfix_l</FONT
> to it also holds in the setting of linear red-black trees.
The very same statement can be made about the following function template
<FONT
COLOR="RED"
>insfix_r</FONT
>, which is precisely a mirror image of <FONT
COLOR="RED"
>insfix_l</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4168"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_r <span class="comment">// left rotation</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_c<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>
  <span class="prfexp">pf_c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">BLK</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_c</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">rbtree_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_c</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span>
  <span class="neuexp"><span class="keyword">#define</span> R RED</span>
  <span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
  <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">!</span>p_tr <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cr</span> <span class="keyword">as</span> R<span class="keyword">,</span> trl<span class="keyword">,</span> _<span class="keyword">,</span> <span class="staexp">trr</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">crr</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> crr := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>trr<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tr <span class="keyword">=</span> <span class="keyword">!</span>p_tr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tr := trl</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := t</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tr<span class="keyword">)</span><span class="keyword">;</span> tr
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, ..., cons (R, ...))]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cr</span> <span class="keyword">as</span> R<span class="keyword">,</span> <span class="staexp">trl</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">crr</span> <span class="keyword">as</span> R<span class="keyword">,</span> trll<span class="keyword">,</span> _<span class="keyword">,</span> trlr<span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tr <span class="keyword">=</span> <span class="keyword">!</span>p_tr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tr := trll</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trll := t</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> trl_ <span class="keyword">=</span> trl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := trlr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cr := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tr<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trlr := tr</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>trl_<span class="keyword">)</span><span class="keyword">;</span> trl_
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, cons (R, ...), ...)]</span>
  <span class="keyword">|</span> _ <span class="comment">(*rest-of-cases*)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_r]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;As can be expected, the following function template
<FONT
COLOR="RED"
>rbtree_insert</FONT
> is essentially a direct translation of the one of
the same name for inserting an element into a functional red-black tree:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4172"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
rbtree_insert
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>bh1<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">bh1</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
rbtree_insert
  <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> B BLK</span>
<span class="neuexp"><span class="keyword">#define</span> R RED</span>
<span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
<span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> ins
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">bh</span><span class="keyword">,</span><span class="staexp">c</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>cl<span class="keyword">:</span>clr<span class="keyword">;</span> v<span class="keyword">:</span>nat <span class="keyword">|</span> v &lt;= c<span class="keyword">]</span></span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span>
      c<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_c <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>c</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tl <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tl</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_x <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>x</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tr <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tr</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cl<span class="keyword">:</span>int</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tl_ <span class="keyword">=</span> ins <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tl := tl_</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>c <span class="keyword">=</span> B<span class="keyword">)</span>
        <span class="keyword">then</span> <span class="keyword">(</span>
          insfix_l&lt;<span class="staexp">a</span><span class="keyword">&gt;</span>
            <span class="keyword">(</span><span class="prfexp">pf_c</span><span class="keyword">,</span> <span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tl<span class="keyword">)</span>
          <span class="comment">// end of [insfix_l]</span>
        <span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> c := R</span> <span class="keyword">in</span> <span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cl<span class="keyword">}</span></span><span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
        <span class="keyword">end</span> <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cr<span class="keyword">:</span>int</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tr_ <span class="keyword">=</span> ins <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tr := tr_</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>c <span class="keyword">=</span> B<span class="keyword">)</span>
        <span class="keyword">then</span> <span class="keyword">(</span>
          insfix_r&lt;<span class="staexp">a</span><span class="keyword">&gt;</span>
            <span class="keyword">(</span><span class="prfexp">pf_c</span><span class="keyword">,</span> <span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tr<span class="keyword">)</span>
          <span class="comment">// end of [insfix_r]</span>
        <span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> c := R</span> <span class="keyword">in</span> <span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cr<span class="keyword">}</span></span><span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
        <span class="keyword">end</span> <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span><span class="keyword">(</span>R<span class="keyword">,</span> nil<span class="keyword">,</span> x0<span class="keyword">,</span> nil<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [ins] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> t <span class="keyword">=</span> ins <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">@</span>cons<span class="keyword">(</span><span class="staexp">c</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>c := B<span class="keyword">;</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;&gt;</span> t
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [rbtree_insert]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;I literally implemented the above <FONT
COLOR="RED"
>rbtree_insert</FONT
> by making a
copy of the previous implementation of <FONT
COLOR="RED"
>rbtree_insert</FONT
> for
functional red-black trees and then properly modifying it to make it pass
typechecking. Although this process of copying-and-modifying is difficult
to be described formally, it is fairly straightforward to follow in
practice as it is almost entirely guided by the error messages issued
during typechecking.

</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/rbtree.dats"
TARGET="_top"
>on-line</A
>.
A challenging as well as rewarding exercise is for the reader to implement
an operation that deletes an element from a given linear red-black tree.

</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="abstract_views_viewtypes"
></A
>Chapter 16. Abstract Views and Viewtypes</H1
><P
>&#13;I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>conceptually</I
></SPAN
> whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="simple-linear-objects"
>Simple Linear Objects</A
></H2
><P
>&#13;Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>simple linear object</I
></SPAN
> here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.
</P
><P
>&#13;Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4188"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span> timer_vtype</span>
<span class="keyword">vtypedef</span> <span class="staexp">timer <span class="keyword">=</span> <span class="staexp">timer_vtype</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> timer_new <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">timer</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_free <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_start <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_finish <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_pause <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_resume <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_get_ntick <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">uint</span></span>
<span class="dynexp"><span class="keyword">fun</span> timer_reset <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">timer</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The state of a timer is given the
record type <FONT
COLOR="RED"
>timer_struct</FONT
> defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4191"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">timer_struct <span class="keyword">=</span> <span class="keyword">@{</span>
  <span class="stalab">started</span><span class="keyword">=</span> <span class="staexp">bool</span> <span class="comment">// the timer has started</span>
<span class="keyword">,</span> <span class="stalab">running</span><span class="keyword">=</span> <span class="staexp">bool</span> <span class="comment">// the timer is running</span>
  <span class="comment">// the tick number recorded when the timer</span>
<span class="keyword">,</span> <span class="stalab">ntick_beg</span><span class="keyword">=</span> <span class="staexp">uint</span> <span class="comment">// was turned on last time</span>
<span class="keyword">,</span> <span class="stalab">ntick_acc</span><span class="keyword">=</span> <span class="staexp">uint</span> <span class="comment">// the number of accumulated ticks</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [timer_struct] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The following linear datatype <FONT
COLOR="RED"
>timer</FONT
>
is declared for timers, and the abstract type <FONT
COLOR="RED"
>timer_vtype</FONT
>
is assumed to equal <FONT
COLOR="RED"
>timer</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4196"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datavtype</span> <span class="staexp">timer <span class="keyword">=</span>
  <span class="dynexp">TIMER <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">timer_struct</span><span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">assume</span> timer_vtype <span class="keyword">=</span> timer</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4199"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_new <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> timer <span class="keyword">=</span> TIMER <span class="keyword">(</span>_<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> TIMER <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>started</span> := false</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := false</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span> := <span class="dynexp">0u</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> := <span class="dynexp">0u</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  timer
<span class="keyword">end</span></span> <span class="comment">// end of [timer_new]</span>

<span class="dynexp"><span class="keyword">implement</span>
timer_free <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">let</span> <span class="dynexp"><span class="keyword">val</span> <span class="keyword">~</span>TIMER _ <span class="keyword">=</span> timer</span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*nothing*)</span> <span class="keyword">end</span></span></span>
<span class="comment">// end of [timer_free]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The function for starting a timer can be implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4202"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_start
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>started</span> := true</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := true</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span> := the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> := <span class="dynexp">0u</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [timer_start]</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>the_current_tick_get</FONT
> is a function for
reading the current time (represented as a number of ticks):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4205"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span> the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">uint</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;A timer can be stopped or paused. The function for stopping a timer can be
implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4208"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_finish
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>started</span> := false</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x<span class="dynexp"><span class="keyword">.</span>running</span> <span class="keyword">then</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := false</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> :=
      x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> + the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span> - x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span></span>
  <span class="keyword">}</span></span> <span class="comment">(* end of [val] *)</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [timer_finish]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;A timer can be paused and then resumed.
The following code implements the functions for pausing and resuming a
timer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4211"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_pause
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x<span class="dynexp"><span class="keyword">.</span>running</span> <span class="keyword">then</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := false</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> :=
      x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> + the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span> - x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span></span>
  <span class="keyword">}</span></span> <span class="comment">(* end of [val] *)</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [timer_pause]</span>

<span class="dynexp"><span class="keyword">implement</span>
timer_resume
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x<span class="dynexp"><span class="keyword">.</span>started</span> &amp;&amp; <span class="keyword">~</span><span class="keyword">(</span>x<span class="dynexp"><span class="keyword">.</span>running</span><span class="keyword">)</span> <span class="keyword">then</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := true</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span> := the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">}</span></span> <span class="comment">(* end of [if] *)</span> <span class="comment">// end of [val]</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [timer_resume]</span>
</p></PRE
><P
></P
></DIV
>


As can be expected, the amount of time between the point
where a timer is paused and the point where the timer is resumed
is not counted.

</P
><P
>&#13;It is also possible to reset a timer by calling the function
<FONT
COLOR="RED"
>timer_reset</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4215"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_reset
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>started</span> := false</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>running</span> := false</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span> := <span class="dynexp">0u</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span> := <span class="dynexp">0u</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [timer_reset]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;In order to read the time accumulated by a timer,
the function <FONT
COLOR="RED"
>timer_get_ntick</FONT
> can be called:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4219"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
timer_get_ntick
  <span class="keyword">(</span>timer<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>TIMER<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> timer</span>
  <span class="keyword">var</span> ntick<span class="keyword">:</span> <span class="staexp">uint</span> <span class="keyword">=</span> x<span class="dynexp"><span class="keyword">.</span>ntick_acc</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> x<span class="dynexp"><span class="keyword">.</span>running</span> <span class="keyword">then</span> <span class="keyword">(</span>
    ntick := ntick + the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span> - x<span class="dynexp"><span class="keyword">.</span>ntick_beg</span>
  <span class="keyword">)</span></span> <span class="comment">(* end of [if] *)</span> <span class="comment">// end of [val]</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>timer<span class="keyword">)</span></span>
<span class="keyword">in</span>
  ntick
<span class="keyword">end</span></span> <span class="comment">// end of [timer_get_ntick]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;A straightforward approach to
implementing <FONT
COLOR="RED"
>the_current_tick_get</FONT
>
can be based directly on the function <FONT
COLOR="RED"
>clock_gettime</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4224"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">local</span>

<span class="keyword">staload</span> "libc/SATS/time.sats"

<span class="keyword">in</span> <span class="comment">(* in-of-local *)</span>

<span class="dynexp"><span class="keyword">implement</span>
the_current_tick_get <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> tv<span class="keyword">:</span> <span class="staexp">timespec</span> <span class="comment">// uninitialized</span>
  <span class="dynexp"><span class="keyword">val</span> err <span class="keyword">=</span> clock_gettime <span class="keyword">(</span>CLOCK_REALTIME<span class="keyword">,</span> tv<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>err &gt;= <span class="dynexp">0</span><span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> opt_unsome<span class="staexp"><span class="keyword">{</span>timespec<span class="keyword">}</span></span><span class="keyword">(</span>tv<span class="keyword">)</span></span>
<span class="keyword">in</span>
  $UNSAFE<span class="keyword">.</span>cast2uint<span class="keyword">(</span>tv<span class="dynexp"><span class="keyword">.</span>tv_sec</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [the_current_tick_get]</span>

<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</p></PRE
><P
></P
></DIV
>


Note that the library flag <FONT
COLOR="RED"
>-lrt</FONT
> may be needed in order to
have link-time access to <FONT
COLOR="RED"
>clock_gettime</FONT
> as the function is in
<FONT
COLOR="RED"
>librt</FONT
>.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/timer.dats"
TARGET="_top"
>on-line</A
> the
entirety of the code presented in this section plus some testing code.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="memory-allocation-deallocation"
>Memory Allocation and Deallocation</A
></H2
><P
>&#13;The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

</P
><P
>&#13;The following function <FONT
COLOR="RED"
>malloc_gc</FONT
> is available in ATS for memory
allocation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4236"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> malloc_gc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">b0ytes</span> <span class="staexp">n</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">// end of [malloc_gc]</span>
</p></PRE
><P
></P
></DIV
>


The sort <FONT
COLOR="RED"
>agz</FONT
> is a subset sort defined for addresses that are not
null:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4239"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">sortdef</span> agz <span class="keyword">=</span> <span class="keyword">{</span>a<span class="keyword">:</span>addr <span class="keyword">|</span> a <span class="keyword">&gt;</span> null<span class="keyword">}</span></span> <span class="comment">// [gz] for great-than-zero</span>
</p></PRE
><P
></P
></DIV
>


Given an integer N, the type <FONT
COLOR="RED"
>b0ytes(N)</FONT
> is a shorthand for
<FONT
COLOR="RED"
>@[byte?][N]</FONT
>, which is for an array of N uninitialized
bytes. Therefore, the at-view <FONT
COLOR="RED"
>b0ytes(N)@L</FONT
> is the same as the
array-view <FONT
COLOR="RED"
>array_v(byte?, L, N)</FONT
>, where L is a memory location.
The view constructor <FONT
COLOR="RED"
>mfree_gc_v</FONT
> is abstract. For a given
location L, the view <FONT
COLOR="RED"
>mfree_gc_v(L)</FONT
> stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function <FONT
COLOR="RED"
>mfree_gc</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4248"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> mfree_gc
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pfat<span class="keyword">:</span> <span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span><span class="keyword">,</span> <span class="prfexp">pfgc<span class="keyword">:</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [free_gc]</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>mfree_gc_v(L)</FONT
> is so far the first form of view we
have encountered that is not built on top of any at-views.

</P
><P
>&#13;In practice, it is rather cumbersome to deal with bytes directly.  The
function <FONT
COLOR="RED"
>ptr_alloc</FONT
> is available for allocating memory to store
a single value (of certain type) and the function <FONT
COLOR="RED"
>ptr_free</FONT
> for
deallocating such memory:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4254"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
ptr_alloc <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">// end of [ptr_alloc]</span>

<span class="dynexp"><span class="keyword">fun</span> ptr_free
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pfgc<span class="keyword">:</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span><span class="keyword">,</span> <span class="prfexp">pfat<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [ptr_free]</span>
</p></PRE
><P
></P
></DIV
>


In addition, the function <FONT
COLOR="RED"
>array_ptr_alloc</FONT
> is for allocating
memory to store an array of values (of certain type), and the function
<FONT
COLOR="RED"
>array_ptr_free</FONT
> is for deallocating such memory:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4258"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_ptr_alloc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span>
<span class="keyword">(</span>
  <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span></span> <span class="comment">// end of [array_ptr_alloc]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
array_ptr_free
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span><span class="keyword">,</span> <span class="prfexp"><span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_ptr_free]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
<FONT
COLOR="RED"
>msort1</FONT
> and <FONT
COLOR="RED"
>msort2</FONT
> perform merge-sort on a given array:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4263"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">cmp <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">int</span></span>

<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> msort1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [msort1]</span>

<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> msort2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [msort2]</span>
</p></PRE
><P
></P
></DIV
>


It is well-known that merging two sorted segments of a given array requires
additional space. When <FONT
COLOR="RED"
>msort1</FONT
> is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
<FONT
COLOR="RED"
>msort1</FONT
> returns, the sorted version of A is still sotred in
A. What <FONT
COLOR="RED"
>msort2</FONT
> does is similar but the sorted version of A is
stored in B when a call to <FONT
COLOR="RED"
>msort2</FONT
> returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of <FONT
COLOR="RED"
>msort1</FONT
> and <FONT
COLOR="RED"
>msort2</FONT
>.  An
implementation of merge-sort based on <FONT
COLOR="RED"
>msort1</FONT
> can be readily
given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4272"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> mergeSort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [mergeSort]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
mergeSort
  <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfat</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> msort1 <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_free <span class="keyword">(</span><span class="prfexp">pfat</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [mergeSort]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

</P
><P
>&#13;It is also allowed for a function to allocate memory on its call-stack
by calling a special function <FONT
COLOR="RED"
>alloca</FONT
>, which is given the
following type in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4276"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">(*
staload "libc/SATS/alloa.sats"
*)</span>
<span class="dynexp"><span class="keyword">fun</span> alloca
  <span class="staexp"><span class="keyword">{</span>dummy<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">void</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">dummy</span></span> <span class="keyword">|</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">dummy</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The type assigned to
<FONT
COLOR="RED"
>alloca</FONT
> makes it extremely unlikely for someone to
unintentionally write well-typed code in ATS that may erroneourly attempt
to access memory obtained from calling <FONT
COLOR="RED"
>alloca</FONT
> after the calling
function has returned.

</P
><P
>&#13;The following function <FONT
COLOR="RED"
>array_ptr_alloca_tsz</FONT
> is the
same as <FONT
COLOR="RED"
>alloca</FONT
> dynamically but it is given a type that
is often more convenient to use:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4283"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
array_ptr_alloca_tsz
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>dummy<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">void</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">dummy</span></span> <span class="keyword">|</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> tsz<span class="keyword">:</span> <span class="staexp">sizeof_t</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">array</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">dummy</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


As an example, the function template <FONT
COLOR="RED"
>mergeSort</FONT
> implemented
above can also be implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4286"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
mergeSort
  <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> tsz <span class="keyword">=</span> sizeof&lt;<span class="staexp">a</span><span class="keyword">&gt;</span></span>
  <span class="keyword">var</span> dummy<span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="prfexp"><span class="keyword">prval</span> pf <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>dummy</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
    <span class="prfexp">pfat</span><span class="keyword">,</span> <span class="prfexp">fpfat</span> <span class="keyword">|</span> p
  <span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloca_tsz<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> n<span class="keyword">,</span> tsz<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> msort1&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>dummy := fpfat <span class="keyword">(</span>pfat<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [mergeSort]</span>
</p></PRE
><P
></P
></DIV
>


where the array used as a scratch area during merge-sort is allocated on
the call-stack of <FONT
COLOR="RED"
>mergeSort</FONT
>. While this implementation of
<FONT
COLOR="RED"
>mergeSort</FONT
> may seem interesting, it is actually inferior to the
previous implementation as calling <FONT
COLOR="RED"
>alloca</FONT
> to allocate a large
chunk of memory can readily lead to a crash for which the cause is often
very difficult to determine. In general, choosing <FONT
COLOR="RED"
>alloca</FONT
> over
<FONT
COLOR="RED"
>malloc</FONT
> is difficult to justify, and any call to the former
should be scrutinized.

</P
><P
>&#13;The entire implementation of merge-sort on arrays plus some testing code
is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/mergeSort.dats"
TARGET="_top"
>on-line</A
>.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="array-based-circular-buffers"
>Example: Array-Based Circular Buffers</A
></H2
><P
>&#13;Array-based circular buffers are of common use in practice. For instance,
in a typical client/server model, a circular buffer can be employed to hold
requests issued by multiple clients that are then processed by the server
according to the first-in-first-out (FIFO) policy. In a case where each
request needs to be given a priority (chosen from a fixed set), a circular
buffer can be created for each priority to hold requests of that particular
priority.
</P
><P
>&#13;Let us declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4299"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">absvtype</span>
cbufObj <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> m<span class="keyword">:</span>int<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
</p></PRE
><P
></P
></DIV
>


Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype <FONT
COLOR="RED"
>cbufObj(VT, M, N)</FONT
> is for a given
buffer of maximal capacity M that currently holds N elements of the type
VT.

</P
><P
>&#13;Some properties on the parameters of <FONT
COLOR="RED"
>cbufObj</FONT
> can be captured
by introducing the following proof function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4304"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span>
lemma_cbufObj_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m&gt;=n<span class="keyword">;</span> n&gt;=0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4306"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_get_cap
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_get_size
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;While it is straightforward to use <FONT
COLOR="RED"
>cbufObj_get_cap</FONT
> and
<FONT
COLOR="RED"
>cbufObj_get_size</FONT
> to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4311"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_is_empty
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_is_full
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">m</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The functions for creating and destroying circular buffers are named
<FONT
COLOR="RED"
>cbufObj_new</FONT
> and <FONT
COLOR="RED"
>cbufObj_free</FONT
>, respectively:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4316"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_new
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> cbufObj_free
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4318"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
cbufObj_clear
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [cbufObj_clear]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4321"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_insert
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [cbufObj_insert]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
cbufObj_remove
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">cbufObj</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/circbuf.sats"
TARGET="_top"
>circbuf.sats</A
>
containing the entirety of the interface for functions creating, destroying
and manipulating circular buffers.
</P
><P
>&#13;There are many simple and practical ways to implement the abstract type
<FONT
COLOR="RED"
>cbufObj</FONT
> and the functions declared in
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/circbuf.sats"
TARGET="_top"
>circbuf.sats</A
>.  In the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/circbuf.dats"
TARGET="_top"
>circbuf.dats</A
>, I give an
implementation that employs four pointers p_beg, p_end, p_frst and p_last
to represent a circular buffer: p_beg and p_end are the starting and
finishing addresses of the underline array, respectively, and p_frst and
p_last are the starting addresses of the occupied and unoccupied segments
(in the array), respectively. What is special about this implementation is
its employing a style of programming that deliberately eschews the need for
proof construction. While code written in this style is not guaranteed to
be type-safe, the style can nonetheless be of great practical value in a
setting where constructing formal proofs is deemed too costly a requirement
to be fully fulfilled. Anyone who tries to give a type-safe implementation
for the functions declared in <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/circbuf.sats"
TARGET="_top"
>circbuf.sats</A
> should likely find some genuine appreciation for this
point.

</P
><P
>&#13;In the file <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/circbuf2.dats"
TARGET="_top"
>circbuf2.dats</A
>, I
give another implementation in which a circular buffer is represented as a
pointer p_beg plus three integers m, n and f: p_beg points to the starting
location of the underline array, m is the size of the array (that is, the
capacity of the buffer), n is the number of elements currently stored in
the buffer and f is the total number of elements that have so far been
removed from the buffer. Again, proof construction is delibrately eschewed
in this implementation.

</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="locking-and-unlocking"
>Locking and Unlocking</A
></H2
><P
>&#13;In concurrent programming, the issue of safely locking and unlocking
shared resources is both essential and challenging. I am to demonstrate
in this section concretely and convincingly that linear types can be used
with great effectiveness to address this issue.

</P
><P
>&#13;Let us first introduce a linear abstract type <FONT
COLOR="RED"
>shared</FONT
>
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4337"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">absvtype</span> shared<span class="keyword">(</span>a<span class="keyword">:</span>vtype<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
</p></PRE
><P
></P
></DIV
>


Given a viewtype VT (for some resources), a value of the type
<FONT
COLOR="RED"
>shared(VT)</FONT
> is essentially a boxed record containing a resource
of the type VT plus a lock (or several) of some kind. The following
function <FONT
COLOR="RED"
>shared_make</FONT
> is called to turn a resource into a shared
resource:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4341"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> shared_make<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vtype<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>  
</p></PRE
><P
></P
></DIV
>


Notice that the type <FONT
COLOR="RED"
>shared(VT)</FONT
> itself is linear. In terms of
implementation, there is usually a reference count inside a linear shared
resource that is protected by a spin-lock. The functions
<FONT
COLOR="RED"
>shared_ref</FONT
> and <FONT
COLOR="RED"
>shared_unref</FONT
> are for increasing and
descreasing the reference count inside a shared resource:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4346"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span> shared_ref<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vtype<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> shared_unref<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vtype<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


If the reference count of a shared resource is 1, then calling
<FONT
COLOR="RED"
>shared_unref</FONT
> on the shared resource frees the memory used in
its representation and then returns the resource stored inside it.

</P
><P
>&#13;The function <FONT
COLOR="RED"
>shared_lock</FONT
> acquires the resource from a
given shared resource and the function <FONT
COLOR="RED"
>shared_unlock</FONT
> does
the opposite:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4352"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absview</span> locked_v</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> shared_lock<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vtype<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">locked_v</span> <span class="keyword">|</span> <span class="staexp">a</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> shared_unlock<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vtype<span class="keyword">}</span></span><span class="keyword">(</span><span class="prfexp"><span class="staexp">locked_v</span></span> <span class="keyword">|</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">shared</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that the abstract view <FONT
COLOR="RED"
>locked_v</FONT
> is introduced for linear
proofs that are meant to remind the programmer that a shared resoure needs
to be released after it is acquired.

</P
><P
>&#13;As can be expected, a shared resource can be implemented as a boxed tuple
consisting of a spin-lock, a reference count and a pointer (referring to
the stored resource):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4356"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datavtype</span>
<span class="staexp">shared_ <span class="keyword">(</span>a<span class="keyword">:</span>vtype<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="dynexp">SHARED <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">spin1_vt</span><span class="comment">(*lock*)</span><span class="keyword">,</span> <span class="staexp">int</span><span class="comment">(*count*)</span><span class="keyword">,</span> <span class="staexp">ptr</span><span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">assume</span> shared <span class="keyword">=</span> shared_</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that the type <FONT
COLOR="RED"
>spin1_vt</FONT
> is for linear spin-locks. The
function <FONT
COLOR="RED"
>shared_ref</FONT
> is implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4360"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
shared_ref
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>sh<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SHARED
  <span class="keyword">(</span>spin<span class="keyword">,</span> count<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> sh</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
spin <span class="keyword">=</span> <span class="comment">// for temp. use</span>
  unsafe_spin_vt2t<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
<span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_lock<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> c0 <span class="keyword">=</span> count</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> count := c0 + <span class="dynexp">1</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_unlock<span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> spin<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span>sh</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>shared<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>sh<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [shared_ref]</span>
</p></PRE
><P
></P
></DIV
>


Clearly, the implementation makes use of several unsafe casts.  An
implementation without such casts would be highly involved even if it could
be done.  The spin-lock must be acquired before the binding between
<FONT
COLOR="RED"
>c0</FONT
> and the integer stored in <FONT
COLOR="RED"
>count</FONT
> is formed for
otherwise a race condition can appear. The function <FONT
COLOR="RED"
>shared_unref</FONT
>
is implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4365"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
shared_unref
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>sh<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SHARED
  <span class="keyword">(</span>spin<span class="keyword">,</span> count<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> sh</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
spin <span class="keyword">=</span> <span class="comment">// for temp. use</span>
  unsafe_spin_vt2t<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
<span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_lock<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> c0 <span class="keyword">=</span> count</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> count := c0 - <span class="dynexp">1</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_unlock<span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> spin<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span>sh</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
c0 &lt;= <span class="dynexp">1</span>
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">~</span>SHARED<span class="keyword">(</span>spin<span class="keyword">,</span> _<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> sh</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*freed*)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_vt_destroy<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="keyword">in</span>
  Some_vt<span class="keyword">(</span>$UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cast2void<span class="keyword">(</span>sh<span class="keyword">)</span></span> <span class="keyword">in</span> None_vt<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [shared_unref]</span>
</p></PRE
><P
></P
></DIV
>


In the case where the reference count is 1,
then the shared resource is freed, the spin-lock in it
is destroyed, and the resource in it is returned.

</P
><P
>&#13;The functions
<FONT
COLOR="RED"
>shared_lock</FONT
>
and
<FONT
COLOR="RED"
>shared_unlock</FONT
>
are implemented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4370"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
shared_lock
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>sh<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SHARED<span class="keyword">(</span>spin<span class="keyword">,</span> _<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> sh</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
spin <span class="keyword">=</span>
  unsafe_spin_vt2t<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
<span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> spin_lock<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> x0 <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span>sh</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">(</span><span class="prfexp">$UN<span class="keyword">.</span>castview0<span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="keyword">|</span> x0<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [shared_lock]</span>
</p></PRE
><P
></P
></DIV
>


<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4372"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
shared_unlock
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> sh<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SHARED<span class="keyword">(</span>spin<span class="keyword">,</span> _<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> sh</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
spin <span class="keyword">=</span>
  unsafe_spin_vt2t<span class="keyword">(</span>spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> x := $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>ptr<span class="keyword">}</span></span><span class="keyword">(</span>x0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  spin_unlock<span class="keyword">(</span><span class="prfexp">$UN<span class="keyword">.</span>castview0<span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="keyword">|</span> spin<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span>sh</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [shared_unlock]</span>
</p></PRE
><P
></P
></DIV
>


In the case of <FONT
COLOR="RED"
>shared_lock</FONT
>, please notice that the content
stored in the variable <FONT
COLOR="RED"
>x</FONT
> is read out after the spin-lock is
acquired. This is crucial for otherwise a race condition can readily
appear. In the case of <FONT
COLOR="RED"
>shared_unlock</FONT
>, the content of the
variable <FONT
COLOR="RED"
>x</FONT
> is updated before the acquired spin-lock is
released.
</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/shared_vt.dats"
TARGET="_top"
>shared_vt.dats</A
>
containing the entirety of the code presented in this section. In addition,
the file also contains an implementation of three threads that move in
locked steps: thread 0 moves; thread 1 moves; thread 2 moves; thread 0
moves; thread 1 moves; thread 2 moves; etc.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="linear-channels-for-async-ipc"
>Linear Channels for Asynchronous IPC</A
></H2
><P
>&#13;In this section, I will present an implementation of
linear channels to support asynchronous communication between threads. This
is also a very fitting occasion for me to advocate what I often refer to as
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>programmer-centric</I
></SPAN
> program verification.
</P
><P
>&#13;A communication channel between threads is essentially
a queue wrapped in some kind of protection mechanism needed for guarding
against race conditions.  Assume that a queue is of a fixed capacity, that
is, the capacity of the queue is fixed after its creation. If the queue is
full, then inserting an element into it results in a failure.  If the queue
is empty, then removing an element from it results in a failure. In order
to prevent inserting into a full queue or removing from an empty queue, I
could first introduce a linear abstract type for queues as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4385"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">absvtype</span>
queue_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> int<span class="comment">(*m*)</span><span class="keyword">,</span> int<span class="comment">(*n*)</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span> <span class="staexp">queue<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">vt@ype</span></span><span class="keyword">,</span><span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">queue_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where the type <FONT
COLOR="RED"
>queue(VT,M,N)</FONT
> is for a queue of capacity M that
currently contains N elements of type VT. Then the functions for inserting
into and removing from a queue are expected to be given the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4388"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_insert
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> m <span class="keyword">&gt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_remove
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The presented abstract type <FONT
COLOR="RED"
>queue</FONT
> can indeed work very well for
the task of implementing linear channels. However, I will not continue with
this version of <FONT
COLOR="RED"
>queue</FONT
> further for I intend to present a style of
program verification that is less rigorous but far more flexible.

</P
><P
>&#13;Following is another version of abstract type <FONT
COLOR="RED"
>queue</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4394"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
queue_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> int<span class="comment">(*id*)</span><span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">queue<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">id<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">queue_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span> <span class="staexp">queue<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>id<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Given a viewtype VT and an integer ID, <FONT
COLOR="RED"
>queue(VT,ID)</FONT
> is for a
queue containing elements of the type VT that can be uniquely identified
with the integer ID. So one may think of ID as some form of stamp. The
following declared function <FONT
COLOR="RED"
>queue_isnil</FONT
> is for testing whether
a given queue is empty:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4398"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absprop</span> ISNIL<span class="keyword">(</span>id<span class="keyword">:</span>int<span class="keyword">,</span> b<span class="keyword">:</span>bool<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_isnil<span class="staexp"><span class="keyword">{</span>id<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">ISNIL</span><span class="keyword">(</span><span class="staexp">id</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Given an integer ID, a proof of the prop <FONT
COLOR="RED"
>ISNIL(ID,true)</FONT
>
(<FONT
COLOR="RED"
>ISNIL(ID,false)</FONT
>) means that the queue uniquely identified by
ID is (not) empty. Similarly, the following declared function
<FONT
COLOR="RED"
>queue_isful</FONT
> is for testing whether a given queue is full:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4403"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="staexp"><span class="keyword">absprop</span> ISFUL<span class="keyword">(</span>id<span class="keyword">:</span>int<span class="keyword">,</span> b<span class="keyword">:</span>bool<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_isful<span class="staexp"><span class="keyword">{</span>id<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">ISFUL</span><span class="keyword">(</span><span class="staexp">id</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Given an integer ID, a proof of the prop <FONT
COLOR="RED"
>ISFUL(ID,true)</FONT
>
(<FONT
COLOR="RED"
>ISFUL(ID,false)</FONT
>) means that the queue uniquely identified by
ID is (not) full.

</P
><P
>&#13;The functions <FONT
COLOR="RED"
>queue_insert</FONT
> and <FONT
COLOR="RED"
>queue_remove</FONT
>
for inserting into and removing from a given queue can now be given the
following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4410"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_insert
  <span class="staexp"><span class="keyword">{</span>id<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">ISFUL</span><span class="keyword">(</span><span class="staexp">id</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span></span>
<span class="keyword">|</span> xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id2</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>id2<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
queue_remove
  <span class="staexp"><span class="keyword">{</span>id<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">ISNIL</span><span class="keyword">(</span><span class="staexp">id</span><span class="keyword">,</span> <span class="staexp">false</span><span class="keyword">)</span></span> <span class="keyword">|</span> xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">id2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>id2<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">a</span></span> <span class="comment">// end-of-fun</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that either inserting an element into a queue or removing an element
from a queue assigns a new stamp to the queue.  This is essential for
interpreting <FONT
COLOR="RED"
>ISNIL</FONT
> and <FONT
COLOR="RED"
>ISFUL</FONT
> in the manner presented
above.

</P
><P
>&#13;In order to call <FONT
COLOR="RED"
>queue_insert</FONT
> on a given queue, one needs to
have a proof attesting to the queue being not full. Such a proof is
obtained if calling <FONT
COLOR="RED"
>queue_isful</FONT
> on the queue returns false.
Similarly, in order to call <FONT
COLOR="RED"
>queue_remove</FONT
> on a given queue,
one can first call <FONT
COLOR="RED"
>queue_isnil</FONT
> on the queue to obtain a proof
attesting to the queue being not empty.
</P
><P
>&#13;What is really of concern here is not to actually verify that
<FONT
COLOR="RED"
>queue_isnil</FONT
> and <FONT
COLOR="RED"
>queue_isful</FONT
> have the interface
assigned to them. Instead, the focus is on ensuring that
<FONT
COLOR="RED"
>queue_insert</FONT
> is never applied to a full queue and
<FONT
COLOR="RED"
>queue_remove</FONT
> is never applied to an empty queue under the
assumption that <FONT
COLOR="RED"
>queue_isnil</FONT
> and <FONT
COLOR="RED"
>queue_isful</FONT
> have
the assigned interface. I refer to this form of program verification as
being <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>programmer-centric</I
></SPAN
> because its correctness is not
formally established in an objective manner. I myself find that
programmer-centric program verification is very flexible and effective in
practice.  If we believe that constructing informal mathematical proofs can
help one check whether the proven statements are valid, then it is only
natural to believe that programmer-centric program verification can also
help one check whether verified programs are correct.
</P
><P
>&#13;Let us now start to implement linear channels for asynchronous
communication between threads. First, let us declare a linear abstract
type <FONT
COLOR="RED"
>channel</FONT
> as follows:


<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4429"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="staexp"><span class="keyword">absvtype</span> channel_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="keyword">vtypedef</span> <span class="staexp">channel<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">channel_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The function for inserting an element into a channel is given the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4431"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> channel_insert <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">channel</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


The caller of <FONT
COLOR="RED"
>channel_insert</FONT
> is blocked if the channel is full.
Similarly, the function for removing an element from a channel is given the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4434"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> channel_remove <span class="keyword">(</span>chan<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">channel</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


The caller of <FONT
COLOR="RED"
>channel_remove</FONT
> is blocked if the channel is empty.

</P
><P
>&#13;Let a channel be represented as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4438"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datavtype</span>
<span class="staexp">channel_ <span class="keyword">=</span>
<span class="dynexp"><span class="staexp"><span class="keyword">{</span>
l0<span class="keyword">,</span>l1<span class="keyword">,</span>l2<span class="keyword">,</span>l3<span class="keyword">:</span>agz
<span class="keyword">}</span></span> CHANNEL <span class="keyword">of</span>
<span class="keyword">@{</span>
  <span class="stalab">cap</span><span class="keyword">=</span><span class="staexp">intGt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">spin</span><span class="keyword">=</span><span class="staexp">spin_vt</span><span class="keyword">(</span><span class="staexp">l0</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">rfcnt</span><span class="keyword">=</span><span class="staexp">intGt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">mutex</span><span class="keyword">=</span><span class="staexp">mutex_vt</span><span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">CVisnil</span><span class="keyword">=</span><span class="staexp">condvar_vt</span><span class="keyword">(</span><span class="staexp">l2</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">CVisful</span><span class="keyword">=</span><span class="staexp">condvar_vt</span><span class="keyword">(</span><span class="staexp">l3</span><span class="keyword">)</span>
<span class="keyword">,</span> <span class="stalab">queue</span><span class="keyword">=</span><span class="staexp">ptr</span> <span class="comment">// deqarray</span>
<span class="keyword">}</span></span></span> <span class="comment">(* end of [channel] *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">assume</span> channel_vtype<span class="keyword">(</span>a<span class="keyword">:</span>vt0p<span class="keyword">)</span> <span class="keyword">=</span> channel_</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


There are 7 fields in the record representing a channel; the
<FONT
COLOR="RED"
>cap</FONT
> field stores an integer indicating the (fixed) capacity of
the channel; the <FONT
COLOR="RED"
>spin</FONT
> field stores a spin-lock for protecting
the reference count in the field of the name <FONT
COLOR="RED"
>rfcnt</FONT
>; the
<FONT
COLOR="RED"
>mutex</FONT
> field stores a mutex for protecting the queue in the
field of the name <FONT
COLOR="RED"
>queue</FONT
>; the field <FONT
COLOR="RED"
>CVisnil</FONT
> stores a
conditional variable for the situation where a caller (holding the mutex)
wants to wait for the condition that the queue becomes not empty; the
field <FONT
COLOR="RED"
>CVisful</FONT
> stores a conditional variable for the situation
where a caller (holding the mutex) wants to wait for the condition that the
queue becomes not full.

</P
><P
>&#13;The function
<FONT
COLOR="RED"
>channel_insert</FONT
> is given the following implementation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4449"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
channel_insert
  <span class="keyword">(</span>chan<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span>CHANNEL
  <span class="staexp"><span class="keyword">{</span>l0<span class="keyword">,</span>l1<span class="keyword">,</span>l2<span class="keyword">,</span>l3<span class="keyword">}</span></span><span class="keyword">(</span>ch<span class="keyword">)</span> <span class="keyword">=</span> chan</span>
<span class="dynexp"><span class="keyword">val</span> mutex <span class="keyword">=</span> unsafe_mutex_vt2t<span class="keyword">(</span>ch<span class="dynexp"><span class="keyword">.</span>mutex</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfmut</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> mutex_lock <span class="keyword">(</span>mutex<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>queue<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">(</span><span class="prfexp">pfmut</span> <span class="keyword">|</span> ch<span class="dynexp"><span class="keyword">.</span>queue</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> channel_insert2&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>chan<span class="keyword">,</span> xs<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> pfmut <span class="keyword">=</span> $UN<span class="keyword">.</span>castview0<span class="staexp"><span class="keyword">{</span>locked_v<span class="keyword">(</span>l1<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> mutex_unlock <span class="keyword">(</span><span class="prfexp">pfmut</span> <span class="keyword">|</span> mutex<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [channel_insert]</span>
</p></PRE
><P
></P
></DIV
>


where
the auxiliary function <FONT
COLOR="RED"
>channel_insert2</FONT
> is given
the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4452"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
channel_insert2
  <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">channel</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">queue</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Please note that <FONT
COLOR="RED"
>channel_insert2</FONT
> is called when
the caller is holding the mutex inside the channel. Following
is an implementation for <FONT
COLOR="RED"
>channel_insert2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4456"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
channel_insert2
  <span class="keyword">(</span>chan<span class="keyword">,</span> xs<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span>CHANNEL
  <span class="staexp"><span class="keyword">{</span>l0<span class="keyword">,</span>l1<span class="keyword">,</span>l2<span class="keyword">,</span>l3<span class="keyword">}</span></span><span class="keyword">(</span>ch<span class="keyword">)</span> <span class="keyword">=</span> chan</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> isful<span class="keyword">)</span> <span class="keyword">=</span> queue_isful <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
isful
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span>
  <span class="keyword">(</span>pfmut<span class="keyword">,</span> fpf<span class="keyword">)</span> <span class="keyword">=</span>
  __assert <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="keyword">extern</span>
    <span class="prfexp"><span class="keyword">praxi</span> __assert <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">vtakeout0</span><span class="keyword">(</span><span class="staexp">locked_v</span><span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">}</span></span>
  <span class="dynexp"><span class="keyword">val</span> mutex <span class="keyword">=</span> unsafe_mutex_vt2t<span class="keyword">(</span>ch<span class="dynexp"><span class="keyword">.</span>mutex</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> CVisful <span class="keyword">=</span> unsafe_condvar_vt2t<span class="keyword">(</span>ch<span class="dynexp"><span class="keyword">.</span>CVisful</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> condvar_wait <span class="keyword">(</span><span class="prfexp">pfmut</span> <span class="keyword">|</span> CVisful<span class="keyword">,</span> mutex<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pfmut<span class="keyword">)</span></span>
<span class="keyword">in</span>
  channel_insert2 <span class="keyword">(</span>chan<span class="keyword">,</span> xs<span class="keyword">,</span> x0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> queue_isnil <span class="keyword">(</span>xs<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> queue_insert <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> xs<span class="keyword">,</span> x0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> isnil<span class="dynexp"><span class="keyword">.1</span></span>
    <span class="keyword">then</span> condvar_broadcast<span class="keyword">(</span>unsafe_condvar_vt2t<span class="keyword">(</span>ch<span class="dynexp"><span class="keyword">.</span>CVisnil</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="comment">// end of [if]</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [channel_insert2]</span>
</p></PRE
><P
></P
></DIV
>


The logic behind <FONT
COLOR="RED"
>channel_insert2</FONT
> can be explained as follows.
If the queue in the given channel is full, the caller calls
<FONT
COLOR="RED"
>condvar_wait</FONT
> to release the mutex it holds and then wait on the
conditional variable stored in the field <FONT
COLOR="RED"
>CVisful</FONT
> of the
channel; after the caller regains the mutex after being awoken by a signal
sent to the conditioanl variable, it calls <FONT
COLOR="RED"
>channel_insert2</FONT
>
recursively. If the queue in the given channel is not full, then the caller
insert a given element into the queue stored in the field <FONT
COLOR="RED"
>queue</FONT
>
and then returns. Note that <FONT
COLOR="RED"
>channel_insert2</FONT
> is a tail-recursive
function that essentially corresponds to a standard while-loop often
appearing in C code for handling the wait on a conditional variable.
</P
><P
>&#13;By following the above implementation for <FONT
COLOR="RED"
>channel_insert</FONT
> (and
<FONT
COLOR="RED"
>channel_insert2</FONT
>), it should be pretty straightforward for one
to figure out an implementation for <FONT
COLOR="RED"
>channel_remove</FONT
>. I leave it
as an exercise.

</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/channel_vt.dats"
TARGET="_top"
>channel_vt.dats</A
>
containing the entirety of the code presented in this section plus some
code for testing.
</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="programming-with-function-templates"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
>V. Programming with Function Templates</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>17. <A
HREF="#from-genericity-to-late-binding"
>From Genericity to Late-Binding</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="from-genericity-to-late-binding"
></A
>Chapter 17. From Genericity to Late-Binding</H1
><P
>&#13;The support for function templates in ATS is deeply ingrained in the design
and implementation of ATS. Primarily, function templates are meant to
provide a general approach to code reuse in ATS that is highly flexible (in
terms of applicability) while incurring minimal run-time overhead if
any. Both ATSPRE (that is, ATSLIB/prelude) and ATSLIB/libats are nearly
entirely template-based, and the templates in these libraries are for use
by <B
CLASS="command"
>atsopt</B
> to generate C code that implements template
instances in the ATS source being compiled. The library files of ATS for
linking (<TT
CLASS="filename"
>libatslib.a</TT
> and <TT
CLASS="filename"
>libatslib.so</TT
>) are minimal, and
they are not even necessary for compiling ATS source into executable binaries.

</P
><P
>&#13;The code employed for illustration in this chapter plus some additional
code for testing is available <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="genericity-of-template-implementations"
>Genericity of Template Implementations</A
></H2
><P
>&#13;As is briefly explained in Part I of the book, function templates can be
seen as a natural solution to the problem of supporting parametric
polymorphism in the presence of native unboxed data. However, function
templates can do much more than just supporting parametric polymorphism.
Let <FONT
COLOR="RED"
>myprint</FONT
> be a function template of the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4484"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> myprint <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Given a value, <FONT
COLOR="RED"
>myprint</FONT
> is supposed to print out some kind of
representation for this value. For example, we can implement
<FONT
COLOR="RED"
>myprint</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4488"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span> myprint <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_string <span class="dynstr">"?"</span></span>
</p></PRE
><P
></P
></DIV
>


This implementation of <FONT
COLOR="RED"
>myprint</FONT
> is often referred to as a
(fully) generic template implementation due to no restriction being imposed
on the template parameter. Following is another way to code the same
implementation:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4491"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> myprint&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_string <span class="dynstr">"?"</span></span>
</p></PRE
><P
></P
></DIV
>


Clearly, the above generic implementation of <FONT
COLOR="RED"
>myprint</FONT
> is
unsatisfactory as it outputs no specific information on a given value.  We
may want to implement <FONT
COLOR="RED"
>myprint</FONT
> as follows for only values of the
type <FONT
COLOR="RED"
>int</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4496"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span> myprint&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_int <span class="keyword">(</span>x<span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>print_int</FONT
> is called to print out a given integer. This
implementation of <FONT
COLOR="RED"
>myprint</FONT
> is often referred to as a specific
template implementation due to the template parameter being bound to a
specific type (that is, <FONT
COLOR="RED"
>int</FONT
> in this case). The following code
implements <FONT
COLOR="RED"
>myprint</FONT
> for list-values (that is, values of type
<FONT
COLOR="RED"
>List(T)</FONT
> for some type T):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4503"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
myprint&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>myprint&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">;</span> myprint&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


This implementation of <FONT
COLOR="RED"
>myprint</FONT
> is often referred to as a
partially generic template implementation. In order for an instance of
<FONT
COLOR="RED"
>myprint</FONT
> to use this implementation, the template parameter for
the instance must be of the form <FONT
COLOR="RED"
>List(T)</FONT
> for some type T.
As an example, the following code calls an instance of <FONT
COLOR="RED"
>myprint</FONT
>
to print out a list of two integer lists:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4509"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">(*
** The output is "0123401234"
*)</span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span><span class="dynexp">1</span><span class="keyword">,</span><span class="dynexp">2</span><span class="keyword">,</span><span class="dynexp">3</span><span class="keyword">,</span><span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> yss <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">List</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">}</span><span class="keyword">(</span>ys<span class="keyword">,</span> ys<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> myprint&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">List</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>yss<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Implementations of a function template can be ordered according to an
obvious partial ordering referred to as genericity ordering: The genericity
of one implementation is less than or equal to that of another one if the
former implementation is an instance of the latter one. Please note that
the first-fit (instead of best-fit) strategy is employed to locate the
template implementation needed for compiling a given template instance.
More specifically, locating the template implementation for a particular
template instance follows the standard principle of lexical scoping to
search for the first one that is available for use.

</P
><P
>&#13;In practice, there is quite a bit of subtlety in locating a template
implementation for a template instance. Let <FONT
COLOR="RED"
>myprint2</FONT
> be a
function template of the following interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4514"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> myprint2 <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
</p></PRE
><P
></P
></DIV
>


Following is a partially generic implementation of <FONT
COLOR="RED"
>myprint2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4517"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
myprint2&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>myprint&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">;</span> <span class="dynexp">1</span> + myprint2 <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


This template implementation actually behaves very differently from what
one might have expected. Note that the template parameter of the called
instance of <FONT
COLOR="RED"
>myprint2</FONT
> in the body of the implementation is
synthesized to be a type of the form <FONT
COLOR="RED"
>list(a, N)</FONT
> for some static
term N (of the sort <FONT
COLOR="RED"
>int</FONT
>). As this form can never match
<FONT
COLOR="RED"
>List(T)</FONT
> for any type T, the called instance of the template
<FONT
COLOR="RED"
>myprint2</FONT
> cannot be compiled according to the given template
implementation of <FONT
COLOR="RED"
>myprint2</FONT
>. This issue can be readily fixed by
passing explicity the type <FONT
COLOR="RED"
>List(a)</FONT
> (as a template parameter) to
the called instance of <FONT
COLOR="RED"
>myprint2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4527"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
myprint2&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>myprint&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">;</span> <span class="dynexp">1</span> + myprint2&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The instance <FONT
COLOR="RED"
>myprint2&#60;List(a)&#62;</FONT
> in this example is often
referred to as a recursive instance. In general, it is a good programming
practice to <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>avoid</I
></SPAN
> using recursive instances. For example, the
following equivalent implementation of <FONT
COLOR="RED"
>myprint2</FONT
> makes no use of
recursive instances:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4532"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
myprint2&lt;<span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
aux
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="dynexp">0</span>
<span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>myprint&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">;</span> <span class="dynexp">1</span> + aux<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [myprint2&lt;List(a)&gt;]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/myprint.dats"
TARGET="_top"
>myprint.dats</A
> containing the
entirety of the code presented in this section plus some testing code.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="generic-operations-on-numbers"
>Example: Generic Operations on Numbers</A
></H2
><P
>&#13;There are many types of numbers in ATS. With function templates, we can
greatly enhance code sharing in numerical computation. For example, we can
give a generic implementation of matrix multiplication of the following
interface:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4539"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
matrix_mul
  <span class="staexp"><span class="keyword">{</span>p<span class="keyword">,</span>q<span class="keyword">,</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  p<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">,</span> q<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">q</span><span class="keyword">)</span>
<span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">r</span><span class="keyword">)</span>
<span class="keyword">,</span> A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">matrix</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">,</span> <span class="staexp">q</span><span class="keyword">)</span>
<span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">matrix</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">q</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span>
<span class="keyword">,</span> C<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">matrix</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">matrix</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [matrix_mul]</span>
</p></PRE
><P
></P
></DIV
>


and then use it to immediately obtain implementations of matrix
multiplication for matrices of integers, matrices of floating point
numbers, matrices of floating point complex numbers, etc. This approach is
clearly far superior to relying on error-prone macros in C.

</P
><P
>&#13;Let us take a look at a concrete example involving generic operations on
numbers. The following code gives a standard implementation of the
factorial function:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4542"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> fact<span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
fact<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> n * fact<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1</span></span>
<span class="comment">// end of [fact]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


When applied to 100, <FONT
COLOR="RED"
>fact</FONT
> is likely to return 0. This can be
easily understood as the true value of the factorial of 100 is a multiple
of 2<SUP
>32</SUP
> and the multiplication operation on integers of the type
<FONT
COLOR="RED"
>int</FONT
> is probably modulo 2<SUP
>32</SUP
>. Suppose that we want to
replace this multiplication operation with the one on floating point
numbers of double precision. This can be done by implementing a slight variant
of <FONT
COLOR="RED"
>fact</FONT
> as follows

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4549"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> factd<span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">double</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
factd<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> n * factd<span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="dynexp">1.0</span></span>
<span class="comment">// end of [factd]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


When applied to 100, <FONT
COLOR="RED"
>factd</FONT
> should return a large floating point
number. Obviously, there is a great deal of code duplication between the
implementations of <FONT
COLOR="RED"
>fact</FONT
> and <FONT
COLOR="RED"
>factd</FONT
>. We can readily
eliminate this duplication by introducing a generic implementation of the
factorial function as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4554"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> gfact<span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
gfact<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span>
<span class="keyword">then</span> gmul_int_val&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>n<span class="keyword">,</span> gfact&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">else</span> gnumber_int&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [gfact] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


With a bit of help from the support for
overloading in ATS, we can rewrite <FONT
COLOR="RED"
>gfact</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4557"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
gfact<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> * <span class="keyword">with</span> gmul_int_val</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> n <span class="keyword">&gt;</span> <span class="dynexp">0</span>
<span class="keyword">then</span> n * gfact&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>n-<span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> gnumber_int&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [gfact] *)</span>
</p></PRE
><P
></P
></DIV
>


We can now implement <FONT
COLOR="RED"
>fact</FONT
> and <FONT
COLOR="RED"
>factd</FONT
>
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4561"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span> fact<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> gfact&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>n<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span> factd<span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> gfact&lt;<span class="staexp">double</span><span class="keyword">&gt;</span><span class="keyword">(</span>n<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


There is support in ATS based on the GNU multiple precision arithmetic
library (GMPLIB) for integers of unlimited precision. The following code
presents a way to compute the true value of the factorial of 100:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4563"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
HX_INTINF_targetloc
"$PATSHOME/contrib/atscntrb-hx-intinf"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span> _<span class="comment">(*T*)</span> <span class="keyword">=</span>
"{$HX_INTINF}/DATS/intinf_t.dats"
<span class="keyword">staload</span> _<span class="comment">(*VT*)</span> <span class="keyword">=</span>
"{$HX_INTINF}/DATS/intinf_vt.dats"
<span class="comment">//</span>
<span class="keyword">staload</span>
GINTINF <span class="keyword">=</span>
"{$HX_INTINF}/DATS/gintinf_t.dats"
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">intinf <span class="keyword">=</span> <span class="staexp">$GINTINF<span class="keyword">.</span>intinf</span></span>
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> $GINTINF<span class="keyword">.</span>print_intinf</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"gfact&lt;intinf&gt;(100) = "</span><span class="keyword">,</span> gfact&lt;<span class="staexp">intinf</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">100</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


I only list some leading digits of the result:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4565"
></A
><PRE
CLASS="programlisting"
>gfact&#60;intinf&#62;(100) = 933262154439441526816992388562667[...omitted...]
</PRE
><P
></P
></DIV
>

</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/gnumber.dats"
TARGET="_top"
>gnumber.dats</A
> containing the
entirety of the code presented in this section plus some testing code.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="templates-as-a-special-form-of-functors"
>Templates as a Special Form of Functors</A
></H2
><P
>&#13;Many uses of higher-order functions can be readily replaced with function
templates in ATS.  In particular, higher-order functions are often
implemented in ATS based on the corresponding function templates.
Let us start with a concrete example. Following is a standard
implementation of list mapping as a higher-order function (template):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4572"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_map_fun<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> fopr<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list_map_fun <span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
aux<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_cons<span class="keyword">(</span>fopr<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> aux<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  aux<span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_map_fun]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Given a list of cerntain length and a function (which is envless),
<FONT
COLOR="RED"
>list_map_fun</FONT
> returns a linear list of the same
length. Unfortunately, <FONT
COLOR="RED"
>list_map_fun</FONT
> cannot be called on a list and
a closure-function. We certainly can implement a variant of
<FONT
COLOR="RED"
>list_map_fun</FONT
> of the following interface by essentially duplicating
the implementation of <FONT
COLOR="RED"
>list_map_fun</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4578"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_map_cloref<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> fopr<span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


While <FONT
COLOR="RED"
>list_map_cloref</FONT
> can be called on a list and a
closure-function, the closure-function that is formed at run-time to be
passed to a call to <FONT
COLOR="RED"
>list_map_cloref</FONT
> most likely becomes garbage
immediately after the call returns. Without garbage collection (GC), the
memory for storing the closure is leaked. We surely have many good reasons
for avoiding using a higher-order function like <FONT
COLOR="RED"
>list_map_cloref</FONT
>
when doing embedded programming in ATS.

</P
><P
>&#13;A proper way to implement list mapping (as I see it) is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4584"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_map<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> list_map$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">b</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list_map <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
aux<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_cons<span class="keyword">(</span>list_map$fopr&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> aux<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [aux] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  aux<span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_map]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The function template <FONT
COLOR="RED"
>list_map</FONT
> is given in a style that is
often referred to as being functorial: <FONT
COLOR="RED"
>list_map</FONT
> can be thought
of as a functor in Standard ML that applies to a module consisting of a
single function <FONT
COLOR="RED"
>list_map$fopr</FONT
>. In SML, each argument of a
functor, which itself is a module, needs to be constructed and then passed
to the functor explcitly. In ATS, the template implementation needed for
compiling a particular template instance is located through a search
procedure (that follows the standard principle of lexical scoping).

</P
><P
>&#13;With <FONT
COLOR="RED"
>list_map</FONT
>, we can implement <FONT
COLOR="RED"
>list_map_fun</FONT
>
as follows in a straightforward manner:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4592"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list_map_fun<span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span> list_map$fopr&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> fopr<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  list_map&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_map_fun]</span>
</p></PRE
><P
></P
></DIV
>


Please note that <FONT
COLOR="RED"
>list_map$fopr</FONT
> being implemented inside
the body of <FONT
COLOR="RED"
>list_map_fun</FONT
> allows the implementation to gain
direct access to the argument <FONT
COLOR="RED"
>fopr</FONT
> of
<FONT
COLOR="RED"
>list_map_fun</FONT
>. It is in this sense that templates in ATS
are often referred to as <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>embeddable</I
></SPAN
> templates as they can
be directly implemented in the bodies of functions.

We can implement <FONT
COLOR="RED"
>list_map_cloref</FONT
> similarly as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4600"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list_map_cloref<span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span> list_map$fopr&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> fopr<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  list_map&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_map_cloref]</span>
</p></PRE
><P
></P
></DIV
>


For those who are familiar with functors in SML, the implementation of
<FONT
COLOR="RED"
>list_map_fun</FONT
> and <FONT
COLOR="RED"
>list_map_cloref</FONT
> should clearly
remind them of functor application.
</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/list_map.dats"
TARGET="_top"
>list_map.dats</A
> containing the
entirety of the code presented in this section plus some testing code.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="template-for-loop-construction"
>Example: Templates for Loop Construction</A
></H2
><P
>&#13;Beginners in functional programming (FP) who have already acquired some
knowledge of imperative programming often ask about ways to construct
for-loops and while-loops in FP. A commonly given answer is that loop
constructs are unnecessary in FP as they can be readily replaced with
higher-order functions. Let us first see some thorny issues with this
answer.
</P
><P
>&#13;The following code in C implements a function that returns the sum
of the first n natural numbers when applied to a natural number n:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4610"
></A
><PRE
CLASS="programlisting"
>int
tally (int n) {
  int i, res;
  for (i = 0, res = 0; i &#60; n; i += 1) res += i;
  return res;
}
</PRE
><P
></P
></DIV
>


This function <FONT
COLOR="RED"
>tally</FONT
> can be given the following
equivalent implementation in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4613"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
tally
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> loop <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> loop <span class="keyword">(</span>i + <span class="dynexp">1</span><span class="keyword">,</span> res + i<span class="keyword">)</span> <span class="keyword">else</span> res</span>
<span class="keyword">}</span></span>
</p></PRE
><P
></P
></DIV
>


where the tail-recursive function <FONT
COLOR="RED"
>loop</FONT
> is just a translation
of the for-loop in C.

</P
><P
>&#13;When someone claims that loop constructs can be replaced with higher-order
functions, he or she probably means to construct loops with a function like
the following one:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4617"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
for_loop
<span class="keyword">(</span>
  count<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> limit<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> fwork<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span> count <span class="keyword">&lt;</span> limit
  <span class="keyword">then</span> <span class="keyword">(</span>fwork<span class="keyword">(</span>count<span class="keyword">)</span><span class="keyword">;</span> for_loop<span class="keyword">(</span>count+<span class="dynexp">1</span><span class="keyword">,</span> limit<span class="keyword">,</span> fwork<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [if]</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [for_loop] *)</span>
</p></PRE
><P
></P
></DIV
>


For example, the following function <FONT
COLOR="RED"
>tally2</FONT
> is directly based
on <FONT
COLOR="RED"
>for_loop</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4621"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
tally2
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> ref&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  for_loop <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>res := <span class="keyword">!</span>res + i<span class="keyword">)</span><span class="keyword">;</span> <span class="keyword">!</span>res
<span class="keyword">end</span></span> <span class="comment">// end of [tally2]</span>
</p></PRE
><P
></P
></DIV
>


While both <FONT
COLOR="RED"
>tally</FONT
> and <FONT
COLOR="RED"
>tally2</FONT
> return the same result
when applied to a given natural number, they behave very differently at
run-time. In particular, each call to <FONT
COLOR="RED"
>tally2</FONT
> creates a
(persistent) reference on heap for temporary use; the reference becomes
garbage immediately after the call returns. Compared to <FONT
COLOR="RED"
>tally</FONT
>,
<FONT
COLOR="RED"
>tally2</FONT
> is inefficient both time-wise and memory-wise.
</P
><P
>&#13;To eliminate the need for reference creation in <FONT
COLOR="RED"
>tally2</FONT
>, we
turn <FONT
COLOR="RED"
>for_loop</FONT
> into the following function template
<FONT
COLOR="RED"
>for_loop2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4632"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> for_loop2
<span class="keyword">(</span>
  count<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> limit<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> fwork<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
count <span class="keyword">&lt;</span> limit
<span class="keyword">then</span> <span class="keyword">(</span>
  fwork<span class="keyword">(</span>count<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">;</span> for_loop2&lt;<span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>count+<span class="dynexp">1</span><span class="keyword">,</span> limit<span class="keyword">,</span> env<span class="keyword">,</span> fwork<span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [for_loop2] *)</span>
</p></PRE
><P
></P
></DIV
>


We can further turn <FONT
COLOR="RED"
>tally2</FONT
> into the following <FONT
COLOR="RED"
>tally3</FONT
>
based on <FONT
COLOR="RED"
>for_loop2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4637"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
tally3
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="keyword">in</span>
  for_loop2&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> n<span class="keyword">,</span> res<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>i<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=&gt;</span> res := res + i<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span></span> <span class="comment">// end of [tally3]</span>
</p></PRE
><P
></P
></DIV
>


While <FONT
COLOR="RED"
>tally3</FONT
> improves upon <FONT
COLOR="RED"
>tally2</FONT
>, it is still
a bit unsatisfactory. Clearly, the closure function formed before
<FONT
COLOR="RED"
>tally3</FONT
> calls <FONT
COLOR="RED"
>for_loop2</FONT
> becomes garbage
immediately after the call returns. It is plausible to expect that an
optimizing C compiler (e.g., gcc and clang) can eliminate the need for
actual closure formation when it compiles the C code generated from
ATS source, but there is no guarantee. In order to have such a
guarantee, we can evolve <FONT
COLOR="RED"
>for_loop2</FONT
> into the following
function template <FONT
COLOR="RED"
>for_loop3:</FONT
>

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4645"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> for_loop3
<span class="keyword">(</span>
  count<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> limit<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
count <span class="keyword">&lt;</span> limit
<span class="keyword">then</span> <span class="keyword">(</span>
  for_loop3$fwork&lt;<span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>count<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">;</span> for_loop3&lt;<span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>count+<span class="dynexp">1</span><span class="keyword">,</span> limit<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [for_loop3] *)</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>for_loop3$fwork</FONT
> is given the interface below:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4648"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> for_loop3$fwork<span class="keyword">(</span>count<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</p></PRE
><P
></P
></DIV
>


Finally, we can turn <FONT
COLOR="RED"
>tally3</FONT
> into <FONT
COLOR="RED"
>tally4</FONT
>
as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4652"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fun</span>
tally4
<span class="keyword">(</span>
  n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
for_loop3$fwork&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>i<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> res := res + i</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  for_loop3&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> n<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span></span> <span class="comment">// end of [tally4]</span>
</p></PRE
><P
></P
></DIV
>


By inspecting the C code generated by <B
CLASS="command"
>atsopt</B
> from compiling
<FONT
COLOR="RED"
>tally4</FONT
>, we can see that the C code is essentially equivalent to
the implementation of <FONT
COLOR="RED"
>tally</FONT
> in C (given at the beginning of
this section).

</P
><P
>&#13;By now, the reader probably agrees with me if I say the statement should at
least be considered grossly inaccurate that claims loop constructs in FP
can be readily replaced with higher-order functions.  Please find on-line
the file <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/loopcons.dats"
TARGET="_top"
>loopcons.dats</A
>
containing the entirety of the code presented in this section plus some
testing code.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="template-based-support-for-late-binding"
>Template-Based Support for Late-Binding</A
></H2
><P
>&#13;When asked about the meaning of object-oriented programming (OOP),
Alan Kay once said that OOP to him meant only messaging, local retention
and protection and hiding of state-process, and extreme late-binding of all
things.
</P
><P
>&#13;In ATS, function templates can provide a highly flexible approach to
supporting late-binding (of function calls). Let us first take a look at a
simple example to see why late-binding can be so desirable. The following
code declares a datatype <FONT
COLOR="RED"
>intfloat</FONT
> such that each value of this
declared type represents either an integer or a floating point number (of
double precision):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4664"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">datatype</span>
<span class="staexp">intfloat <span class="keyword">=</span> <span class="dynexp">INT <span class="keyword">of</span> <span class="staexp">int</span></span> <span class="keyword">|</span> <span class="dynexp">FLOAT <span class="keyword">of</span> <span class="staexp">double</span></span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


In order to print values of the type <FONT
COLOR="RED"
>intfloat</FONT
>, we can implement
<FONT
COLOR="RED"
>print_intfloat</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4668"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
print_intfloat
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">intfloat</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> x <span class="keyword">of</span>
<span class="keyword">|</span> INT<span class="keyword">(</span>int<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_int<span class="keyword">(</span>int<span class="keyword">)</span>
<span class="keyword">|</span> FLOAT<span class="keyword">(</span>float<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_double<span class="keyword">(</span>float<span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>print_int</FONT
> and <FONT
COLOR="RED"
>print_double</FONT
> are monomorphic
functions for printing an integer and a floating point number (of double
precision), respectively. There are certainly many different ways to print
integers and floating point numbers, but <FONT
COLOR="RED"
>print_intfloat</FONT
> only
uses a particular one for integers (via <FONT
COLOR="RED"
>print_int</FONT
>) and a
particular one for floating point numbers (via <FONT
COLOR="RED"
>print_double</FONT
>).
One possibility of avoiding this form of extreme inflexibility is to define
a higher-order function <FONT
COLOR="RED"
>fprint_intfloat</FONT
> as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4676"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fprint_intfloat
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">intfloat</span>
<span class="keyword">,</span> print_int<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span>
<span class="keyword">,</span> print_double<span class="keyword">:</span> <span class="staexp">double</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> x <span class="keyword">of</span>
<span class="keyword">|</span> INT<span class="keyword">(</span>int<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_int<span class="keyword">(</span>int<span class="keyword">)</span>
<span class="keyword">|</span> FLOAT<span class="keyword">(</span>float<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_double<span class="keyword">(</span>float<span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


With <FONT
COLOR="RED"
>fprint_intfloat</FONT
>, one can decide to choose implementations
for <FONT
COLOR="RED"
>print_int</FONT
> and <FONT
COLOR="RED"
>print_double</FONT
> at a later stage. In
this regard, I say that higher-order functions can support a form of
late-binding. However, using higher-order functions in such a manner is not
without serious problems. Basically, any function that calls
<FONT
COLOR="RED"
>print_int</FONT
> either directly or indirectly needs to be turned into
a higher-order function, and the same applies to functions calling
<FONT
COLOR="RED"
>print_double</FONT
> as well. This style of programming with extensive
use of higher-order functions can soon become extremely unwieldy when the
number of functions grows large that need to be treated like
<FONT
COLOR="RED"
>print_int</FONT
> and <FONT
COLOR="RED"
>print_double</FONT
>.

</P
><P
>&#13;Instead of using higher-order functions, we can rely on template functions
to support late-binding (of function calls). For example, the following
code implements a template function <FONT
COLOR="RED"
>tprint_intfloat</FONT
> for
printing values of the type <FONT
COLOR="RED"
>intfloat</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4688"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
tprint_int<span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
tprint_double<span class="keyword">(</span><span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
tprint_intfloat<span class="keyword">(</span><span class="staexp">intfloat</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
tprint_int&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_int<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span>
tprint_double&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_double<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
tprint_intfloat&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> x <span class="keyword">of</span>
<span class="keyword">|</span> INT<span class="keyword">(</span>int<span class="keyword">)</span> <span class="keyword">=&gt;</span> tprint_int&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>int<span class="keyword">)</span>
<span class="keyword">|</span> FLOAT<span class="keyword">(</span>float<span class="keyword">)</span> <span class="keyword">=&gt;</span> tprint_double&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>float<span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Please note that the default implementations for <FONT
COLOR="RED"
>tprint_int</FONT
> and
<FONT
COLOR="RED"
>tprint_double</FONT
> are based on <FONT
COLOR="RED"
>print_int</FONT
> and <FONT
COLOR="RED"
>print_double</FONT
>,
respectively. As can be expected, the following code outputs two lines:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4694"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  tprint_intfloat&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>INT<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> print_newline<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [val] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  tprint_intfloat&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>FLOAT<span class="keyword">(</span><span class="dynexp">1.0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> print_newline<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [val] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


where the first line consists of the string "0" and the second one
the string "1.000000". The following code also outputs two lines:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4696"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">local</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
tprint_int&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">print!</span> <span class="keyword">(</span><span class="dynstr">"INT("</span><span class="keyword">,</span> x<span class="keyword">,</span> <span class="dynstr">")"</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span>
tprint_double&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">print!</span> <span class="keyword">(</span><span class="dynstr">"FLOAT("</span><span class="keyword">,</span> x<span class="keyword">,</span> <span class="dynstr">")"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span> <span class="comment">(* in-of-local *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  tprint_intfloat&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>INT<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> print_newline<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [val] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  tprint_intfloat&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>FLOAT<span class="keyword">(</span><span class="dynexp">1.0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> print_newline<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [val] *)</span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</p></PRE
><P
></P
></DIV
>


where the first line consists of the string "INT(0)" and the second one the
string "FLOAT(1.000000)"). In the latter case, the calls to template instances
<FONT
COLOR="RED"
>tprint_int&#60;&#62;</FONT
> and <FONT
COLOR="RED"
>tprint_double&#60;&#62;</FONT
> are compiled
according to the implementations for <FONT
COLOR="RED"
>tprint_int</FONT
> and <FONT
COLOR="RED"
>tprint_double</FONT
>
given between the keywords <FONT
COLOR="RED"
>local</FONT
> and <FONT
COLOR="RED"
>in</FONT
>.
</P
><P
>&#13;Please find on-line the file
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_FNTMPINT/intfloat.dats"
TARGET="_top"
>intfloat.dats</A
> containing the
entirety of the code presented in this section plus some testing code.
</P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML>
